<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="style.css" />
<title>Web book programming</title>
</head>
<body>  
<main dir="rtl">
  <div>
<section id="introduction">
    <h1>فصل اول: مبانی برنامه نویسی</h1>
<h2>مقدمه</h2>
<p><strong>برنامه نویسی چیست و چرا باید آن را یاد گرفت؟<br /></strong></p> 
    <p>برنامه‌نویسی اساساً راهی برای برقراری ارتباط با کامپیوترها است. فرآیند نوشتن دستورالعمل‌های دقیقی است که کامپیوترها می توانند درک و اجرا کنند. آن را به‌عنوان آموزش وظایف به یک ربات در نظر بگیرید، اما به‌جای دادن دستورات به زبان انسانی، از کد استفاده می‌کنیم.</p>
    <p>تصور کنید یک ربات در آشپزخانه خود دارید. برای درست کردن یک فنجان چای، ممکن است به آن بگویید: 
</p>
<ol>
<li>کتری را با آب پر کن. 
</li>
<li>آب را بجوشان. 
</li>
<li>یک چای کیسه ای را در یک فنجان قرار بده. 
</li>
<li>آب جوش را داخل فنجان بریز. 
</li>
<li>۳ دقیقه صبر کن.
</li>
</ol>
<p>برنامه‌نویسی یک کامپیوتر به شیوه مشابهی کار می کند، اما دستورالعمل‌ها دقیق‌تر هستند و ما از زبان‌های خاصی استفاده می‌کنیم که کامپیوترها می‌توانند آن‌ها را تفسیر کند.
</p>
</section>

<section id="request-response">
  <h2>چرا یادگیری کدنویسی؟</h2>
  <p>یادگیری کدنویسی دنیایی از امکانات را باز می کند. در اینجا فقط چند دلیل وجود دارد که چرا برنامه‌نویسی یک مهارت ارزشمند است:</p>
  <div>
    <ul>
      <li>حل مسئله: برنامه نویسی به شما می آموزد که منطقی فکر کنید و مشکلات را به صورت خلاقانه حل کنید.</li>
      <li>فرصت های شغلی: با توجه به اینکه همه چیز در حال حرکت آنلاین است، مهارت های برنامه‌نویسی در بسیاری از صنایع مورد تقاضا هستند.
</li>
      <li>ایده ها را زنده کنید: برنامه نویسی به شما امکان می دهد وب سایت ها، برنامه ها، بازی ها و موارد دیگر خود را بسازید.</li>
      <li>دنیای دیجیتال را درک کنید: به شما کمک می کند نحوه عملکرد نرم افزار و وب سایت هایی که هر روز از آنها استفاده می کنید را درک کنید.
</li>
    </ul>
  </div>
</section>
<section id="authentication">
  <h2>مفاهیم برنامه نویسی</h2>
  <p>بیایید یک مثال ساده ریم در نظر بگیریم تا قدرت برنامه نویسی را نشان دهیم. به ایجاد یک ماشین حساب بودجه شخصی فکر کنید. به جای محاسبه دستی هزینه ها و پس انداز خود در هر ماه، می توانید برنامه ای بنویسید که این کار را برای شما انجام دهد. درآمد و هزینه های ماهانه خود را وارد میکنید و برنامه پس انداز شما را محاسبه می کند. این یک مثال اساسی از خودکار کردن یک کار از طریق برنامه نویسی است.</p>
  <h5>در اینجا چند مفهوم پایه‌ای وجود دارد که می‌توانند در شروع به شما کمک کنند:</h5>
  <section id="Variables">
  <ol>
    <li> 
      متغیرها / Variables:
      </li>
      <p>
        یک متغیر در برنامه نویسی شبیه به جعبه ای در دنیای واقعی کار می کند که می توانید چیزی را در آن قرار دهید. در این حالت، شما اشیاء فیزیکی را در آن قرار نمی دهید، بلکه اطلاعات یا داده ها را در آن قرار می دهید. در برنامه نویسی به فرآیند «قرار دادن چیزی» می گویند.
      </p>
      <p>
        برای اینکه بتوانید به این کادر (متغیر) ارجاع دهید، نامی به آن می دهید. این نام به شما کمک می کند بعدا به راحتی به اطلاعات ذخیره شده در آن دسترسی داشته باشید. به عنوان مثال، اگر متغیری به نام سن دارید، مانند این است که یک جعبه با برچسب "سن" دارید که می توانید سن یک فرد را در آن ذخیره کنید.
      </p>
      <img src="/images/1.1 photo.png" width="450" alt="aks1"/>
      <p>
        مثال: <br/> تصور کنید می خواهید سن یک فرد را در برنامه خود ذخیره کنید. ابتدا یک متغیر ایجاد می‌کنید و نامی برای آن می‌گذارید که آنچه را که ذخیره می‌کند، به عنوان مثال سن، توصیف می‌کند. سپس به این متغیر یک مقدار اختصاص می‌دهید، مثلاً 30. در بسیاری از زبان‌های برنامه‌نویسی به این صورت است: <br/>age = 30; <br/>در این مثال:
<br/>age نام متغیر است مانند برچسب روی جعبه ما.
      </p>
      <p>= عملگر( Operator) انتساب است که برای تخصیص یک مقدار به متغیر استفاده می شود مانند قرار دادن یک آیتم در کادر.</p>
        <p>
          30  مقداری ( Value) است که به متغیر اختصاص می دهیم مانند موردی که در کادر قرار داده ایم.
<br/>بعد از اینکه یک مقدار را به یک متغیر اختصاص دادید، می توانید آن مقدار را بعداً با استفاده از نام متغیر در برنامه بازیابی کنید. بنابراین اگر بعداً می خواهید بررسی کنید که آیا فرد بالای 18 سال دارد، می توانید از شرایطی استفاده کنید که به این صورت است:
<div>
<img src="/images/1.2 photo.png" width="450" alt="aks2"/>
</div>
          
          استفاده از متغیرها برنامه شما را انعطاف پذیر و قابل استفاده مجدد می کند زیرا می توانید به راحتی مقادیری را که متغیرها نگه می دارند بدون نیاز به تغییر همه کدها تغییر دهید. می توانید تصور کنید که استفاده از متغیرها مانند نگه داشتن جعبه هایی است که می توانید محتویات آنها را در هر زمان بدون نیاز به تغییر برچسب روی جعبه (نام متغیر) تعویض کنید. <br/>در برنامه ها می توانید با مقادیر موجود در متغیرها محاسبه کنید، آنها را مقایسه کنید، از آنها در شرایط / Conditions استفاده کنید و موارد دیگر. متغیرها برای ایجاد انعطاف پذیری و پویایی برنامه ها بسیار مفید هستند. شما می توانید مقدار یک متغیر را در طول زمان اجرای برنامه خود تغییر دهید، به این معنی که رفتار برنامه شما می تواند مطابق با آن سازگار شود.
        </p>
      </li>
  
    </section>

    <section id="Data">

<h4> 2- انواع داده (Data):</h4>
<p>این‌ها انواع مختلفی از اطلاعاتی هستند که می‌توانید در متغیرها ذخیره کنید، مثل اعداد، متن (همچنین شناخته شده به عنوان رشته‌ها) یا مقادیر بولی (درست/غلط). البته، بیایید نگاهی دقیق‌تر به انواع مختلف داده‌های موجود در بیشتر زبان‌های برنامه‌نویسی بیندازیم و نمونه‌ای از هر کدام را ذکر کنیم:</p>
<ul>
  <li>اعداد صحیح (Integer, Int):
    <ul>
      <li>اعداد بدون اعشار هستند. آنها می‌توانند مثبت یا منفی باشند.</li>
      <li>مثال: <code>42</code>، <code>-7</code></li>
    </ul>
  </li>
  <li>اعداد ممیز شناور (Float):
    <ul>
      <li>اعدادی هستند که اعشار دارند. آنها برای مقادیر دقیق تر استفاده می‌شوند.</li>
      <li>مثال: <code>3.14</code>، <code>-0.001</code></li>
    </ul>
  </li>
  <li>رشته‌های کاراکتر (Strings):
    <ul>
      <li>دنباله‌ای از کاراکترها هستند که متن را نشان می‌دهند.</li>
      <li>مثال: "<code>سلام جهان</code>"، "<code>1234</code>"</li>
    </ul>
  </li>
  <li>ارزشهای حقیقت (بولیان Boolean):
    <ul>
      <li>مقادیر حقیقت را نشان می‌دهند و فقط می‌توانند دو مقدار بگیرند: true یا false.</li>
      <li>مثال: "<code>درست</code>"، "<code>نادرست</code>"</li>
    </ul>
  </li>
  <li>فهرست Arrays:
    <ul>
      <li>مجموعه‌های مرتب شده‌ای از عناصر هستند که می‌توانند انواع مختلفی از داده‌ها را در بر گیرند.</li>
      <li>مثال: "<code>[1، 2، 3]</code>"، "<code>["سیب"، "موز"، "گیلاس"]</code>"</li>
    </ul>
  </li>
  <li>تاپل ها (Tuple):
    <ul>
      <li>شبیه به لیست ها هستند، اما تغییر ناپذیرند.</li>
      <li>مثال: "<code>(1، "سلام"، درست است)</code>"</li>
    </ul>
  </li>
  <li>فرهنگ لغت (Dictionaries):
    <ul>
      <li>جفت کلیدها و مقادیر را ذخیره می‌کنند.</li>
      <li>مثال: "<code>{"name": "Emma"، "age": 30}</code>"</li>
    </ul>
  </li>
  <li>تعداد (مجموعه Set):
    <ul>
      <li>مجموعه‌هایی از عناصر منحصر به فرد بدون ترتیب خاصی هستند.</li>
      <li>مثال: "<code>{1، 2، 3، 4}</code>"</li>
      <p>هر یک از این نوع داده ها حوزه های کاربردی و ویژگی های خاص خود را دارند. هنگام برنامه نویسی، انتخاب نوع داده مناسب برای اطلاعات ذخیره شده به منظور نوشتن کد کارآمد و خوانا مهم است.</p>
    </ul>
  </li>
</ul>
</section>

<section id="Operators">

<h4>3- عملگرها (Operators):</h4>
<ul>
  <p>این نمادها به رایانه می‌گویند که چگونه با داده‌ها تعامل داشته باشد:</p>
  <li>حسابگری: (+، -، *، /) برای محاسبات.</li>
  <li>مقایسه: (==، !=، >، <) برای مقایسه مقادیر.</li>
  <li>منطقی: ( و and، یا or، نه not) برای ترکیب شرایط.</li>
</ul>
</section>

<br/>

<section></section>

<h4>4- شرط‌ها (Conditional Statements (If-Else:</h4>
<p>شرایط یک عنصر کلیدی در برنامه‌نویسی هستند، زیرا به برنامه اجازه می‌دهند تا بسته به اینکه معیارهای خاصی برآورده شده باشند یا نه، رفتارهای متفاوتی داشته باشد. دستورالعمل "if" اساسی‌ترین ابزار برای کنترل جریان برنامه بر اساس شرایط است. بیایید این مفهوم را با چند جزئیات و مثال بررسی کنیم:</p>

  <p>ساختار پایه دستورالعمل "if":</p> 
  <p>نحو پایه ای یک دستورالعمل "if" در اکثر زبان های برنامه نویسی مشابه است و از این اصل پیروی می کند:
</p>
<img src="/images/1.3 photo.png" width="450" alt=""/>
    
      <p>شرط ارزیابی می‌شود و اگر true باشد، دستورات داخل بلاک اجرا می‌شوند. اگر شرط false باشد، بلاک نادیده گرفته می‌شود.</p>
            <p>دستورالعمل های "if" پیشرفته:</p>

      <div><img src="/images/1.4 photo.png" width="450" alt=""/></div>
    
      <p>برای تصمیم‌گیری‌های پیچیده‌تر، می‌توان "if" را با "else" و "else if" گسترش داد که چندین شرط و اقدامات مربوطه را امکان پذیر می‌کند.</p>
      <br/>
      <p>مثال:</p>
      <p>فرض کنید می خواهیم برنامه ای بنویسیم که بر اساس دما، نوع لباس مناسب را انتخاب می کند:
</p>
      <img src="/images/1.5 photo.png" width="450" alt=""/>
    

  <p>عملگرهای منطقی:</p>

      <p>برای بیان شرایط پیچیده‌تر، می‌توانید از عملگرهای منطقی مانند && (و)، || (یا) و ! (نه) برای ترکیب چندین شرط استفاده کنید.</p>
      <p>مثال:
      </p>
      <img src="/images/1.6 photo.png" width="450" alt=""/>
      </section>
<section id="Loops">

<h4>5- حلقه‌ها (Loops):</h4>
<p>اگر می‌خواهید برنامه شما بارها و بارها کاری را انجام دهد، مثلاً گذر از لیستی از کارها، می‌توانید از حلقه‌ها استفاده کنید. یک حلقه به کامپیوتر می‌گوید که یک بلوک از دستورالعمل‌ها را تا زمانی که یک شرط خاص برآورده شود، تکرار کند. حلقه‌ها در برنامه‌نویسی برای مدیریت کارهای تکراری به طور کارآمد ضروری هستند. انواع مختلفی از حلقه‌ها در اکثر زبان‌های برنامه‌نویسی موجود هستند و هر کدام کاربردهای خاص خود را دارند. بیایید مفاهیم پایه و چند مثال را بررسی کنیم:</p>
<ol>
  <li>
    حلقه‌های For:
    <p>یک حلقه For زمانی استفاده می‌شود که دقیقاً می‌دانید چند بار باید یک بلوک از دستورات اجرا شود. این حلقه برای پیمایش در لیست‌ها (آرایه‌ها) یا سایر مجموعه‌ها بسیار مفید است.
</p>
<img src="/images/1.7 photo.png" width="450" alt="image for halghe for"/>

      <p>
        <strong>مثال عملی:</strong>
        <p>فرض کنید می‌خواهید اعداد 1 تا 5 را روی صفحه نمایش دهید:
</p>
<img src="/images/1.8 photo.png" width="450" alt="aks mesal amali"/>
      </p>
    <p> این مثال، متغیر i از 1 شروع می‌شود و تا زمانی که i کوچکتر یا مساوی 5 باشد، حلقه اجرا می‌شود. بعد از هر بار اجرا، i به اندازه 1 افزایش می‌یابد.
</p>
    
  </li>

  <li>
    حلقه‌های While:
  
      <p>
        <strong>مثال عملی:</strong>
        <p>یک حلقه While تا زمانی که یک شرط برقرار باشد، دستورات را اجرا می‌کند. این حلقه زمانی ایده‌آل است که تعداد دفعات اجرا از قبل مشخص نیست.</p>
        <img src="/images/1.9 photo.png" width="450" alt="aks baraye while">
      </p>
      <p><strong>مثال عملی:</strong></p>   
<p>
فرض کنید یک شمارنده دارید که تا زمانی که یک عدد تصادفی بزرگتر از 0.8 باشد، افزایش می‌یابد:

</p>
<img src="/images/1.10 photo.png" width="450" alt="aks mesal amali2"/>

  </li>


  <li>
    حلقه‌های Do-While:
  
      <p>حلقه Do-While شبیه به حلقه While است، با این تفاوت که دستورات حداقل یک بار قبل از بررسی شرط اجرا می‌شوند.</p>
      <img src="/images/1.11 photo.png" width="450" alt="aks do-while">
      
    <p><strong>مثال عملی:</strong></p>
<p>فرض کنید می‌خواهید یک پیام را حداقل یک بار نمایش دهید و سپس تا زمانی که کاربر می‌خواهد، آن را نمایش دهید:</p>   
<img src="/images/1.12 photo.png" width="450" alt=""/>
<p>حلقه‌ها ابزاری قدرتمند در برنامه‌نویسی برای جلوگیری از تکرار کد و کنترل اجرای دستورات بر اساس شرایط هستند. انتخاب بین حلقه‌های For، While و Do-While به موقعیت خاص و نوع شرطی که تکرار باید تحت آن انجام شود بستگی دارد</p>
  
  </li>
</ol>

<section id="Functions">
<h4>6- توابع (Functions): </h4>
  <p>
    یک تابع (Function) مجموعه‌ای از انجام دستورالعمل‌ها است که برای دادن یک کار خاص جمع‌آوری شده‌اند. می‌توان یک تابع را مثل یک برنامه کوچک درون برنامه‌ای خود تصور کرد. اگر بخواهید یک کار را چند بار انجام دهید، می‌توانید یک تابع بنویس و هر زمانی که نیاز دارید، آن را فراخوانی کنید.
  </p>
  <p>
    توابع یک مفهوم اساسی در برنامه‌نویسی هستند که برای ساختار و استفاده مجدد از کد ضروری هستند. آنها به شما امکان می‌دهند برنامه‌های پیچیده را به بخش‌های کوچکتر و قابل‌کنترل تقسیم کنید. یک تابع را می‌توان به عنوان یک "مینی برنامه" مستقل در نظر گرفت که یک کار خاص را انجام می‌دهد. در اینجا نحوه تعریف توابع، نحوه استفاده از پارامترها و نحوه فراخوانی آنها در کد خود را خواهید آموخت.
  </p>
  </h4>
  <p><strong>تعریف تابع:</strong></p>
  <p>تعریف یک تابع معمولاً شامل یک نام، لیست پارامترها و بلوکی از دستورات است که منطق واقعی تابع را شامل می‌شود.</p>
  <img src="/images/1.13 photo.png"  width="450" alt=""/>
    <ul>
      <li>
        <strong>نام:</strong> نامی که به تابع خود می‌دهید. باید وظیفه تابع را منعکس کند.
      </li>
      <li>
        <strong>پارامترها:</strong> متغیرهایی که هنگام فراخوانی تابع مقادیر دریافت می‌کنند. آنها به تابع اجازه می‌دهند تا با ورودی‌های مختلف کار کند.
      </li>
      <li>
        <strong>دستورات:</strong> کدی که وظیفه واقعی تابع را انجام می‌دهد.
      </li>
      <li>
        <strong>Return:</strong> کلمه کلیدی که برای بازگرداندن یک مقدار از تابع استفاده می‌شود. این اختیاری است و به وظیفه تابع بستگی دارد.
      </li>
    </ul>
  
  <p><strong>فراخوانی تابع:</strong></p>
  <p> پس از تعریف یک تابع، می‌توان آن را با ذکر نام آن و ارسال مقادیر پارامترهای مورد نیاز فراخوانی کرد.
  </p>
  <img src="/images/1.14 photo.png" width="450" alt="aks addiere"/>
  
  <p>در این مثال، یک تابع ساده addiere تعریف می‌شود که دو عدد را به عنوان پارامتر می‌گیرد و مجموع آنها را برمی‌گرداند. سپس تابع با مقادیر 5 و 3 فراخوانی می‌شود و نتیجه چاپ می‌شود.</p>

<p> <strong>
تعریف پارامترها و آرگومان‌ها
</strong> 
</p>
<ul>
<li>پارامترها متغیرهایی هستند که در تعریف تابع مشخص شده‌اند.</li>
<li>آرگومان‌ها مقادیر واقعی هستند که هنگام فراخوانی به یک تابع ارسال می‌شوند.
</li>
</ul>
  <p><strong>مزایای توابع:</strong>
    <ul>
      <li>
        <strong>استفاده مجدد از کد:</strong> توابع به شما این امکان را می‌دهند که یک بلوک کد را بنویسید که می‌توان چندین بار بدون نیاز به نوشتن مجدد آن اجرا کرد.
      </li>
      <li>
        <strong>مدولار بودن:</strong> توابع به شما کمک می‌کنند تا برنامه خود را به بخش‌های کوچکتر و قابل‌مدیریت‌تر تقسیم کنید.
      </li>
      <li>
        <strong>قابلیت نگهداری:</strong> برنامه هایی که از توابع با ساختار مناسب استفاده می کنند، درک، آزمایش و نگهداری آسان تر هستند.
      </li>
    </ul>
    <p>توابع ابزاری قدرتمند در دستان یک برنامه‌نویس هستند و نقش کلیدی در ایجاد کدهای تمیز، کارآمد و قابل‌استفاده مجدد دارند. با یادگیری نحوه استفاده موثر از توابع، می‌توانید پیچیدگی برنامه‌های خود را به طور قابل‌توجهی کاهش داده و زمان توسعه آنها را کوتاه کنید. </p>
    <p>ما برخی از مفاهیم اساسی برنامه نویسی، از جمله متغیرها، انواع داده ها، شرایط، حلقه ها و توابع را پوشش داده ایم. این موضوعات پایه و اساس شروع برنامه نویسی را تشکیل می دهند. با این حال، چندین مفهوم و موضوع دیگر وجود دارد که مهم هستند و ما هنوز به آنها نپرداخته ایم. در اینجا به برخی از آنها اشاره می کنیم:</p>
    <ol>
      <li>رسیدگی به استثناء / Exception Handling مدیریت خطا برای پاسخ به خطاها یا موقعیت های غیرمنتظره ای که ممکن است در حین اجرای یک برنامه رخ دهد، مهم است. با استفاده از بلوک های try-catch، می توانید برنامه خود را قوی تر و پایدارتر کنید.</li>
      <li>برنامه نویسی شی گرا / Objektorientierte Programmierung برنامه نویسی شی گرا الگوی مبتنی بر مفاهیمی مانند کلاس ها، اشیا، وراثت، چندشکلی و کپسوله سازی است. OOP به سازماندهی کد به شیوه ای ساختاریافته و مدولار کمک می کند که قابلیت نگهداری و توسعه پذیری برنامه ها را بهبود می بخشد.</li>
      <li>ساختارهای داده / Data Structures علاوه بر انواع داده های اساسی، درک ساختارهای داده پیچیده تر مانند پشته ها، صف ها، لیست های پیوندی، درختان و نمودارها برای ذخیره سازی، مدیریت و پردازش کارآمد داده ها مهم است.</li>
      <li> الگوریتم / Algorithms مطالعه الگوریتم‌ها، از جمله الگوریتم‌های مرتب‌سازی و جستجو، برای بهبود استراتژی‌های حل مسئله و کارایی کد شما بسیار مهم است.</li>
      <li> پایگاه های اطلاعاتی / Databases درک پایگاه های داده و SQL (زبان پرس و جوی ساختاریافته) برای ذخیره، پرس و جو و مدیریت موثر داده ها ضروری است. این شامل پایگاه های داده رابطه ای، پایگاه های داده NoSQL و مفاهیم تراکنش ها و عادی سازی می شود.</li>
      <li>نسخه و گیت / Versioning and Git نسخه کد، به ویژه استفاده از Git، در توسعه نرم افزار مدرن ضروری است. این به شما امکان می دهد تغییرات کد خود را ردیابی کنید، با دیگران همکاری کنید و پروژه ها را به طور موثر مدیریت کنید.</li>
      <li> تست / Test  تست کد شما، از جمله تست های واحد، تست های یکپارچه سازی، و تست های سیستم، برای اطمینان از صحت، قابلیت اطمینان و کیفیت برنامه های شما حیاتی است.</li>
      <li>اصول توسعه نرم افزار / Software Development Principles  درک اصول اولیه توسعه نرم افزار مانند DRY (تکرار نکنید)، KISS (ساده، احمقانه نگه دارید)، و YAGNI (به آن نیاز ندارید) می تواند به شما در برنامه نویسی موثرتر و نوشتن کد بهتر کمک کند.</li>
    </ol>
  <p>این موضوعات، همراه با اصول اولیه ای که قبلاً در مورد آن صحبت کردیم، پایه محکمی برای دانش برنامه نویسی شما فراهم می کند. البته، بهترین راه برای یادگیری، تمرین و کار بر روی پروژه های واقعی است تا این مفاهیم را در عمل ببینید و درک کنید که چگونه با هم برای ایجاد نرم افزار کار می کنند.</p>

</section>



<section id="endpoints">
  <h2>کامپایل کردن یعنی چی؟
</h2>
<img src="/images/1.15 photo.png" width="450" alt="">
<section>
<p>کامپایل یک فرآیند اساسی در توسعه نرم افزار است که کد نوشته شده در یک زبان برنامه نویسی سطح بالا (کد منبع) را به کد ماشین (کد باینری) تبدیل می کند که پردازنده کامپیوتر می تواند مستقیماً آن را اجرا کند. ابزار مسئول این تبدیل کامپایلر نامیده می شود.</p>

<p>در اینجا خلاصه ای از آنچه کامپایل شامل می شود آورده شده است:</p>

<ul>
    <li>
        <p><strong>تجزیه و تحلیل واژگانی - Lexical Analysis:</strong> کامپایلر کد منبع را می خواند و آن را به عناصر معنی دار به نام نشانه ها تقسیم می کند. این نشانه ها می توانند کلمات کلیدی، نمادها، عملگرها، شناسه ها و غیره باشند.</p>
    </li>
    <li>
        <p><strong>تجزیه و تحلیل نحو (تجزیه) - (Syntax Analysis (Parsing:</strong> در این مرحله، کامپایلر نشانه ها را در برابر قوانین نحوی زبان برنامه نویسی بررسی می کند تا یک نمایش درخت مانند از ساختار کد منبع ایجاد کند. این درخت به درخت نحو انتزاعی (AST) معروف است.</p>
    </li>
    <li>
        <p><strong>تجزیه و تحلیل معنایی - Semantic Analysis:</strong> کامپایلر AST را برای سازگاری معنایی تأیید می کند، و اطمینان حاصل می کند که کد منبع به قوانین معنایی زبان پایبند است. این شامل بررسی نوع، وضوح محدوده، و شناسایی استفاده از متغیرهای اعلام نشده است.</p>
    </li>
    <li>
        <p><strong>بهینه سازی - Optimization:</strong> کامپایلر ممکن است بهینه سازی های مختلفی را برای افزایش کارایی کد ماشین حاصل انجام دهد. این می تواند شامل حذف کد اضافی، به حداقل رساندن استفاده از حافظه و بهینه سازی مسیرهای اجرا باشد.</p>
    </li>
    <li>
        <p><strong>تولید کد - Code Generation:</strong> کامپایلر AST بهینه شده را به کد ماشین مخصوص معماری پردازنده هدف تبدیل می کند. این کد ماشین همان چیزی است که کامپیوتر می تواند اجرا کند.</p>
    </li>
    <li>
        <p><strong>پیوند - Linking:</strong> در بسیاری از موارد، به ویژه برای برنامه های پیچیده، کامپایلر نیاز دارد تا کدهای ماشین را از فایل های منبع و کتابخانه های مختلف به یکدیگر پیوند دهد. این مرحله مراجع خارجی را حل می کند و یک فایل اجرایی یا باینری نهایی تولید می کند.</p>
    </li>
</ul>
</section>
<section id="nemoneh-compile">
<br/>
<p><strong>نمونه‌ای از کامپایل</strong></p>

<p>یک برنامه ساده را در نظر بگیرید که به زبان C نوشته شده است:</p>
<img src="/images/1.16 photo.png " width="450" alt=""/>

<p>وقتی این برنامه را با استفاده از یک کامپایلر C کامپایل می‌کنید (مانند gcc برای مجموعه کامپایلر گنو)، کامپایلر مراحل ذکر شده در بالا را طی می‌کند تا این کد C سطح بالا را به کد ماشینی تبدیل کند که رایانه می‌تواند اجرا کند. دستور کامپایل این برنامه ممکن است به صورت زیر باشد:</p>

<img src="/images/1.17 photo.png" width="450" alt=""/>

<p>این به gcc می گوید که فایل منبع hello.c را بگیرد، آن را کامپایل کند و یک فایل اجرایی به نام hello را خروجی دهد. اجرای ./hello در ترمینال، کد دستگاه را اجرا می کند و "Hello, world!" به کنسول</p>

<p>کامپایل بسیار مهم است زیرا:</p>

<ul>
    <li>
        <p>کدهای قابل خواندن توسط انسان را به شکلی ترجمه می کند که ماشین ها بتوانند آن را درک و اجرا کنند.</p>
    </li>
    <li>
        <p>کد را برای عملکرد بهینه می کند و از منابع کامپیوتر استفاده بهینه می کند.</p>
    </li>
    <li>
        <p>بررسی خطا در مراحل اولیه، گرفتن نحو و برخی از خطاهای معنایی را قبل از اجرای برنامه فعال می کند.</p>
    </li>
    <li>
        <p>با اجازه دادن به یک کد سطح بالا برای کامپایل شدن کدهای سطح بالا برای معماری های مختلف، با کامپایلر که مشخصات هر معماری هدف را مدیریت می کند، قابلیت حمل را تسهیل می کند.</p>
    </li>
</ul>

<p>به طور خلاصه، کامپایل یک مرحله حیاتی در فرآیند توسعه نرم افزار است، که شکاف بین منطق انسانی بیان شده در کد منبع و دستورالعمل های باینری را که سخت افزار رایانه می تواند اجرا کند، پر می کند.</p>
</section>


<section id="zaban">
<h3>مروری کوتاه بر زبان های برنامه نویسی</h3>
<p>در طول این کتاب، چندین زبان برنامه‌نویسی را بررسی خواهیم کرد که هر کدام اهداف متفاوتی دارند:</p>
<ul>
<li>HTML و CSS: اینها به خودی خود زبان برنامه نویسی نیستند، اما برای ایجاد و طراحی صفحات وب ضروری هستند. HTML را به عنوان اسکلت (ساختار) یک صفحه وب و CSS را به عنوان پوسته (استایل) در نظر بگیرید.</li>
<li>JavaScript: این یک زبان برنامه نویسی واقعی است که تعامل را به صفحات وب اضافه می کند. می خواهید یک دکمه هنگام کلیک عملکردی داشته باشد؟ جاوا اسکریپت پاسخ شماست.</li>
<li>PHP: یک زبان اسکریپت نویسی سمت سرور که برای ایجاد وب سایت های پویا استفاده می شود که با پایگاه های داده تعامل دارند.</li>
</ul>
</section>


<section id="Dark">
<p> <strong>درک کامپیوترها و کد
</strong></p>
<img src="/images/1.18 photo.png" width="450" alt=""/>

<p>تا پایان این کتاب، درک خوبی از این زبان‌ها به دست خواهید آورد و می‌توانید پروژه‌های وب تعاملی و پویا خود را ایجاد کنید. سفر ما از اصول اولیه شروع می شود و به تدریج به سمت مفاهیم پیچیده‌تر حرکت می‌کند. هیچ تجربه قبلی لازم نیست—فقط تمایل به یادگیری.</p>

<p>شروع این سفر نه تنها شما را به مهارت‌های ارزشمندی مجهز می‌کند، بلکه قلمرو جدیدی از خلاقیت و حل مسئله را نیز باز می‌کند. چه هدف شما دنبال کردن حرفه‌ای در فناوری باشد یا صرفاً بخواهید نحوه ایجاد محصولات دیجیتال را کشف کنید، برنامه‌نویسی مسیری ارزشمند را ارائه می‌دهد.</p>

<p>به یاد داشته باشید، هر برنامه‌نویس ماهری روزی یک مبتدی بوده است. سفر شما از هم اکنون آغاز می‌شود و من اینجا هستم تا در هر مرحله شما را راهنمایی کنم.</p>
</section>
<section id="rahandaz">
<p><strong>راه‌اندازی جعبه ابزار</strong></p>
<p>اکنون که مبانی برنامه نویسی و اهمیت آن را به عنوان یک مهارت ارزشمند برای یادگیری پوشش داده‌ایم، زمان آن رسیده است که ابزارهایی را که برای شروع ساخت پروژه‌های خود نیاز دارید راه‌اندازی کنید. در این فصل، ما شما را در انتخاب یک ویرایشگر کد، درک مرورگرهای وب و راه اندازی یک محیط توسعه محلی در یک سرور لینوکس اوبونتو با Nginx و وردپرس راهنمایی خواهیم کرد.</p>
</section>
<section id="editor">
<p><strong>انتخاب یک ویرایشگر متن یا ویرایشگر کد</strong></p>

<p>قبل از اینکه بتوانید شروع به نوشتن کد کنید، به یک ویرایشگر متن نیاز دارید- جایی که بیشتر وقت خود را به عنوان یک توسعه‌دهنده در آن می‌گذرانید. در اینجا چند گزینه‌ی محبوب وجود دارد:</p>

<ul>
    <li>
        <p><strong>Visual Studio Code (VS Code):</strong> رایگان، متن‌باز، و در دسترس برای لینوکس، ویندوز، و macOS. VS Code بسیار قابل سفارشی‌سازی است و دارای یک کتابخانه بزرگ از افزونه‌ها برای پشتیبانی از زبان‌ها و ابزارهای برنامه‌نویسی مختلف است.</p>
    </li>
    <li>
        <p><strong>Sublime Text:</strong> این برنامه به دلیل سرعت و کارایی خود شهرت دارد، رابط کاربری براق و ویژگی‌های قدرتمندی را ارائه می دهد. دانلود و ارزیابی آن رایگان است، اما برای استفاده مداوم به مجوز نیاز دارد.</p>
    </li>
    <li>
        <p><strong>Atom:</strong> یک ویرایشگر رایگان و متن‌باز که توسط GitHub ایجاد شده، که پشتیبانی عالی برای همکاری و کنترل نسخه ارائه می‌کند.</p>
    </li>
</ul>

<p>هنگام انتخاب یک ویرایشگر متن، اولویت‌های شخصی خود از جمله سهولت استفاده، افزونه‌ها یا پلاگین‌های موجود، و پشتیبانی از زبان‌هایی که استفاده می‌کنید را در نظر بگیرید.</p>
</section>

<section id="browser">
<p><strong>مرورگرهای وب و نقش آنها</strong></p>

<p>مرورگرهای وب پنجره شما به اینترنت هستند و نقش مهمی در توسعه وب ایفا می‌کنند. آنها کدهای HTML، CSS، و JavaScript را برای نمایش صفحات وب تفسیر می‌کنند. مرورگرها برای توسعه‌دهندگان همچنین ابزارهایی (اغلب «ابزارهای توسعه‌دهنده» یا «DevTools» نامیده می‌شوند) را برای تست و اشکال‌زدایی پروژه‌های وب ارائه می‌دهند.</p>

<ul>
    <li>
        <p><strong>Google Chrome:</strong> به طور گسترده استفاده می‌شود، با DevTools قوی برای اشکال‌زدایی و آزمایش برنامه‌های وب.</p>
    </li>
    <li>
        <p><strong>Mozilla Firefox:</strong> ابزارهای جامعی را برای توسعه‌دهندگان ارائه می‌دهد، از جمله ویژگی‌های منحصر به فردی که در سایر مرورگرها یافت نمی‌شوند.</p>
    </li>
    <li>
        <p><strong>Safari:</strong> برای آزمایش وب‌سایت‌ها در دستگاه‌های اپل با مجموعه‌ای از DevTools های خودش، ترجیح داده می‌شود.</p>
    </li>
</ul>

<p>این یک تصمیم عالی است! HTML (HyperText Markup Language) پایه و اساس وب و اولین قدم به سوی دنیای توسعه وب است. HTML به شما امکان می‌دهد ساختار و محتوای صفحات وب را تعریف کنید. بیایید با چند اصل شروع کنیم:</p>
</section>
<!--fasle2-->


<section id="chapter2"> 
<h3>فصل دوم</h3>
</section>


<section id="Hyper">
<p><strong>Hyper Text Markup Language</strong></p>

<p>HTML (زبان نشانه‌گذاری ابرمتن) پایه و اساس هر وب سایتی است. این یک زبان نشانه‌گذاری است که برای تعریف ساختار و محتوای یک صفحه وب استفاده می‌شود. با HTML می‌توانید متن را قالب‌بندی کنید، تصاویر و ویدیوها را درج کنید، لینک‌ها را ایجاد کنید و کارهای بسیار بیشتری انجام دهید. هر سند HTML با یک تگ &lt;html&gt; شروع می‌شود و با یک تگ &lt;/html&gt; به پایان می‌رسد. محتوای وب سایت در داخل این تگ ها قرار می‌گیرد و به عناصر مختلف تقسیم می‌شود.</p>
</section>

<section id="sakhtar">
<p><strong>ساختار اصلی یک سند HTML</strong></p>

<p>یک سند HTML ساده از چند عنصر اساسی تشکیل شده است که ساختار صفحه را مشخص می‌کند. به عنوان مثال:</p>
<img src="/images/2.1 photo.png" width="450" alt=""/>

<ul>
    <li><code>&lt;!DOCTYPE html&gt;</code>: نوع سند و نسخه HTML (در این مورد HTML5) را اعلام می‌کند.</li>
    <li><code>&lt;html&gt;</code>: عنصر ریشه‌ای که کل سند HTML را در بر می‌گیرد.</li>
    <li><code>&lt;head&gt;</code>: حاوی ابرداده و پیوندهایی به منابع خارجی مانند فایل‌های CSS است. آنچه در <code>&lt;head&gt;</code> است معمولاً مستقیماً در وب‌سایت نمایش داده نمی‌شود.</li>
    <li><code>&lt;meta charset="utf-8"&gt;</code>: این عنصر مجموعه نویسه‌هایی را که سند شما باید استفاده کند را روی UTF-8 تنظیم می‌کند.</li>
    <li><code>&lt;meta name="viewport" content="width=device-width"&gt;</code>: این عنصر viewport تضمین می‌کند که صفحه در عرض درگاه نمایش رندر می‌شود، و از باز کردن صفحه‌ها توسط مرورگرهای تلفن همراه و سپس کوچک کردن آنها جلوگیری می‌کند.</li>
    <li><code>&lt;title&gt;</code>: عنوان صفحه وب را که در نوار عنوان مرورگر نمایش داده می‌شود را مشخص می‌کند.</li>
    <li><code>&lt;body&gt;&lt;/body&gt;</code>: عنصر <code>&lt;body&gt;</code>. این شامل تمام محتوایی است که می‌خواهید هنگام بازدید از صفحه شما به کاربران وب نشان دهید، خواه متن، عکس، ویدیو، بازی، آهنگ‌های صوتی قابل پخش یا هر چیز دیگری.</li>
</ul>
</section>

<section id="HTML Elements">
<p><strong>HTML Elements</strong></p>

<p>یک عنصر HTML از یک تگ شروع، محتوا و یک تگ پایان تشکیل شده است. تگ شروع و تگ پایان نام یکسانی دارند، با این تفاوت که تگ پایان یک اسلش قبل از نام دارد.</p>
<img src="/images/2.2 photo.png" width="450" alt=""/>

<p>بخش‌های اصلی عنصر به شرح زیر است:</p>

<ul>
    <li><strong>تگ باز / opening tag:</strong> این شامل نام عنصر (در این مورد p) است که در براکت های زاویه باز و بسته پیچیده شده است. این نشان می دهد که عنصر از کجا شروع می شود یا شروع به اثر می کند - در این مورد که پاراگراف شروع می شود.</li>
    <li><strong>تگ بسته شدن / closing tag:</strong> این تگ همانند تگ افتتاحیه است، با این تفاوت که قبل از نام عنصر دارای یک اسلش رو به جلو است. این نشان می دهد که عنصر به کجا ختم می شود - در این مورد جایی که پاراگراف به پایان می رسد. عدم اضافه کردن برچسب بسته شدن یکی از خطاهای استاندارد مبتدی است و می تواند به نتایج عجیبی منجر شود.</li>
    <li><strong>محتوا / content:</strong> این محتوای عنصر است که در این مورد فقط متن است.</li>
    <li><strong>عنصر / element:</strong> تگ افتتاحیه، تگ بسته شدن و محتوا با هم عنصر را تشکیل می دهند.</li>
</ul>

<p>عناصر همچنین می توانند ویژگی هایی داشته باشند که به شکل زیر هستند:</p>
<img src="/images/2.3 photo.png" width="450" alt=""/>


    <p>ویژگی ها حاوی اطلاعات اضافی درباره عنصری هستند که نمی خواهید در محتوای واقعی ظاهر شوند. در اینجا، class نام ویژگی و "editor-note" مقدار ویژگی است. ویژگی class به شما امکان می دهد به عنصر یک شناسه غیر منحصر به فرد بدهید که می تواند برای هدف قرار دادن آن (و هر عنصر دیگر با مقدار کلاس مشابه) با اطلاعات سبک و چیزهای دیگر استفاده شود. برخی از ویژگی ها هیچ ارزشی ندارند، مانند مورد نیاز.</p>
    <p>ویژگی هایی که یک مقدار را تعیین می‌کنند همیشه دارای:</p>
        <ul>
            <li>فاصله بین آن و نام عنصر (یا ویژگی قبلی، اگر عنصر قبلاً یک یا چند ویژگی داشته باشد).</li>
            <li>نام مشخصه که با علامت مساوی همراه است.</li>
            <li>مقدار مشخصه با علامت نقل قول باز و بسته می شود.</li>
        </ul>
    </p>
</ul>
<section id="Nesting elements">

<p><strong>عناصر تودرتو / Nesting elements</strong></p>

<p>شما می توانید عناصر را درون عناصر دیگر نیز قرار دهید - به این حالت تودرتو می گویند. اگر بخواهیم بگوییم که گربه ما بسیار بداخلاق است، می‌توانیم کلمه "بسیار" را در یک عنصر <code>&lt;strong&gt;</code> بپیچیم، به این معنی که این کلمه باید به شدت تاکید شود:</p>
  <img src="/images/2.4 photo.png" width="450" alt=""/>

<p>با این حال، باید مطمئن شوید که عناصر شما به درستی تو در تو قرار گرفته اند. در مثال بالا ابتدا عنصر <code>&lt;p&gt;</code> و سپس عنصر <code>&lt;p&gt;</code> را باز کردیم. بنابراین، ابتدا باید عنصر <code>&lt;/strong&gt;</code> و سپس عنصر <code>&lt;/p&gt;</code> را ببندیم. موارد زیر نادرست است:</p>

<img src="/images/2.5 photo.png" width="450" alt=""/>

<p>عناصر باید به درستی باز و بسته شوند تا به وضوح در داخل یا خارج یکدیگر قرار گیرند. اگر همانطور که در بالا نشان داده شده با هم همپوشانی داشته باشند، مرورگر وب شما سعی می کند بهترین حدس را در مورد آنچه می خواستید بگویید، انجام دهد، که می تواند منجر به نتایج غیرمنتظره شود. پس این کار را نکنید!</p>
</section>

<section id="Void elements">
<p><strong>عناصر خالی / Void elements</strong></p>
<p>برخی از عناصر محتوایی ندارند و عناصر خالی نامیده می شوند. عنصر <code>&lt;img&gt;</code> را که قبلاً در صفحه HTML خود داریم، در نظر بگیرید:</p>
<img src="/images/2.6 photo.png" width="450" alt=""/>
<p>این شامل دو ویژگی است، اما هیچ برچسب <code>&lt;/img&gt;</code> بسته و محتوای داخلی وجود ندارد. این به این دلیل است که یک عنصر تصویر محتوا را نمی‌پوشاند تا بر آن تأثیر بگذارد. هدف آن قرار دادن یک تصویر در صفحه HTML در مکانی است که ظاهر می شود.</p>
</section>
</section>

<section id="Avalieh">
<h3>برخی از عناصر اولیه
</h3>
<section id="Text" >
<h3>تصاویر / Images</h3>

<p>همانطور که قبلاً گفتیم، یک تصویر را در صفحه ما در موقعیتی که ظاهر می شود تعبیه می کند. این کار را از طریق ویژگی <code>src</code> (source) انجام می دهد که حاوی مسیر فایل تصویری ما است.</p>
<img src="/images/2.7 photo.png" width="450" alt=""/>

<p>ما همچنین یک ویژگی <code>alt</code> (جایگزین) قرار داده ایم. در ویژگی <code>alt</code>، متن توصیفی را برای کاربرانی که نمی توانند تصویر را ببینند، مشخص می کنید، احتمالاً به دلایل زیر:</p>

<ol>
    <li>آنها دچار اختلال بینایی هستند. کاربرانی که دارای اختلالات بینایی قابل توجهی هستند اغلب از ابزارهایی به نام صفحه خوان برای خواندن متن جایگزین برای آنها استفاده می کنند.</li>
    <li>مشکلی رخ داده است که باعث شده تصویر نمایش داده نشود. به عنوان مثال، سعی کنید عمدا مسیر داخل ویژگی <code>src</code> خود را تغییر دهید تا آن را نادرست کنید. اگر صفحه را ذخیره کرده و مجدداً بارگذاری کنید، باید چیزی شبیه به این را به جای تصویر ببینید:</li>
    <img src="/images/2.8 photo.png" width="450" alt="">
</ol>

<p>کلمات کلیدی متن جایگزین "descriptive text" هستند. متن جایگزینی که می نویسید باید اطلاعات کافی را در اختیار خواننده قرار دهد تا ایده خوبی از آنچه که تصویر منتقل می کند داشته باشد. در این مثال، متن فعلی ما "My test image" اصلا خوب نیست. یک جایگزین بسیار بهتر برای لوگوی فایرفاکس ما "آرم فایرفاکس: روباهی شعله ور زمین را احاطه کرده است."</p>
</section>
<section id="headings">
<h3>سرفصل ها / Heading</h3>

<p>عناصر عنوان به شما این امکان را می دهند که مشخص کنید که قسمت های خاصی از محتوای شما عنوان یا عنوان فرعی باشد. همانطور که یک کتاب دارای عنوان اصلی، عنوان فصل و زیرنویس است، یک سند HTML نیز می تواند. HTML شامل 6 سطح عنوان، <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> است، اگرچه معمولاً حداکثر از 3 تا 4 استفاده می کنید:</p>
<img src="/images/2.9 photo.png" width="450" alt="">

<p style="color: red;">توجه: هر چیزی که در HTML بین <code>&lt;!--</code> و <code>--&gt;</code> باشد یک Comment HTML است. مرورگر توضیحات را در هنگام ارائه کد نادیده می گیرد. به عبارت دیگر، آنها در صفحه قابل مشاهده نیستند - تنها در کد. توضیحات HTML راهی برای نوشتن یادداشت های مفید در مورد کد یا منطق خود است.</p>

<p>اکنون سعی کنید یک عنوان مناسب به صفحه HTML خود درست بالای عنصر <code>&lt;img&gt;</code> خود اضافه کنید.</p>

<p style="color: red;">توجه: خواهید دید که عنوان سطح 1 شما دارای سبک ضمنی است. از عناصر عنوان برای بزرگ‌تر یا پررنگ‌تر کردن متن استفاده نکنید، زیرا برای دسترسی و دلایل دیگری مانند SEO استفاده می‌شوند. سعی کنید دنباله ای معنادار از سرفصل ها در صفحات خود بدون رد شدن از سطوح ایجاد کنید.</p>
</section>
<section id="Paragraph">
<h3>پاراگراف ها / Paragraphs</h3>

<p>همانطور که در بالا توضیح داده شد، عناصر <code>&lt;p&gt;</code> برای شامل پاراگراف های متن هستند. هنگام علامت‌گذاری محتوای متنی معمولی، اغلب از این موارد استفاده می‌کنید:</p>
<img src="/images/2.10 photo.png" width="450" alt=""/>
</section>
<section id="List">
<h3>لیست ها / Lists</h3>

<p>بسیاری از محتوای وب لیست است و HTML عناصر ویژه ای برای آنها دارد. علامت گذاری لیست ها همیشه از حداقل 2 عنصر تشکیل شده است. رایج ترین انواع لیست لیست های مرتب و نامرتب هستند:</p>

<ol>
    <li><strong>لیست های نامرتب:</strong> برای لیست هایی هستند که ترتیب اقلام در آنها مهم نیست، مانند لیست خرید. اینها در یک عنصر <code>&lt;ul&gt;</code> پیچیده شده اند.</li>
    <li><strong>لیست های مرتب:</strong> برای لیست هایی هستند که ترتیب اقلام مهم است، مانند دستور پخت. اینها در یک عنصر <code>&lt;ol&gt;</code> پیچیده شده اند.</li>
</ol>

<p>هر آیتم داخل لیست ها داخل یک عنصر <code>&lt;li&gt;</code> (مورد لیست) قرار می گیرد.</p>

<p>به عنوان مثال، اگر بخواهیم بخشی از پاراگراف زیر را به لیست تبدیل کنیم:</p>
<img src="/images/2.11 photo.png" width="450" alt=""/>

<p>ما می توانیم نشانه گذاری را به این تغییر دهیم:</p>
<img src="/images/2.12 photo.png" width="450" alt=""/>
</section>

<section id="Link">
<h3>پیوندها / Links</h3>

<p>پیوندها بسیار مهم هستند - آنها چیزی هستند که وب را به یک وب تبدیل می کنند! برای افزودن یک پیوند، باید از یک عنصر ساده استفاده کنیم - <code>&lt;a&gt;</code>  شکل کوتاه "anchor" است. برای تبدیل متن داخل پاراگراف به پیوند، مراحل زیر را دنبال کنید:</p>

<ol>
    <li>متنی را انتخاب کنید. ما متن "Mozilla Manifesto" را انتخاب کردیم.</li>
    <li>متن را در یک عنصر <code>&lt;a&gt;</code>بپیچید، همانطور که در  زیر نشان داده شده است:</li>
      <img src="images/2.13 photo.png" width="450" alt=""/>
          <li>مطابق شکل زیر به عنصر <a> یک ویژگی href بدهید:</li>
          <img src="/images/2.14 photo.png" width="450" alt=""/>
          <li>مقدار/ Value این ویژگی را با آدرس وب که می‌خواهید پیوند به آن اشاره کند پر کنید:</li>
          <img src="images/2.15 photo.png" width="450" alt=""/>
            <li>اگر قسمت https یا http به نام پروتکل را در ابتدای آدرس وب حذف کنید، ممکن است نتایج غیرمنتظره ای دریافت کنید. پس از ایجاد یک پیوند، روی آن کلیک کنید تا مطمئن شوید که آن را به جایی که می خواهید ارسال می کند.</li>
</ol>
<p style="color: red;">توجه: href ممکن است در ابتدا مانند یک انتخاب نسبتا مبهم برای نام یک ویژگی به نظر برسد. اگر در به خاطر سپردن آن مشکل دارید، به یاد داشته باشید که مخفف مرجع فرامتن است.</p>

<p>برای شروع کار با HTML، می توانید به سادگی از یک ویرایشگر متن مانند Notepad (ویندوز)، (TextEdit (Mac یا یک ویرایشگر کد مانند Visual Studio Code یا Sublime Text استفاده کنید. فایل خود را با پسوند html. ذخیره کنید و آن را در یک مرورگر وب باز کنید تا نتیجه را ببینید.</p>

<p>اکنون فایل را به صورت .html ذخیره کنید، به عنوان مثال "index.html" و سپس فایل را با مرورگری مانند Firefox یا Google Chrome باز کنید.</p>

<p>اگر تمام دستورالعمل‌های این مقاله را دنبال کرده‌اید، باید به صفحه‌ای برسید که شبیه صفحه زیر است:</p>

<p>index.html</p>

<img src="/images/2.16 photo.png" width="450" alt=""/>
<div>
    <img src="/images/2.17 photo.png" width="450" alt=""/>
</div>

<p>مثال دوم:</p>

<p>یک ویرایشگر باز کنید و کد زیر را قرار دهید. سپس فایل را به عنوان index.html ذخیره کنید. </p>

  <img src="images/2.18 photo.png" width="450" alt=""/>
<p>سپس index.html را با دوبار کلیک در مرورگر خود باز کنید.</p>
    <img src="/images/2.19 photo.png" width="450" alt=""/>

<p>یادگیری HTML نسبتاً آسان است، اما زمانی که با CSS برای چیدمان (Style) و طراحی وب سایت شما ترکیب شود، بسیار قدرتمند است. هنگامی که با اصول HTML آشنا شدید، می توانید شروع به کاوش در CSS برای اضافه کردن سبک و قالب بندی به وب سایت خود کنید.</p>
</section>
</section>

<section id="HTML">
<h2>HTML5 چیست؟ درک روش صحیح چیدمان صفحه با HTML5</h2>
<p>HTML5 آخرین نسخه از زبان نشانه‌گذاری ابرمتنی است، زبان استاندارد برای ساختاربندی محتوا در وب. این نسخه به طور رسمی در اکتبر 2014 منتشر شد و تعدادی بهبود و ویژگی‌های جدید را در مقایسه با پیشینیان خود به ارمغان آورد. HTML5 با هدف ساخت وبی مدرن‌تر، دسترس‌پذیرتر و همکاری‌پذیرتر توسعه یافت. این نسخه عناصر و APIهای جدیدی را معرفی می‌کند که به توسعه‌دهندگان امکان می‌دهد صفحات وب و برنامه‌های وب قدرتمندتر و تعاملی‌تری را ایجاد کنند. <br/>
  HTML5 ستون فقرات وب است که مسئولیت ساختار و ارائه محتوا را بر عهده دارد. مجموعه‌ای از عناصر و ویژگی‌های جدید HTML5 را می توان با تمرکز بر موارد زیر معرفی کرد:
  <ul>
    <li>ساختار معنایی: تگ‌های جدیدی که هدف بخش‌های مختلف صفحه وب را واضح‌تر تعریف می‌کنند (در ادامه بیشتر به این موضوع می‌پردازیم).</li>
    <li>ذخیره‌سازی آفلاین و برنامه‌های کاربردی: وب‌سایت‌ها را قادر می‌سازد تا داده‌ها را به صورت محلی ذخیره کنند و حتی بدون اتصال به اینترنت، تا حدی کار کنند.</li>
    <li>چندرسانه‌ای: پشتیبانی بهبود یافته برای جاسازی مستقیم صدا و تصویر در صفحات وب.</li>
    <li>دسترسی‌پذیری: عناصر و ویژگی‌های پیشرفته‌ای را برای آسان‌تر کردن استفاده از وب‌سایت‌ها برای افراد دارای معلولیت ارائه می‌دهد.</li>
  </ul>
</p>

<h3>تکنیک‌های چیدمان در HTML5</h3>
<p>بزرگترین بهبود چیدمان HTML5 معرفی عناصر معنایی بود. این موارد به توسعه‌دهندگان و مرورگرها کمک می‌کنند تا محتوا را به روشی معنادارتر درک کنند:</p>

<img src="/images/2.20 photo.png" width="450" alt=""/>

<ul>
    <li><strong>&lt;header&gt;</strong>: نشان‌دهنده محتوای مقدماتی برای یک صفحه یا بخش، که معمولاً شامل عناوین، ناوبری یا لوگوها می‌شود.</li>
    <li><strong>&lt;nav&gt;</strong>: مجموعه‌ای از لینک‌های ناوبری را در بر می‌گیرد.</li>
    <li><strong>&lt;main&gt;</strong>: محتوای اصلی یک سند. در هر صفحه فقط باید یک &lt;main&gt; وجود داشته باشد.</li>
    <li><strong>&lt;section&gt;</strong>: یک بخش کلی از محتوا، مانند مقاله، بلوک خبری و غیره.</li>
    <li><strong>&lt;article&gt;</strong>: محتوای مستقل و خودکفا مانند پست وبلاگ، مقاله خبری یا ورودی انجمن.</li>
    <li><strong>&lt;aside&gt;</strong>: محتوایی که به طور مماس با محتوای اطراف مرتبط است (به عنوان مثال، نوارهای کناری، کادرهای فراخوان یا لینک‌های مرتبط).</li>
    <li><strong>&lt;footer&gt;</strong>: ناحیه پایین یک صفحه یا بخش، که معمولاً حاوی اطلاعات حق نسخه‌برداری، لینک‌های تماس و غیره است.</li>
</ul>

<h3>مثالی از یک چیدمان HTML5</h3>
<p>هنگام طراحی یک صفحه وب با HTML5، مهم است که از عناصر معنایی به طور معقولی استفاده شود تا ساختار محتوا را به وضوح تعریف کنید. یک طرح ابتدایی می‌تواند به شکل زیر باشد:</p>
<img src="/images/2.21 photo.png" width="450" alt=""/>
<p>در این مثال، ما از عناصر HTML5 استفاده کردیم تا بخش‌های مختلف صفحه را تعریف کنیم، که خوانایی و دسترس‌پذیری را بهبود می‌بخشد. استفاده از <strong>&lt;main&gt;</strong>,<strong>&lt;section&gt;</strong>,<strong>&lt;article&gt;</strong>, <strong>&lt;aside&gt;</strong>, و دیگر تگ‌های معنایی به سازماندهی منطقی محتوا کمک کرده و بهینه‌سازی موتور جستجو (SEO) را بهبود می‌بخشد.</p>
<img src="/images/2.22 photo.png" width="450" alt=""/>

  

  <p>HTML5 امکانات ایجاد فرم‌ها و عناصر تعاملی در صفحات وب را گسترش می‌دهد. این نسخه انواع ورودی جدیدی مانند email، date، time، range و color را معرفی می‌کند که ورودی‌های کاربرپسندانه‌تری برای انواع داده‌های خاص فراهم می‌آورد. علاوه بر این، APIهای جدید برای کانواس، کشیدن و رها کردن، و چندرسانه‌ای (صوتی و تصویری) امکانات گسترده‌تری برای ایجاد محتوای تعاملی و چندرسانه‌ای بدون نیاز به پلاگین‌های خارجی را فراهم می‌کنند.</p>


<h3>مزایای چیدمان معنایی HTML5</h3>
<ul>
    <li><strong>وضوح:</strong> خوانایی کد را برای توسعه‌دهندگان و موتورهای جستجو بهبود می‌بخشد.</li>
    <li><strong>دسترسی‌پذیری:</strong> به خواننده‌های صفحه و فناوری‌های کمکی برای پیمایش موثرتر صفحه کمک می‌کند.</li>
    <li><strong>نگهداری:</strong> به‌روزرسانی و استایل‌دهی وب‌سایت شما را آسان‌تر می‌کند، زیرا ساختار منطقی‌تری دارد.</li>
</ul>

<p>به خاطر داشته باشید که HTML5 عمدتا ساختار صفحه شما را مدیریت می کند. در اینجا CSS وارد عمل می شود تا به آن سبک دهد:</p>

<ul>
  <li>Grid یا شبکه CSS: سیستمی قدرتمند برای ایجاد چیدمان‌های چند ستونی و پیچیده.</li>
  <li>Flexbox: مناسب برای تراز کردن عناصر درون کانتینرها و پاسخگو کردن چیدمان‌ها به اندازه‌های مختلف صفحه نمایش.</li>
</ul>

<p>شما می توانید تمام دستورات HTML را با جزئیات در وب سایت زیر یاد بگیرید.
</p>

<p><a href="https://www.w3.org/html/">https://www.w3schools.com/html/default.asp
</a></p>
<p>
  <a href="https://www.programiz.com/html/online-compiler/">https://www.programiz.com/html/online-compiler </a></p>
<p>پس از درک اصول اولیه HTML5، قدم بعدی گسترش و تعمیق دانش خود با کسب تجربه عملی و یادگیری مفاهیم جدید است. در اینجا چند پیشنهاد برای حرکت رو به جلو وجود دارد:</p>
<ol>
<li>CSS را یاد بگیرید: <br/>
هنگامی که با HTML احساس راحتی کردید، باید شروع به یادگیری (CSS (Cascading Style Sheets کنید. از CSS برای طراحی ظاهر و چیدمان صفحات وب استفاده می شود. CSS به شما امکان می دهد رنگ ها، فونت ها، فاصله گذاری، موقعیت و موارد دیگر را کنترل کنید. تسلط بر CSS برای ایجاد وب سایت هایی با ظاهر حرفه ای بسیار مهم است.
</li>
<li>طراحی وب سایت واکنش گرا / Responsives Webdesign: <br/>
یاد بگیرید که چگونه طراحی وب ریسپانسیو را پیاده سازی کنید تا وب سایت شما در دستگاه ها و اندازه های مختلف صفحه نمایش عالی به نظر برسد. این شامل درک پرسش‌های رسانه در CSS، طرح‌بندی‌های انعطاف‌پذیر و سایر تکنیک‌ها برای تطبیق وب‌سایت شما با دستگاه‌های تلفن همراه و تبلت‌ها می‌شود.
</li>
<li>جاوا اسکریپت: <br/>
جاوا اسکریپت یک زبان برنامه نویسی است که برای تعاملی کردن وب سایت ها استفاده می شود. با یادگیری جاوا اسکریپت می‌توانید ویژگی‌های پویا مانند گالری‌های تصاویر، اعتبارسنجی فرم‌ها، تغییرات محتوای پویا و غیره را به صفحات وب خود اضافه کنید. جاوا اسکریپت همچنین پایه ای برای فناوری ها و چارچوب های پیشرفته وب مانند React، Angular و Vue است.
</li>
<li>ابزار توسعه وب / Webentwicklungs-Tools: <br/>
با ابزارها و فناوری‌های مورد استفاده در توسعه وب مدرن آشنا شوید، مانند ابزارهای نسخه‌سازی (مانند Git)، ابزارهای توسعه مرورگر (ابزارهای توسعه‌دهنده)، و چارچوب‌ها/کتابخانه‌ها برای هر دو CSS (مانند Bootstrap، Tailwind) و جاوا اسکریپت (مانند React، Angular، Vue).
</li>
<li> ساخت پروژه ها : <br/>
بهترین راه یادگیری از طریق تمرین است. با ایجاد پروژه های خود یا شرکت در پروژه های منبع باز شروع کنید. این می تواند شامل وب سایت های ساده، نمونه کارها شخصی، برنامه های وب کوچک یا بازی ها باشد. این به شما کمک می‌کند تا آنچه را که آموخته‌اید به کار ببندید، مهارت‌های حل مسئله را توسعه دهید و مجموعه‌ای بسازید که می‌تواند به کارفرمایان یا مشتریان بالقوه ارائه شود.
</li>
<li>به طور مداوم یاد بگیرید: <br/>
توسعه وب یک زمینه سریع است و یادگیری مداوم و به روز نگه داشتن خود بسیار مهم است. وبلاگ‌ها، پادکست‌ها و دوره‌های آنلاین را دنبال کنید، در وبینارها شرکت کنید و در جوامع شرکت کنید تا روندها، فناوری‌ها و بهترین شیوه‌های جدید را کشف کنید.
</li>
</ol>
</section>
</section>

    <!--fasle3 css-->
    <section id="chapter3">
      <section id="chapter3">
        <h2>فصل سوم</h2>
        <h3>CSS چیست؟</h3>
        <p>
          مانند HTML، CSS یک زبان برنامه نویسی نیست.این زبان نشانه گذاری نیز
          نیست. CSS یک زبان شیوه نامه است.<br />
          CSS چیزی است که شما برای استایل کردن انتخابی عناصر HTML استفاده می
          کنید. به عنوان مثال، این CSS متن پاراگراف را انتخاب می کند و رنگ را
          قرمز می کند:
        </p>
        <img src="images/3.1 photo.png" width="450" />
        <p>
          CSS مخفف Cascading Style Sheets است و زبانی است که برای طراحی سبک و
          چیدمان صفحات وب ایجاد شده با HTML استفاده می شود. <br />در حالی که
          HTML ساختار یک وب سایت را تعریف می کند، CSS از استایل و طرح بندی
          مراقبت می کند - صفحه چگونه باید به نظر برسد. CSS به شما امکان می
          دهد<br />
          رنگ ها، فونت ها، فاصله ها، اندازه ها و موارد دیگر را برای عناصر مختلف
          در یک صفحه وب تعریف کنید.
        </p>
      </section>
  
      <section>
        <h3>درک عمیق‌تر ساختار و اصطلاحات قواعد CSS:</h3>
        <p>
          بیایید کد CSS را برای متن پاراگراف قرمز تجزیه کنیم تا بفهمیم چگونه
          کار می کند؟<br />
          برای تسلط بر CSS و ساختار آن، بررسی دقیق اجزاء و اصطلاحات یک قاعده
          (به انگلیسی "ruleset") ضروری است.<br />
          هر قاعده از چند بخش کلیدی تشکیل شده است که با هم برای اعمال ‍سبک و
          قالب‌بندی به عناصر HTML همکاری می‌کنند.
        </p>
        <img src="images/3.2 photo.png" width="450"  />


            <ol>
        
          <h5>اجزای یک قاعده:
</h5>   
      
          <li>انتخابگر / Selector:
            <ul> 
            <li>
          مشخص می‌کند که کدام عناصر 
            HTML تحت تاثیر
          قاعده قرار می‌گیرند.</li>
          <li>در ابتدای قاعده قرار دارد و می‌تواند به انواع مختلفی از عناصر اشاره کند:

        <ul>
          <li>انتخابگر نوع / Type selector: مانند p برای پاراگراف‌ها <p>
</li>
          <li>انتخابگر کلاس / Class selector: مانند .نام‌کلاس که تمام عناصر با کلاس نام‌کلاس را انتخاب می‌کند
</li>
          <li>انتخابگر شناسه / ID selector: مانند #نام_شناسه که عنصری با شناسه نام_شناسه را انتخاب می‌کند
</li>
          <li>شبه‌کلاس‌ها و شبه‌عناصر / Pseudo-class selector: مانند :hover برای اثر هاور موس
</li>
          <li>Descendant Selector: عنصری را انتخاب می کند که از نسل دیگری است (به عنوان مثال، div p).
</li>
          <li>Child Selector: عناصر مستقیم فرزندان را انتخاب می کند (به عنوان مثال، ul > li).
</li>
          <li>Adjacent Sibling Selector: عنصری را انتخاب می کند که مستقیماً بعد از یک عنصر خاص دیگر قرار دارد (به عنوان مثال، h1 + p).
</li>
          <li>General Sibling Selector: عناصری را انتخاب می کند که خواهر و برادر یک عنصر مشخص شده باشند (به عنوان مثال، h1 ~ p).


</li>
        </ul>
      </li>
      </ul>
  
    
    <li>شبه طبقات / Pseudo-Classes
      <p>شبه کلاس ها برای تعریف حالت خاصی از یک عنصر استفاده می شوند. در اینجا برخی از رایج ترین کلاس های شبه استفاده می شود:
</p>
        <ul>
          <li>:hover: هنگامی که کاربر ماوس را روی یک عنصر با ماوس قرار می دهد، استایل ها را اعمال می کند.
</li>
          <li>:focus: هنگامی که یک عنصر فوکوس داشته باشد، سبک‌ها را اعمال می‌کند (به عنوان مثال، فیلدهای ورودی هنگام کلیک کردن).
</li>
          <li>:active: هنگامی که یک عنصر فعال می شود (به عنوان مثال، کلیک می شود) سبک ها را اعمال می کند.</li>
          <li>:first-child: اولین فرزند والدین خود را هدف قرار می دهد.</li>
          <li>:last-child: آخرین فرزند والدین خود را هدف قرار می دهد.</li>
          <li>:nth-child(n): نهمین فرزند والدین خود را هدف قرار می دهد.</li>
        </ul>
        </li>
          <li>شبه عناصر / Pseudo-Elements
        عناصر شبه به شما این امکان را می دهند که به بخش های خاصی از یک عنصر استایل دهید. برخی از شبه عناصر رایج عبارتند از:

        <ul>
          <li>::before: محتوا را قبل از محتوای عنصر انتخاب شده درج می کند.
</li>
          <li>::after: محتوا را بعد از محتوای عنصر انتخاب شده درج می کند.
</li>
          <li>::first-line: خط اول متن یک عنصر را هدف قرار می دهد.
</li>
          <li>::first-letter: حرف اول متن را در یک عنصر هدف قرار می دهد.
</li>
          </ul>
          <li>ترکیب انتخابگرها / Combining Selectors
            <p>می توانید انتخابگرها را برای هدف قرار دادن عناصر به طور خاص تر ترکیب کنید، که این امکان را برای الگوهای یک ظاهر پیچیده بدون افزودن کلاس ها یا شناسه های اضافی به HTML فراهم می کند:
</p>
<ul>
                <li>ترکیب یک کلاس و کلاس شبه: .button:hover — هنگامی که ماوس را روی عناصر با کلاس "دکمه" قرار می دهید، سبک ها را اعمال می کند.
</li>           
            <li>ترکیب شناسه و شبه عنصر: #header::after — محتوا یا سبک‌هایی را بعد از محتوای عنصر با شناسه «هدر» اضافه می‌کند.
</li>   
</ul>           
                      </li>

      
      
<p>این مفاهیم CSS برای طراحی موثر وب یکپارچه هستند و به شما امکان می دهند ارائه صفحات وب را به صورت پویا و تعاملی دستکاری کنید و تجربه کاربری غنی تری را ارائه دهید. درک این انتخابگرها و شبه عناصر برای اعمال دقیق و کارآمد استایل ها ضروری است.

انتخابگرهای زیادی برای کشف وجود دارد. برای کسب اطلاعات بیشتر، راهنمای انتخابگرهای MDN را ببینید:
https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors

</p>
          <li>اعلامیه / Declaration:
            <ul>
              <li>یک قانون سبک است که نحوه نمایش عناصر انتخاب‌شده را مشخص می‌کند.
</li>
              <li>از دو بخش تشکیل شده است:
                <ul>
                  <li>ویژگی / Property: مشخصه عنصر که ‍سبک‌بندی می‌شود (مانند رنگ، ‍فونت، چیدمان)
</li>
                  <li>مقدار / Value: ‍ظاهر یا رفتار ‍ویژگی را تعیین می‌کند (مانند قرمز، 16px، flexbox)
</li>
                </ul>
                <li>مثال: color: red; font-size: 16px;
</li>
</li>
            </ul>
          </li>

        
          <li>ویژگی‌ها / Properties
            <ul>
              <li>مشخصه‌های قابل ‍سبک‌بندی یک عنصر را تعریف می‌کنند.
</li>
              <li>CSS ‍ویژگی‌های متنوعی برای ‍تأثیرگذاری بر بخش‌های مختلف ‍یک عنصر ارائه می‌دهد:
                <ul>
                  <li>تایپوگرافی: مانند font-family, font-size, text-align
</li>
                  <li>رنگ: مانند color, background-color
</li>
                  <li>چیدمان: مانند display, float, margin
</li>
                  <li>موقعیت: مانند position, top, left
</li>
                  <li>انیمیشن: مانند transition, animation
</li>
                </ul>
</li>
            </ul>
          </li>

      
          <li>مقدار ‍ویژگی / Property value
            <ul>
              <li>‍ظاهر یا رفتار ‍مشخص ‍ویژگی را تعیین می‌کند.
</li>
              <li>انواع ‍مقادیر:

<ul>
<li>کلمات کلیدی: مانند bold, inherit
</li>
<li>اعداد: مانند 16px, 100%
</li>
<li>رنگ‌ها: مانند red, #00FF00
</li>
<li>طول‌ها: مانند 1em, 20px
</li>
<li>‍مقادیر ‍پیچیده‌تر: مانند url(image.png), linear-gradient()
</li>
</ul>
</ol>
  </li>
</ul>
            
          </li>
        
      <p>قواعد ‍مهم نگارشی / Syntax rules:
        <ul>
          <li>پرانتز: قواعد ‍در ‍پرانتزهای مجعد ({}) قرار می‌گیرند.
</li>
          <li>دو نقطه: ‍ویژگی و ‍مقدار را در ‍اعلامیه‌ها از هم جدا می‌کند (:).
</li>
          <li>نقطه ویرگول: ‍هر ‍اعلامیه را ‍به ‍پایان می‌‍رساند (;).
</li>
          <li>ترکیب: ‍امکان ‍استفاده از ‍چند ‍اعلامیه در ‍یک ‍قاعده ‍وجود دارد.
</li>
        </ul>
        </p>
        <p>مثال ‍یک ‍قاعده ‍کامل:
</p>

      <img src="images/3.3 photo.png" width="450"><br>
      <p>‍جمع‌بندی:
        <ul>
          <li>قواعد ‍CSS ‍امکان ‍سبک‌بندی ‍عناصر ‍HTML را ‍فراهم ‍می‌کنند.
</li>
          <li>‍انتخابگرها ‍عناصر ‍را ‍انتخاب ‍و ‍اعلامیه‌ها ‍سبک ‍آنها ‍را ‍مشخص ‍می‌کنند.
</li>
          <li>‍ویژگی‌ها و ‍مقادیر ‍جزئیات ‍‍سبک‌
</li>
        </ul>
    
      </p>
    </ul>
      </section>
      <section>
          <h3>1.ویژگی های طرح بندی / Layout Properties</h3>
          <p>این ویژگی ها به تعریف طرح بندی صفحات وب کمک می کنند.<br/>

              نمایش (display): رفتار نمایشگر را مشخص می کند (به عنوان مثال، بلوک، درون خطی، انعطاف پذیر، شبکه).<br/>
              موقعیت (position): نوع روش موقعیت یابی مورد استفاده را مشخص می کند (به عنوان مثال، مطلق، نسبی، ثابت، چسبنده).<br/>
              Float (float): یک عنصر را در سمت چپ یا راست ظرف آن قرار می دهد و به متن و عناصر درون خطی اجازه می دهد تا دور آن بپیچند.<br/>
              Clear (clear): مشخص می کند که عناصر شناور در کدام طرف یک عنصر مجاز به شناور نیستند.
              </p>
      </section>
      <section id="Flexbox">
          <h3>Flexbox 2و Grid</h3>
          <p>
              برای ساختارهای چیدمان پیشرفته، به ویژه در طراحی های واکنش گرا استفاده می شود.<br/>
ویژگی‌های انعطاف‌پذیری / Flex Properties: شامل جهت انعطاف‌پذیری، انعطاف‌پذیری، توجیه محتوا، تراز کردن آیتم‌ها، تراز کردن محتوا، رشد انعطاف‌پذیر، منقبض شدن انعطاف‌پذیر و پایه انعطاف‌پذیری است.<br/>
              ویژگی های گرید: شامل گرید-الگو-ستون ها، گرید-الگو-ردیف ها، گرید-ستون، گرید-ردیف، ناحیه-شبکه، شبکه-شکاف .</p>

          
      </section>
      <section id="Box">
          <h3> 3.ویژگی های مدل جعبه  / Box Model Properties</h3>
          <p>اندازه و فاصله عناصر را کنترل کنید.<br>

              Width and Height (width, height): عرض و ارتفاع عناصر را مشخص کنید.<br/>
              Padding (padding): فضایی را در اطراف محتوای یک عنصر، در داخل هر مرز تعریف شده ایجاد می کند.<br/>
              حاشیه (حاشیه): فضای اطراف عناصر را کنترل می کند.<br/>
              Border (border): حاشیه اطراف عناصر را تنظیم می کند.
              </p>
      </section>
      <section id="Typography">
          <h3>4. خواص تایپوگرافی / Typography Properties</h3>
      <p>این ویژگی ها سبک و طرح متن و فونت ها را مشخص می کنند.<br>

          ویژگی های فونت: شامل اندازه فونت، خانواده فونت، وزن فونت، سبک فونت.<br/>
          ویژگی های متن: شامل تراز کردن متن، تزئین متن، تبدیل متن، ارتفاع خط، فاصله حروف، سایه متن.
          </p>
  </section>
      <section id="properties">
          <h3>5.ویژگی های جلوه های بصری / Visual Effects Properties</h3>
          <p>علاقه بصری و نشانه‌ها را به طرح‌بندی‌ها اضافه کنید.<br>

              Color (color): رنگ متن را مشخص می کند.<br/>
              پس‌زمینه (پس‌زمینه، رنگ پس‌زمینه، تصویر پس‌زمینه، موقعیت پس‌زمینه، پس‌زمینه تکرار، اندازه پس‌زمینه): پس‌زمینه عناصر را تعریف می‌کند.<br/>
              Box Shadow (box-shadow): افکت های سایه را در اطراف کادر یک عنصر اضافه می کند.<br/>
              Opacity (opacity): سطح کدورت یک عنصر را تنظیم می کند.<br/>
              فیلتر (فیلتر): جلوه های گرافیکی مانند تاری یا تغییر رنگ را روی یک عنصر اعمال می کند.<br/>
              </p>
      </section>
      <section id="Animation">
          <h3>6.انیمیشن و انتقال / Animation and Transitions</h3>
          <p>برای افزودن افکت های تعاملی و پویا.<br/>

              Transition (transition): راهی برای کنترل سرعت انیمیشن در هنگام تغییر ویژگی های CSS ارائه می دهد.<br/>
              انیمیشن (@keyframes، انیمیشن-نام، انیمیشن-مدت، انیمیشن-زمان-عملکرد، انیمیشن-تاخیر، انیمیشن-تکرار-تعداد، انیمیشن-جهت): امکان کنترل بیشتر روی انیمیشن های CSS را فراهم می کند.
              </p>
      </section>
      <section id="Miscellaneous">
          <h3>7.خواص متفرقه / Miscellaneous Properties</h3>
          <p>سایر خواص مهم که اغلب برای اهداف خاص استفاده می شوند.<br>
            <ul>
              <li>  مکان نما (cursor): نوع نشانگر ماوس را مشخص می کند.</li>
              <li>Z-index (z-index): ترتیب پشته عناصر همپوشانی را کنترل می کند.
</li>
              <li>Visibility (Visibility): مشخص می کند که آیا یک عنصر قابل مشاهده است یا خیر.
</li>
            </ul>
              این دسته‌بندی‌ها ضروری‌ترین جنبه‌های CSS را پوشش می‌دهند که برای ساخت و استایل تقریباً تمام رابط‌های وب استفاده می‌شوند. هر دسته به بخش خاصی از فرآیند استایل و چیدمان می پردازد و به توسعه دهندگان این امکان را می دهد که هم طراحی های وب جذاب و هم کاربردی ایجاد کنند.
              
              </p>
      </section>
      <section id="mafahimasasi">
          <h3>برخی از مفاهیم اساسی CSS که فراتر از ویژگی ها هستند:
          </h3>
          <ul>
              <li>
                بیایید این مفاهیم را که شامل انتخابگرها، شبه کلاس‌ها و شبه عناصر و غیره هستند، بررسی کنیم. <br>اینها برای هدف قرار دادن عناصر HTML برای اعمال موثر سبک ها بسیار مهم هستند.
          </li>
          </ul>
          <section id="emtehan">
              <h4>بیایید امتحان کنیم! </h4><br>
              <p>
              من از این ویرایشگر HTML/CSS برای این پروژه استفاده می کنم:
              </p><br>
              <a href="https://www.programiz.com/html/online-compiler/">                https://www.programiz.com/html/online-compiler/
</a><br/>
<img src="/images/3.edit.jpg" alt="">
              
              ما روی فایل index.html که در بالا به عنوان مثال ساخته ایم کار می کنیم.
              با استفاده از یک ویرایشگر متن، سه خط CSS (بالا) را در یک فایل جدید قرار دهید. فایل را به عنوان style.css در فهرستی با نام styles ذخیره کنید.<br><br>
              <img src="images/3.4 photo.png" width="450"><br>
              اکنون ما سه فایل برای این پروژه داریم: index.html: این همان چیزی است که در فصل 2 HTML ساختیم. (اگر پروژه ما را دنبال نکرده اید، در اینجا مکث کنید تا فصل ۲: Hyper Text Markup Language را بخوانید.)
              iman.png: عکسی است که در مثال خود استفاده می کنیم.<br><br/>
              style.css: ما فقط این را برای استایل های Css خود ایجاد کردیم.<br>
              برای اینکه کد کار کند، همچنان باید این CSS (بالا) را در سند HTML شما اعمال کنیم. در غیر این صورت، استایل ظاهر HTML را تغییر نخواهد داد. 

              فایل index.html خود را باز کنید. خط زیر را در سر (بین تگ‌های <code>&lt;head&gt;</code><code>&lt;/head&gt;</code> ) قرار دهید:<br>
              <img src="images/3.5 photo.png" width="450"><br>
              href="در اینجا مسیر فایل style.css می آید" را تغییر دهید!<br><br>
              <li>نتیجه باید اینگونه باشد:</li>
              <img src="images/3.6 photo.png" width="450"  alt=""><br><br>
              index.html را ذخیره کرده و در مرورگر خود بارگذاری کنید. شما باید چیزی شبیه به این را ببینید:<br>
              <img src="/images/3.edit2.jpg" width="450"  alt=""><br><br>
              اگر متن پاراگراف شما قرمز است، تبریک می‌گوییم! CSS شما کار می کند. اگر نه، لطفا مسیر style.css بالا را بررسی کنید.

            
      </section>

      <section id="font">

          <h4>فونت و متن / Fonts and text</h4>
              <p>اکنون که برخی از اصول CSS را بررسی کردیم، بیایید ظاهر مثال را با افزودن قوانین و اطلاعات بیشتر به فایل style.css بهبود دهیم.<br>
                  ابتدا خروجی فونت های گوگل را که قبلاً ذخیره کرده اید از وب سایت شما چگونه خواهد بود پیدا کنید. عنصر <code>&lt;link&gt;</code> را در جایی داخل سر index.html خود اضافه کنید (هر جایی بین تگ‌های <head> و </head>). چیزی شبیه این به نظر می رسد:
              </p><br>
              <img src="images/3.7 photo.png" width="450" ><br>
              <p>این کد صفحه شما را به یک شیوه نامه پیوند می دهد که خانواده فونت Open Sans را با صفحه وب شما بارگیری می کند.
                  در مرحله بعد، قانون موجود در فایل style.css خود را حذف کنید. تست خوبی بود، اما اجازه دهید با متن قرمز زیاد ادامه ندهیم.
                  خطوط زیر را اضافه کنید (در زیر نشان داده شده است)، و به جای انتساب خانواده فونت با انتخاب خانواده فونت خود از وب سایت شما چه خواهد شد؟ ویژگی font-family به فونت(هایی) که می خواهید برای متن استفاده کنید اشاره دارد. این قانون یک فونت پایه جهانی و اندازه فونت را برای کل صفحه تعریف می کند. از آنجایی که <html> عنصر والد کل صفحه است، همه عناصر داخل آن اندازه فونت و خانواده فونت یکسانی را به ارث می برند.
                  </p><br>
                  <img src="images/3.8 photo.png" width="450" ><br>
                  <p style="color: red;">توجه: هر چیزی در CSS بین /* و */ یک نظر CSS است. مرورگر هنگام ارائه کد، نظرات را نادیده می گیرد. نظرات CSS راهی برای نوشتن یادداشت های مفید در مورد کد یا منطق خود است.</p><br>
                  <p>حالا بیایید اندازه فونت را برای عناصری که متنی در بدنه HTML دارند (<code>&lt;h1&gt;</code>، <code>&lt;li&gt;</code> ، <code>&lt;p&gt;</code>) تنظیم کنیم. ما همچنین عنوان را در مرکز قرار می دهیم. در نهایت، اجازه دهید مجموعه قوانین دوم (در زیر) را با تنظیمات ارتفاع خط و فاصله حروف گسترش دهیم تا محتوای بدنه را خوانا تر کنیم.
                  </p><br>
                  <img src="images/3.9 photo.png" width="450" ><br>
                  <p>مقادیر px را همانطور که دوست دارید تنظیم کنید. کار در حال انجام شما باید شبیه به این باشد:
                  </p><br>
                  <img src="/images/3.edit photo.jpg" alt="dfdf">
      </section>

      <section id="cssbox">
          <ul>
              <h3>CSS: همه چیز درباره جعبه ها Boxes</h3><br>
              <p>چیزی که در مورد نوشتن CSS متوجه خواهید شد: بسیاری از آن در مورد جعبه ها هستند. این شامل تنظیم اندازه، رنگ و موقعیت است. بیشتر عناصر HTML در صفحه شما را می توان به عنوان جعبه هایی در نظر گرفت که در بالای کادرهای دیگر قرار دارند.
              </p><br>
              <img src="images/3.10 photo.png" width="450" ><br>
              <p>چیدمان CSS بیشتر بر اساس مدل جعبه است. هر کادری که فضای صفحه شما را اشغال می کند دارای ویژگی هایی مانند:
              </p>
              <li>padding، فضای اطراف محتوا. در مثال زیر، فضای اطراف متن پاراگراف است.</li>
                  <li>border، خط ثابتی که درست خارج از بالشتک قرار دارد.</li>
                  <li>margin، فضای اطراف بیرون مرز.</li><br>
                  <img src="images/3.11 photo.png" width="450" ><br>
                  <p>در این بخش نیز از:</p><br>
                  <li>
                      width : عرض (یک عنصر).
                  </li>
                  <li> background color پس‌زمینه رنگ، رنگ پشت محتوای یک عنصر و بالشتک.
              </li>
              <li>color  رنگ، رنگ محتوای یک عنصر (معمولاً متن).
              </li>
              <li> text-shadow بر روی متن داخل یک عنصر سایه می گذارد.</li>
              <li> display حالت نمایش یک عنصر را تنظیم می کند. (برای یادگیری بیشتر خواندن را ادامه دهید)
              </li><br>
              <p>برای ادامه، بیایید CSS بیشتری اضافه کنیم. به افزودن این قوانین جدید در پایین style.css ادامه دهید. با تغییر مقادیر آزمایش کنید تا ببینید چه اتفاقی می افتد.
              </p><br>
          </ul>
      </section>
      <section id="tagheire-rang">
        
              <h3>
                  تغییر رنگ صفحه
              </h3>
              <p>این قانون یک رنگ پس زمینه برای کل صفحه تعیین می کند. کد رنگ را به رنگی که انتخاب میکنید تغییر دهید:
              </p><br>
              <img src="images/3.12 photo.png" width="450" ><br>

          
      </section>
      <section id="style-body">
          <ul>
              <h3>حالت دادن به بدن / Styling the body</h3>
              <p>ین کد را به فایل style.css اضافه کنید:</p><br>
              <img src="images/3.13 photo.png" width="450" ><br>
              <p>توضیحات برای عنصر <code>&lt;body&gt;</code>
                  برخی از اعلان‌هایی که معمولاً برای عنصر <code>&lt;body&gt;</code> استفاده می‌شوند به شرح زیر هستند. اجازه بدید آن‌ها را خط به خط بررسی کنیم:<br>
                      
                  </p>
                  <p>width: 600px 
                      <li>این کد عرض عنصر <code>&lt;body&gt;</code> را همیشه 600 پیکسل ثابت نگه می‌دارد.</li>
                      </p>
                      margin: 0 auto
                          <li>زمانی که برای ویژگی‌ای مانند margin یا padding دو مقدار اختصاص می‌دهید، مقدار اول بر بالا و پایین عنصر تأثیر می‌گذارد (که در این مورد مقدار آن صفر در نظر گرفته شده است). مقدار دوم بر چپ و راست عنصر اثر می‌گذارد. auto در اینجا یک مقدار ویژه است که فضای افقی باقی‌مانده را به‌طور مساوی بین چپ و راست تقسیم می‌کند. به یاد داشته باشید که می‌توانید از یک، دو، سه یا چهار مقدار با توجه به مستندات "Margin Syntax" استفاده کنید.</li>
                          </p>
                          <p>background-color: #FFFFFF
                              <li>رنگ پس‌زمینه عنصر را تنظیم می‌کند. در اینجا یک رنگ نارنجی مایل به قرمز برای پس‌زمینه <code>&lt;body&gt;</code> در نظر گرفته شده است. این در تقابل با رنگ آبی تیره استفاده‌شده برای پس‌زمینه عنصر <code>&lt;html&gt;</code> است. (می‌توانید با رنگ‌ها به دلخواه خودتان آزمایش کنید.)</li> 
                              </p>
                              <p>padding: 0 20px 20px 20px
                                  <li> چهار مقدار برای حاشیه‌گذاری داخلی تعیین می‌کند. هدف از این کد افزودن فاصله در اطراف محتوایِ درون عنصر است. در این مثال، در بالای <code>&lt;body&gt;</code> حاشیه‌ای وجود ندارد و 20 پیکسل فاصله در سمت راست، پایین و چپ آن در نظر گرفته شده است. مقادیر به‌ترتیب "بالا، راست، پایین و چپ" لحاظ می‌شوند. همانند margin ، می‌توانید از یک، دو، سه یا چهار مقدار طبق آنچه در "Padding Syntax" توضیح داده شده است استفاده کنید.</li>
                                  </p>
                                  <p>border: 5px solid black
                                    <li>  مقادیر عرض، سبک و رنگ حاشیه خارجی عنصر را مشخص می‌کند. در اینجا نوع حاشیه solid و به‌رنگ مشکی و با عرض 5 پیکسل در نظر گرفته شده است که در تمام اضلاع <code>&lt;body&gt;</code> لحاظ می‌شود.
                                      اگر همه چیز را به درستی انجام داده اید، اکنون وب سایت باید به این شکل باشد</li>
                                      </p>
          </ul>
          <img src="/images/edit4.jpg" alt="">
      </section>
      <section id="style-safhe">
        
              <h3>تعیین موقعیت و استایل کردن عنوان صفحه اصلی</h3><br>
              <img src="images/3.14 photo.png" width="450" ><br>
              <p>ممکن است متوجه شده باشید که شکاف وحشتناکی در بالای بدن وجود دارد. این اتفاق می افتد زیرا مرورگرها یک ظاهر طراحی پیش فرض را برای عنصر h1 (در میان سایر موارد) اعمال می کنند. ممکن است ایده بدی به نظر برسد، اما هدف این است که خوانایی اولیه برای صفحات بدون استایل ارائه شود. برای از بین بردن شکاف، استایل پیش فرض مرورگر را با حاشیه تنظیم بازنویسی می کنیم:
              </p>

              ;margin: 0
                  <p>در مرحله بعد، قسمت بالا و پایین عنوان را روی 20 پیکسل قرار می دهیم.<br>
                      به دنبال آن، متن عنوان را همرنگ رنگ پس‌زمینه HTML قرار می‌دهیم.<br>
                      در نهایت، text-shadow یک سایه به محتوای متن عنصر اعمال می کند. چهار مقدار آن عبارتند از:
                      </p>
                      <ul>
                  <li> اولین مقدار پیکسل، افست افقی سایه را از متن تعیین می کند: تا چه اندازه حرکت کند.</li>
                  <li> دومین مقدار پیکسل، افست عمودی سایه را از متن تعیین می کند: چقدر به سمت پایین حرکت کند.
                  </li>
                  <li>  سومین مقدار پیکسل شعاع تاری سایه را تعیین می کند. یک مقدار بزرگتر باعث ایجاد سایه مبهم تری می شود.
                  </li>
                  <li>    مقدار چهارم رنگ پایه سایه را تعیین می کند.
                  </li>
              </ul>
              <p>سعی کنید با مقادیر مختلف آزمایش کنید تا ببینید چگونه ظاهر را تغییر می دهد.</p>
        
      </section>
      <section id="position">
              <h3>مکان تصویر را تغییر دهید / Change the image position</h3><br>
              <img src="images/3.15 photo.png" width="450" />
              <p>در مرحله بعد، تصویر را در مرکز قرار می دهیم تا بهتر به نظر برسد. <br>می‌توانیم از حاشیه استفاده کنیم: 0 ترفند خودکار دوباره همانطور که برای بدنه انجام دادیم. اما تفاوت هایی وجود دارد که برای کارکرد CSS نیاز به تنظیمات اضافی دارد.<br>
                  <body> یک عنصر بلوک است، به این معنی که فضای صفحه را اشغال می کند. حاشیه اعمال شده بر روی یک عنصر بلوک توسط سایر عناصر موجود در صفحه رعایت می شود. در مقابل، تصاویر عناصر درون خطی هستند، برای اینکه ترفند حاشیه خودکار روی این تصویر کار کند، باید با استفاده از ;display: block رفتاری در سطح بلوک به آن بدهیم.</p>
          <p style="color: red;">توجه: دستورالعمل‌های بالا فرض می‌کنند که از تصویری کوچک‌تر از عرض تنظیم‌شده روی بدنه استفاده می‌کنید. (600 پیکسل) اگر تصویر شما بزرگتر باشد، از بدنه سرریز می شود و به بقیه صفحه می ریزد. برای رفع این مشکل، می توانید:<br> (عرض تصویر را با استفاده از ویرایشگر گرافیکی کاهش دهید، یا 2) از CSS برای اندازه گیری تصویر با تنظیم ویژگی width در عنصر <code>&lt;img&gt;</code> با مقدار کوچکتر استفاده کنید.<br/>
            </p>
<p style="color: red;">توجه: اگر کاملاً متوجه نشدید، زیاد نگران نباشید: block; یا تفاوت بین یک عنصر بلوکی و یک عنصر درون خطی. با ادامه مطالعه CSS، منطقی تر خواهد بود. می توانید اطلاعات بیشتری در مورد مقادیر مختلف نمایش در صفحه مرجع نمایشگر MDN بیابید.
              https://developer.mozilla.org/en-US/docs/Web/CSS/display
              
              </p>
              <p>اگر تمام دستورالعمل‌های ما را دنبال کردید، باید صفحه‌ای مشابه این صفحه داشته باشید:<br>
                  index.html
                  </p>
                  <img src="images/3.16 photo.png" width="450" /><br>
                  <p>style.css</p><br>
                  <img src="images/3.17 photo.png" width="450" /><br>

                  </ul>
                  <p>Frontend</p>
                  <img src="/images/edit5.jpg" alt="">
                  <p>من از منابع مختلف و هوش مصنوعی برای کتاب استفاده کردم (, Mozilla Official, Google, Open AI):</p>
                  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display">https://developer.mozilla.org/en-US/docs/Web/CSS/display</a>
      </section>

  </ol>
</section>

    <!--fasle4 api--><section>
    <section id="chapter4">
        <h2>فصل چهارم</h2>
        <section id="api">
        <h3>API (Application Programming)Interfaces</h3>
        <img src="images/4.1 photo.png" width="450" alt=""><br>
        <p>در حوزه توسعه وب، درک رابط های برنامه نویسی کاربردی <br>(API) برای استفاده از پتانسیل کامل جاوا اسکریپت بسیار مهم است.<br> API ها به عنوان پل عمل می کنند و برنامه های وب شما را قادر می سازند تا با سایر برنامه ها، سرویس های وب و سیستم عامل ها تعامل داشته باشند. آنها به عنوان ابزاری عمل می کنند که به توسعه دهندگان اجازه می دهد تا بر اساس عملکرد موجود بدون نیاز به اختراع مجدد چرخ برای هر پروژه جدید، کار کنند.
        </p> 
    </section>
    <section id="api1">
        <h3>API ها چیست؟</h3>
        <img src="images/4.2 photo.png" width="450" alt=""><br>
        <p>API ها یا Application Programming Interfaces مجموعه ای از پروتکل ها، ابزارها و تعاریف هستند که به نرم افزارهای مختلف اجازه می دهند تا با یکدیگر ارتباط برقرار کنند. آنها توسعه دهندگان را قادر می سازند تا به عملکردهای داخل یا خارج از محیط خود دسترسی داشته باشند بدون اینکه نیازی به درک یا بازسازی آنها از ابتدا داشته باشند. این شبیه به استفاده از اجزای آماده در ساخت و ساز است که به طور قابل توجهی روند ساخت سازه های پیچیده را ساده می کند.</p>
    </section>
    <section id="api2">
        <h3>انواع API ها
        </h3><br>
        <img src="images/4.3 photo.png" width="450" alt=""><br>
        <p>API ها را می توان بر اساس در دسترس بودن، سطح دسترسی و دامنه عملکردشان دسته بندی کرد. چهار نوع اصلی وب API عبارتند از:</p><br>
        <ul>
            <li>APIهای باز (Public API): اینها برای هر توسعه‌دهنده‌ای برای استفاده با حداقل محدودیت در دسترس هستند. ممکن است رایگان باشند یا نیاز به اشتراک داشته باشند. APIهای باز برای به اشتراک گذاری داده ها و خدمات با جامعه توسعه دهندگان گسترده تر هستند، اما معمولاً دسترسی محدودی به منابع برای اطمینان از امنیت و مدیریت بار ارائه می دهند.</li>
            <li>API های شریک (Partner APIs): همانطور که از نام آن پیداست، API های شریک در معرض شرکای تجاری استراتژیک قرار دارند. آنها به حقوق و مجوزهای خاصی برای دسترسی و ارائه یک محیط کنترل شده برای به اشتراک گذاری داده ها و عملکردهای حساس یا ارزشمندتر نیاز دارند.</li>
            <li>
                APIهای داخلی (Private API): این APIها که برای استفاده در یک سازمان طراحی شده اند، عملیات را با امکان برقراری ارتباط سیستم ها یا برنامه های مختلف در یک سازمان با یکدیگر ساده می کنند. آنها در معرض عموم قرار نمی گیرند و سطح بالایی از امنیت و کنترل را تضمین می کنند.
                </li>
                <li>
                    API های ترکیبی (Composite APIs): ترکیبی از API های مختلف هستند که برای انجام یک کار یا حل یک مشکل پیچیده با هم کار می کنند. APIهای ترکیبی به توسعه‌دهنده اجازه می‌دهند تا چندین تماس API را در یک تماس جمع کند، بار سرور را کاهش دهد، کد مشتری را ساده‌تر کند و عملکرد برنامه را بهبود بخش
                    </li>
        </ul>
    </section>
    <section id="api3">
        <h3>معماری API</h3><br>
        <img src="images/4.4 photo.png" width="450" alt=""><br>
        <p>چشم انداز دیجیتال مملو از مجموعه ای از رابط های برنامه نویسی کاربردی (API) است که هر کدام به عنوان مجرای حیاتی برای تعامل یکپارچه بین سیستم های نرم افزاری متفاوت عمل می کنند. APIها ستون فقرات توسعه نرم‌افزار مدرن هستند و قابلیت‌هایی را از بازیابی ساده داده تا اجرای فرآیندهای تجاری پیچیده را ممکن می‌سازند. همانطور که ما در دنیای گسترده API ها کاوش می کنیم، درک انواع و تفاوت های معماری آنها برای ایجاد برنامه های کاربردی قوی و کارآمد بسیار مهم است. بیایید معماری های متنوع API و ویژگی های منحصر به فرد آنها را بررسی کنیم و دانش خود را فراتر از اصول اولیه غنی کنیم.

            معماری یک API نحوه برقراری ارتباط، سطح امنیتی که ارائه می دهد، کارایی آن در مدیریت داده ها و سهولت یکپارچه سازی آن را تعیین می کند. از REST و SOAP پرکاربرد گرفته تا GraphQL و gRPC تخصصی، هر معماری جای خود را در جعبه ابزار توسعه دهنده دارد.
            </p>
            <img src="images/4.5 photo.png" width="450" alt="">
    </section>
    <section id="soap">
        <h3>(SOAP) Simple Object Access Protocol</h3><br>
        <img src="images/4.6 photo.png" width="450" alt=""><br>
        <p>SOAP یا Simple Object Access Protocol سنگ بنای دنیای معماری های API است که برای اطمینان از قابلیت همکاری و تبادل یکپارچه داده در سیستم های مختلف طراحی شده است. SOAP با رعایت مجموعه ای از قوانین جهانی، تعامل قابل اعتماد بین برنامه های کاربردی سرویس گیرنده و سرور را بدون توجه به پشته فناوری زیربنایی آنها تسهیل می کند. در اینجا، ما به نکات ضروری SOAP می پردازیم، ویژگی های آن، موارد استفاده، و تعادل مزایا و معایب آن را برجسته می کنیم.
            SOAP بر اساس یک اصل اساسی کار می کند که امکان برقراری ارتباط پایدار بین برنامه های توسعه یافته با زبان ها و پلتفرم های مختلف را فراهم می کند. این پروتکل از پیام‌های مبتنی بر XML که در پاکت‌ها پیچیده شده‌اند برای انتقال اطلاعات درخواست و پاسخ بین کلاینت و سرور استفاده می‌کند. ساختار یک پیام SOAP معمولاً شامل دو بخش اصلی است: هدر که حاوی ابرداده در مورد پیام است و بدنه که داده‌های درخواست یا پاسخ واقعی را در خود نگه می‌دارد.
            </p>
    </section>
    <section id="soap1">
        <h3>ویژگی های کلیدی SOAP
        </h3>
        <ul>
            <li>مبتنی بر XML: پیام های SOAP در XML ساخته می شوند، یک زبان نشانه گذاری همه کاره که تضمین می کند پیام ها در سیستم های مختلف قابل درک هستند.
            </li>
            <li>پهنای باند فشرده: به دلیل ساختار دقیق پیام، SOAP پهنای باند بیشتری را در مقایسه با سایر سبک‌های API مصرف می‌کند و داده‌های گسترده‌ای را در پیام‌های خود جای می‌دهد.
            </li>
            <li>ناسازگاری با REST :REST و SOAP سبک های معماری متفاوتی هستند که هر کدام رویکرد منحصر به فرد خود را در طراحی و تعامل API دارند. استانداردها و ساختارهای SOAP با اصول RESTful همخوانی ندارند.
            </li>
        </ul>
        <p>چه زمانی از SOAP استفاده کنیم؟
            SOAP در سناریوهایی که سطوح بالایی از امنیت، قابلیت اطمینان و ارتباطات رسمی را می طلبد می درخشد. مناسب بودن آن به برنامه های مختلف گسترش می یابد:
            
            </p><br>
            <ul>
                <li>عملیات همزمان: ایده آل برای برنامه هایی که نیاز به تبادل داده های قابل اعتماد و پردازش بلادرنگ دارند.</li>
                <li>ارتباطات رسمی: زمانی که قالب‌های پیام از پیش تعریف‌شده و سخت‌گیرانه برای مبادلات سرور و مشتری ضروری باشد.
                </li>
                <li>عملیات Stateful: SOAP از برنامه هایی پشتیبانی می کند که نیاز به حفظ متن یا حالت در چندین درخواست دارند.
                </li>
            </ul>
            <p>نمونه ای از SOAP API
                یک مثال پیام SOAP ساختار آن را نشان می‌دهد، از جمله یک اعلان فضای نام، سرصفحه‌های ابرداده و بدنه حاوی درخواست.
                </p><br>
                <img src="images/4.7 photo.png" width="450" alt="">
    </section>
    <section id="soap2">
        <h3>مزایا و معایب SOAP</h3><br>
        <p>مزایا:</p>
        <ul>
            <li>یکپارچه سازی WSDL: از زبان توصیف خدمات وب (WSDL) برای مستندسازی دقیق خدمات وب، افزایش مصرف و توسعه API استفاده می کند.
        </li>
        <li>توسعه پذیر: سازگار با افزونه های متعدد (مانند WS-Security، WS-Federation)، ایجاد برنامه های کاربردی بسیار کاربردی و ایمن را تسهیل می کند.
        </li>
        <li>Protocol Agnostic: روی چندین پروتکل حمل و نقل (HTTP، SMTP، TCP) کار می کند و آن را برای موارد استفاده مختلف همه کاره می کند.</li>
        </ul>
        <p>معایب:
        </p><br>
        <ul>
            <li>سربار عملکرد: استفاده از XML برای انتقال داده ها به دلیل ماهیت پرمخاطب آن، نگرانی های عملکردی را ایجاد می کند.</li>
            <li>نحو پیچیده: اتکای SOAP به XML و نحو پیچیده آن می‌تواند استخراج داده‌ها را پیچیده و زمان‌بندی توسعه را طولانی کند.
            </li>
        </ul>
        <p>بی‌طرفی پروتکل، ویژگی‌های امنیتی و پشتیبانی از قابلیت اطمینان تراکنشی SOAP، آن را به گزینه‌ای قوی برای برنامه‌های کاربردی در سطح سازمانی تبدیل می‌کند که در آن این ویژگی‌ها بسیار مهم هستند. با این حال، سربار عملکرد و پیچیدگی نحوی آن نشان می‌دهد که قبل از پذیرش، به‌ویژه برای برنامه‌هایی که کارایی و سادگی در آن‌ها اهمیت دارد، به دقت توجه شود. SOAP یک معماری API محوری باقی می‌ماند که تعادلی بین عملکرد جامع و الزامات یکپارچه‌سازی سیستم پیچیده را در بر می‌گیرد.</p>
    </section>
    <section id="rest">
        <h3>(REST) Representational State Transfer</h3>
        <img src="images/4.8 photo.png" width="450" alt=""><br>
        <p>REST، مخفف Representational State Transfer، یک رویکرد معماری متمایز را برای طراحی API اتخاذ می کند. این الگویی است که به طور گسترده در برنامه های کاربردی وب مدرن استفاده می شود و روشی انعطاف پذیر و کارآمد برای مدیریت اجزای مختلف برنامه مانند فایل ها، اشیاء و رسانه ها ارائه می دهد. API های REST عملکرد را بر روی HTTP تسهیل می کنند و از افعال HTTP مانند GET و POST برای پشتیبانی از قابلیت همکاری در سراسر وب استفاده می کنند و آنها را به انتخابی ارجح برای بسیاری از توسعه دهندگان تبدیل می کند.</p><br>
        <img src="images/4.9 photo.png" width="450" alt="">
    </section>
    <section id="rest1">
        <h3>موارد استفاده ایده آل برای REST</h3>
        <p>REST ارزش خود را در سناریوهایی ثابت می کند که پهنای باند محدود است، عملیات بدون حالت مورد نیاز است، کش بسیار مهم است، و سرعت توسعه ضروری است:</p>
        <ul>
            <li>پهنای باند محدود: اگر با محدودیت‌های پهنای باند کار می‌کنید، فرمت تبادل داده سبک REST (معمولاً JSON) بسیار کارآمدتر از XML پرمخاطب مورد استفاده در پیام‌های SOAP است.
            </li>
            <li>عملیات بدون حالت: REST برای ارتباطات بدون حالت طراحی شده است، و برای تراکنش هایی که نیازی به یادآوری تعاملات قبلی از سوی سرور ندارند، مناسب است.
            </li>
            <li>حجم بالای درخواست ها: امکان ذخیره درخواست ها با REST نیاز به تماس های مکرر باطن را کاهش می دهد و عملکرد و سرعت توسعه را افزایش می دهد.
            </li>
            <li>سادگی و سرعت در توسعه: رویکرد ساده REST و نگاشت مستقیم به افعال HTTP، فرآیند کدگذاری را ساده می‌کند و چرخه‌های توسعه سریع‌تر را ممکن می‌سازد.
            </li>
        </ul>
        <h4>مزایا و معایب REST:</h4>
        <ul>
            <li>بدون وضعیت: هر تماس API مستقل است، تراکنش ها را سرعت می بخشد و معماری سرور را ساده می کند.
            </li>
            <li>انعطاف‌پذیری فرمت: API‌های REST می‌توانند در قالب‌های مختلف ارتباط برقرار کنند و در نحوه مدیریت و ارائه داده‌ها تطبیق‌پذیری ایجاد کنند.
            </li>
            <li>پشتیبانی از حافظه پنهان: REST ذخیره اطلاعات کارآمد، کاهش درخواست های غیر ضروری سرور و بهبود عملکرد برنامه را امکان پذیر می کند.
            </li>
        </ul>
        <h4>معایب:
        </h4>
        <ul>
            <li>عدم استانداردسازی: بدون استانداردهای پذیرفته شده جهانی، پیاده سازی REST می تواند متفاوت باشد و به طور بالقوه توسعه و یکپارچه سازی API را پیچیده کند.
            </li>
            <li>محدودیت HTTP: همراهی محکم با HTTP می‌تواند REST را در محیط‌هایی که ممکن است پروتکل‌های ارتباطی جایگزین ترجیح داده شوند، محدود کند.

            </li>
        </ul>
    </section>
    <section id="rest2">
        <h3>روش های REST API و ساختار درخواست</h3>
        <img src="images/4.10 photo.png" width="450" alt=""><br>
        <p>هر درخواست REST شامل چهار بخش اساسی است: یک روش HTTP، یک نقطه پایانی، هدرها و یک بدنه.
            یک روش HTTP توصیف می کند که با یک منبع چه کاری باید انجام شود. چهار روش اساسی وجود دارد که عملیات CRUD نیز نامیده می شود:
            </p>
            <ul>
                <li>POST برای ایجاد یک منبع پست کنید،</li>
                <li>Get دریافت یک منبع،</li>
                <li>PUT  قرار دادن برای به روز رسانی یک منبع، و
                </li>
                <li>DELETE برای حذف یک منبع.</li>
            </ul>
            <p>یک نقطه پایانی (Endpoint) حاوی یک شناسه منبع یکنواخت (URI) است که نشان می دهد کجا و چگونه منبع را در اینترنت پیدا کنید. متداول ترین نوع URI یک مکان منبع منحصر به فرد (URL) است که به عنوان یک آدرس وب کامل عمل می کند.
                هدرها (Headers) اطلاعات مربوط به مشتری و سرور را ذخیره می کنند. به طور عمده، هدرها داده‌های احراز هویت را ارائه می‌کنند - مانند یک کلید API، نام یا آدرس IP رایانه‌ای که سرور در آن نصب شده است، و اطلاعات مربوط به فرمت پاسخ.
                یک بدنه (Body) برای انتقال اطلاعات اضافی به سرور استفاده می شود. به عنوان مثال، ممکن است بخشی از داده باشد که می خواهید اضافه یا جایگزین کنید.
                </p>
    </section>
    <section id="rest3">
        <h3>ساختار پاسخ REST</h3><br>
        <img src="images/4.11 photo.png" width="450" alt=""><br>
        <p>در پاسخ، سرور نه خود منبع مورد نظر، بلکه نمایش آن را می فرستد - یک توصیف قابل خواندن توسط ماشین از وضعیت فعلی آن. یک منبع را می توان در قالب های مختلف نشان داد، اما محبوب ترین آنها XML و JSON هستند.


            هر زمان که مرتبط باشد، یک سرور در پاسخ، هایپرلینک ها یا ابررسانه هایی را که به منابع مرتبط دیگر پیوند می دهند، شامل می شود. به این ترتیب، سرور دستورالعمل هایی را در مورد کارهای بعدی که مشتری می تواند انجام دهد و درخواست های بعدی را ارائه می دهد.
            </p>
        <ul>
            <li>نمونه ای از تماس REST API
            </li>
            <li>سناریویی را در نظر بگیرید که در آن باید جزئیات یک کاربر را با استفاده از REST API فچ (فچ کردن) کنید. عملیات را می توان به صورت زیر ساختار داد:
            </li>
        </ul>
        <p>Request:</p><br>
        <img src="images/4.12 photo.png" width="450" alt=""><br>
        <p>Response:</p><br>
        <img src="images/4.13 photo.png" width="450" alt=""><br>
        <p>این مثال یک تماس REST API را نشان می‌دهد که در آن مشتری جزئیات کاربر را با یک درخواست GET درخواست می‌کند و سرور با اطلاعات کاربر در قالب JSON پاسخ می‌دهد.
        </p>
    </section>
    <section id="rest4">
        <h3>REST در مقابل SOAP: ملاحظات عملکرد</h3><br>
        <img src="images/4.14 photo.png" width="450" alt=""><br>
        <p>REST اغلب از نظر سرعت و کارایی از SOAP پیشی می‌گیرد، زیرا ماهیت کمتر دست و پا گیر آن، اتکا به JSON (که معمولاً سبک‌تر از XML است) و توانایی آن در کش کردن داده‌ها. SOAP با مشخصات سختگیرانه و ویژگی های امنیتی خود، ذاتاً پیچیده تر و پرمخاطب تر است که منجر به استفاده از پهنای باند بیشتر و عملکرد کندتر در سناریوهایی می شود که REST می تواند کافی باشد.

            به طور خلاصه، APIهای REST یک رویکرد انعطاف‌پذیر، کارآمد و توسعه‌دهنده را برای ساخت سرویس‌های وب ارائه می‌کنند، به خصوص زمانی که عملکرد، سادگی و سرعت بسیار مهم هستند. توانایی آنها برای کار بر روی HTTP، پشتیبانی از فرمت های مختلف داده، و ارتباطات بدون حالت، آنها را برای طیف گسترده ای از برنامه های کاربردی وب مناسب می کند. با این حال، درک زمان و مکان استفاده از REST، بر خلاف معماری های دیگر مانند SOAP، کلیدی برای استفاده از پتانسیل کامل آن است.
            </p>
    </section>
    <section id="graph">
        <h3>GraphQL
        </h3><br>
        <img src="images/4.15 photo.png" width="450" alt=""><br>
        <p>GraphQL به عنوان یک رویکرد دگرگون کننده در عرصه توسعه API است و یک زبان پرس و جو را در کنار یک زمان اجرا سمت سرور برای اجرای آن کوئری ها با استفاده از نوع سیستمی که برای داده های خود تعریف می کنید، ارائه می دهد. برخلاف روش‌های سنتی که در آن سرور ساختار داده‌ها را دیکته می‌کند، GraphQL به مشتریان این امکان را می‌دهد که دقیقاً آنچه را که نیاز دارند درخواست کنند، فچ کردن داده‌ها را کارآمدتر می‌کند و مسائل مربوط به فچ بیش از حد یا کم فچ را کاهش می‌دهد.</p><br>
        <p>GraphQL به عنوان یک رویکرد دگرگون کننده در عرصه توسعه API است و یک زبان پرس و جو را در کنار یک زمان اجرا سمت سرور برای اجرای آن کوئری ها با استفاده از نوع سیستمی که برای داده های خود تعریف می کنید، ارائه می دهد. برخلاف روش‌های سنتی که در آن سرور ساختار داده‌ها را دیکته می‌کند، GraphQL به مشتریان این امکان را می‌دهد که دقیقاً آنچه را که نیاز دارند درخواست کنند، فچ کردن داده‌ها را کارآمدتر می‌کند و مسائل مربوط به فچ بیش از حد یا کم فچ را کاهش می‌دهد.</p>
    </section>
    <section id="graph1">
        <h3>تشخیص GraphQL از REST</h3><br>
        <img src="images/4.16 photo.png" width="450" alt=""><br>
        <p>در حالی که REST یک استاندارد دیرینه برای APIهای وب بوده است و از روش‌های HTTP برای مدیریت منابع استفاده می‌کند، اغلب منجر به فچ کردن بیش از حد یا کمتر از حد داده‌ها می‌شود و به‌روزرسانی‌های بلادرنگ را به طور موثر پشتیبانی نمی‌کند. GraphQL این کاستی ها را با ارائه موارد زیر برطرف می کند:
        </p>
        <ul>
            <li>یک نقطه پایانی واحد برای پرس و جوها، اجتناب از نیاز به درخواست های متعدد برای داده ها از منابع مختلف.
            </li>
            <li>توانایی مشخص کردن دقیقاً چه داده‌هایی در یک درخواست مورد نیاز است، در نتیجه فچ کردن بیش از حد یا کم فچ  را حذف می‌کند.
            </li>
            <li>پشتیبانی از به روز رسانی داده ها در زمان واقعی از طریق اشتراک، افزایش ماهیت پویا برنامه های وب.
            </li>
        </ul>
    </section>
    <section id="graph2">
        <h3>مفاهیم کلیدی در GraphQL
        </h3><br>
        <p>نوع سیستم: اساس GraphQL سیستم نوع قوی آن است که امکان تعریف انواع سفارشی در کنار انواع داخلی مانند Int، Float و String را فراهم می کند. به عنوان مثال، تعریف یک نوع کاربر ممکن است به شکل زیر باشد:
        </p><br>
        <img src="images/4.17 photo.png" width="450" alt=""><br>
        <p>Schema: طرحواره ای که با استفاده از زبان تعریف طرحواره (SDL) تعریف شده است، ساختار داده های موجود از طریق GraphQL API شامل انواع شی، فیلدها و روابط آنها را مشخص می کند.

            Resolvers: این توابع هر فیلد در یک جستار GraphQL را به یک منبع داده متصل می کنند و اطمینان می دهند که داده های صحیح در پاسخ به پرس و جوها فچ  شده و برگردانده می شوند.
            </p><br>
            <p>کوئری ها و جهش ها / Queries and Mutations: کوئری ها در GraphQL داده ها را بازیابی می کنند (مشابه درخواست GET REST)، در حالی که جهش ها داده ها را تغییر می دهند (شبیه به POST، PUT، PATCH، DELETE در REST). یک درخواست برای فچ  جزئیات کاربر ممکن است به شکل زیر باشد:
            </p><br>
            <img src="images/4.18 photo.png" width="450" alt=""><br>
            <p>اشتراک‌ها / Subscriptions: اشتراک‌ها مکانیزمی برای به‌روزرسانی‌های بی‌درنگ فراهم می‌کنند و به مشتریان این امکان را می‌دهند که داده‌های جدید را به‌محض در دسترس بودن بدون نیاز به نظرسنجی دریافت کنند.
            </p><br>
            <h4>مزایای استفاده از GraphQL</h4>
            <ul>
                <li>انعطاف پذیری و کارایی: مشتریان می توانند داده ها را از منابع متعدد در یک درخواست فچ  کنند و دقیقاً آنچه را که نیاز دارند مشخص کنند.
                </li>
                <li>Evolution Without Versioning: فیلدها و انواع جدیدی را می توان بدون تأثیر بر پرس و جوهای موجود به API اضافه کرد.</li>
                <li>تایپ قوی: سیستم مبتنی بر طرحواره و با تایپ قوی، تشخیص زودهنگام خطاها را تسهیل می کند و از تولید خودکار اسناد پشتیبانی می کند.
                </li>
                <li>داده‌های بی‌درنگ با اشتراک‌ها: عملکرد بی‌درنگ در GraphQL تعبیه شده است، و آن را برای برنامه‌هایی که نیاز به به‌روزرسانی فوری داده دارند، ایده‌آل می‌کند.
                </li>
            </ul>
            <h4>چالش ها و ملاحظات</h4>
            <ul>
                <li>پیچیدگی: پیاده سازی GraphQL API می تواند پیچیدگی را در سمت سرور ایجاد کند که نیاز به طراحی و نگهداری دقیق دارد.
                </li>
                <li>منحنی یادگیری: توسعه دهندگان ممکن است به دلیل رویکرد منحصر به فرد GraphQL در مقایسه با API های سنتی REST با منحنی یادگیری مواجه شوند.
                </li>
                <li>امنیت: برای جلوگیری از سوء استفاده از انعطاف پذیری GraphQL پرس و جوهای مخرب باید اقدامات مناسبی انجام شود.
                </li>
            </ul>
    </section>
    <section id="graph3">
        <h3>ساخت GraphQL API</h3><br>
        <p>ایجاد یک GraphQL API شامل تعریف یک طرحواره، راه‌اندازی حل‌کننده‌ها، و نوشتن کوئری‌ها، جهش‌ها و احتمالاً اشتراک‌ها است. ابزارهایی مانند Back4app این فرآیند را با ایجاد خودکار یک طرح GraphQL بر اساس مدل‌های پایگاه داده ساده می‌کنند و تلاش دستی مربوط به توسعه API را به میزان قابل توجهی کاهش می‌دهند. این انتزاع نه تنها روند توسعه را تسریع می‌کند، بلکه تضمین می‌کند که توسعه‌دهندگان می‌توانند بر روی ساختن بخش مقدماتی و منطق تجاری برنامه‌های خود تمرکز کنند.
        </p><br>
        <p>GraphQL نشان دهنده تغییر قابل توجهی در نحوه طراحی و مصرف API ها است و رویکردی کارآمدتر، انعطاف پذیرتر و سازگارتر با توسعه دهندگان را ارائه می دهد. چه در حال شروع یک پروژه جدید باشید و چه به دنبال بهبود یک برنامه کاربردی موجود باشید، GraphQL مجموعه ابزار قدرتمندی برای ساخت APIهای پویا، مقیاس پذیر و کارآمد ارائه می دهد.</p>
        
    </section>
    <section id="google">
        <h3>(gRPC) Google Remote Procedure Call</h3>
          <section id="google1">
          <h4>تماس رویه از راه دور (RPC) چیست؟</h4>
        
          <p>RPC یا  Remote Procedure Call یک ارتباط بین فرایندی است که در آن یک برنامه کامپیوتری رویه ای (عملکرد یا روش) را برای اجرا در فضای آدرسی متفاوت از فضای خود فراخوانی می کند. RPC این توهم را به کلاینت می دهد که یک متد محلی را فراخوانی می کند، اما در واقع، متدی را در یک ماشین راه دور فراخوانی می کند که وظایف لایه شبکه را انتزاع می کند. RPC از یک پروتکل درخواست-پاسخ (مدل کلاینت-سرور) پیروی می کند. شکل زیر چرخه عمر RPC را نشان می دهد.</p><br>
          <ul>پیاده سازی های مختلفی از RPC ها وجود دارد. آن ها هستند:

            <li> gRPC (Google)
            </li>
            <li>Thrift (فیس بوک)</li>
            <li>Finagle (توئیتر)</li>
          </ul>
          <p>شناخته شده ترین فریم ورکی که یک RPC می سازد gRPC است. gRPC مانند Docker و Kubernetes بخشی از Cloud Native Computing Foundation است. RPC مخفف فراخوانی روش از راه دور است.
        </p><br>
        <img src="images/4.19 photo.png" width="450" alt=""><br>
        <ol>
            <li>Unary RPC که در آن مشتری یک درخواست واحد را به سرور ارسال می کند و یک پاسخ را دریافت می کند.</li>
            <li>Server Stream RPC که در آن مشتری درخواستی را به سرور ارسال می کند و جریانی از پاسخ ها را دریافت می کند.</li>
            <li>Client Stream RPC که در آن مشتری یک سری پیام را به سرور ارسال می کند، که سپس یک پاسخ را برمی گرداند.</li>
            <li>Bidirectional RPC که در آن هر دو طرف جریانی از پیام ها را به یکدیگر ارسال می کنند.</li>

        </ol>
        <p>gRPC، مخفف Google Remote Procedure Call، یک پروتکل ارتباطی منبع باز است که توسط Google توسعه یافته است. این طراحی شده است تا ارتباط کارآمد و کم تأخیر بین خدمات در یک سیستم توزیع شده را امکان پذیر کند. gRPC از HTTP/2 برای انتقال، (Protocol Buffers (protobufs به عنوان زبان توصیف رابط خود استفاده می‌کند و ویژگی‌هایی مانند احراز هویت، تعادل بار و غیره را ارائه می‌دهد. این به ویژه برای معماری های میکروسرویس که در آن عملکرد و مقیاس پذیری بسیار مهم است، مناسب است</p><br>
        <img src="images/4.20 photo.png" width="450" alt="">
            </section>
    </section>
    <section id="google2">
        <h3>اصول اصلی gRPC
        </h3><br>
        <p>بر اساس HTTP/2: gRPC از HTTP/2 برای انتقال استفاده می‌کند که امکان جریان‌های چندگانه را در یک اتصال واحد فراهم می‌کند. این امر منجر به کاهش تاخیر و افزایش کارایی در ارتباط بین سرویس ها می شود.

            بافرهای پروتکل: gRPC از بافرهای پروتکل استفاده می‌کند، یک مکانیسم خنثی برای زبان، خنثی از پلتفرم، و قابل توسعه برای سریال‌سازی داده‌های ساخت‌یافته. این انتخاب از نظر کارایی و سادگی نسبت به JSON یا XML که معمولاً در API های RESTful استفاده می شوند، مزایایی را ارائه می دهد.
            
            قراردادهای قوی تایپ شده: با gRPC، قراردادهای خدمات با استفاده از فایل های .proto تعریف می شوند. این یک سطح API با تایپ قوی را تضمین می کند که در آن ساختار داده ها و قابلیت های سرویس به وضوح مشخص شده است.
            </p><br>
            <ul>gRPC یک انتخاب ایده آل در سناریوهایی است که:
                <li>تأخیر کم و توان عملیاتی بالا مورد نیاز است: استفاده از HTTP/2 و بافرهای پروتکل، gRPC را بسیار کارآمد و سریع می کند، که برای میکروسرویس هایی که به طور مکرر ارتباط برقرار می کنند یا حجم زیادی از داده را مدیریت می کنند، بسیار مهم است.
                </li>
                <li>سازگاری بین زبانی مورد نیاز است: gRPC از طیف گسترده ای از زبان های برنامه نویسی پشتیبانی می کند و ایجاد سیستم هایی متشکل از اجزای نوشته شده به زبان های مختلف را آسان می کند.
                </li>
                <li>قراردادهای سختگیرانه API مفید هستند: ماهیت قوی تایپ شده API های gRPC به تشخیص زودهنگام مشکلات کمک می کند و ارتباط واضح تر بین بخش های مختلف یک سیستم را تسهیل می کند.

                </li>
            </ul>
            <ul>مزایای gRPC
                <li>عملکرد: استفاده gRPC از HTTP/2 و بافرهای پروتکل منجر به بارهای کوچکتر و ارتباطات سریعتر می شود.
                </li>
                <li>قابلیت همکاری: پشتیبانی gRPC از زبان های برنامه نویسی متعدد، قابلیت همکاری را در یک اکوسیستم میکروسرویس ارتقا می دهد.
                </li>
                <li>پشتیبانی جریان: پشتیبانی درجه یک gRPC برای استریم برای ارتباطات بلادرنگ و انتقال داده های بزرگ ایده آل است.

                </li>
            </ul>
            <ul>ملاحظات مربوط به gRPC
                <li>پشتیبانی مرورگر: gRPC-Web، گونه‌ای از gRPC، به دلیل پشتیبانی محدود مرورگر از ویژگی‌های HTTP/2 مورد استفاده توسط gRPC، برای تعامل با برنامه‌های کاربردی وب مورد نیاز است.
                </li>
                <li>پیچیدگی عملیاتی: ماهیت باینری پیام‌های gRPC و استفاده از HTTP/2 ممکن است پیچیدگی‌های عملیاتی را ایجاد کند، مانند نیاز به ابزار خاصی برای اشکال‌زدایی و نظارت.
                </li>
                <li>منحنی یادگیری: پذیرش gRPC مستلزم آشنایی با بافرهای پروتکل و خود چارچوب gRPC است که ممکن است در مقایسه با APIهای JSON/REST منحنی یادگیری را ارائه دهد.</li>
            </ul>
    </section>
    <section id="google3">
        <h3>نمونه ای از سرویس gRPC
        </h3><br>
        <p>تعریف سرویس gRPC شامل مشخص کردن روش های سرویس و نوع درخواست و پاسخ آنها در یک فایل .proto است. در اینجا یک مثال ساده آورده شده است:
        </p><br>
        <img src="images/4.21 photo.png" width="450" alt=""><br>
        <div>
            <img src="images/4.22 photo.png" width="450" alt="">

        </div>
        <p>این فایل .proto یک سرویس Greeter را با روش SayHello تعریف می‌کند و نشان می‌دهد که چگونه gRPC اجازه می‌دهد تا مشخصات API واضحی را ارائه دهد.

            gRPC یک رویکرد قوی و با کارایی بالا برای ساختن سیستم‌ها و ریزسرویس‌های توزیع‌شده ارائه می‌دهد که با تایپ قوی، رمزگذاری داده‌های کارآمد و پشتیبانی از زبان گسترده پشتیبانی می‌شود. در حالی که پیچیدگی‌های عملیاتی و یادگیری خاصی را به همراه دارد، مزایای آن از نظر عملکرد و مقیاس‌پذیری، آن را به انتخابی قانع‌کننده برای بسیاری از موارد استفاده می‌کند، به‌ویژه در مواردی که تأخیر کم و کارایی بالا در اولویت هستند. مانند هر تصمیم دیگری در زمینه فناوری، مناسب بودن gRPC باید در زمینه الزامات پروژه و قابلیت‌های زیرساختی خاص ارزیابی شود.
            </p>
    </section>

    <section id="socket">
        <h3>وب سوکت</h3><br>
        <img src="images/4.23 photo.png" width="450" alt=""><br>
        <p>WebSocket یک پروتکل ارتباطی است که کانال های ارتباطی تمام دوبلکس را از طریق یک اتصال TCP با عمر طولانی فراهم می کند. WebSocket که به عنوان بخشی از مشخصات HTML5 ایجاد شده است، مرورگرها و سرورها را قادر می سازد تا داده ها را بدون سربار و محدودیت های مرتبط با اتصالات HTTP سنتی مبادله کنند. این باعث می‌شود WebSocket مخصوصاً برای برنامه‌های بلادرنگی که به تأخیر کم نیاز دارند، مانند سیستم‌های چت زنده، بازی‌ها و پلتفرم‌های معاملات مالی، مناسب باشد.</p>
    </section>
    <section id="socket1">
        <h3>ویژگی های اصلی WebSocket</h3><br>
        <p>ارتباطات Full-Duplex: بر خلاف HTTP، که در آن ارتباطات معمولاً توسط مشتری آغاز می شود، WebSocket به مشتری و سرور اجازه می دهد تا داده ها را به طور مستقل و همزمان ارسال کنند.
            Single Connection: هنگامی که یک اتصال WebSocket برقرار شد، باز می ماند و اجازه می دهد تا داده ها در همان اتصال به عقب و جلو ارسال شوند و تاخیر و سربار کاهش یابد.
            کارآمد: WebSocket نیاز به باز کردن و بستن مکرر اتصالات را برطرف می کند، همانطور که در مکانیسم های نظرسنجی HTTP معمول است، و آن را برای به روز رسانی داده های بلادرنگ کارآمدتر می کند.
            سازگاری: WebSocket برای کار بر روی پورت های وب استاندارد (80 و 443) طراحی شده است که به جلوگیری از مشکلات فایروال و پروکسی که می تواند بر پورت های غیر استاندارد تأثیر بگذارد کمک می کند.
            </p><br>
            <img src="images/4.24 photo.png" width="450" alt="">
    </section>
    <section id="socket2">
        <h3>چه زمانی از WebSocket استفاده کنیم؟</h3><br>
        <p>WebSocket در سناریوهایی می درخشد که نیاز به به روز رسانی داده ها در زمان واقعی با حداقل تأخیر دارند، مانند:

            اعلان‌های زنده: به‌روزرسانی فوری کاربران با اعلان‌ها یا هشدارها.
            برنامه های مشترک: فعال کردن ویژگی های همکاری بلادرنگ در برنامه هایی مانند Google Docs.
            بازی آنلاین: ارائه تعامل بدون درز و زمان واقعی در بازی های چند نفره.
            برنامه های مالی: نمایش نمادهای سهام زنده، سیستم های معاملاتی و به روز رسانی داده های مالی.
            </p>
    </section>
    <section id="socket3">
        <h3>مثالی از استفاده از WebSocket</h3><br>
        <p>ایجاد یک اتصال WebSocket ساده شامل اجرای سمت کلاینت و سمت سرور است. در اینجا یک مثال اساسی برای نشان دادن آمده است:</p><br>
        <h4>سمت مشتری (جاوا اسکریپت):</h4><br>
        <img src="images/4.25 photo.png" width="450" alt=""><br>
        <h4>سمت سرور (Node.js با کتابخانه ws):</h4><br>
        <img src="images/4.26 photo.png" width="450" alt="">
        <div>
          <img src="images/4.27 photo.png" width="450" alt=""></div>
        <p>این مثال یک اتصال WebSocket را نشان می دهد که در آن سرور به اتصالات و پیام های دریافتی گوش می دهد و مشتری و سرور می توانند برای یکدیگر پیام ارسال کنند.
        </p>
        <ul>مزایای WebSocket
            <li>تبادل داده در زمان واقعی: WebSocket مکانیزمی را برای جریان داده در زمان واقعی بین کلاینت ها و سرورها فراهم می کند.
            </li>
            <li>تأخیر کاهش یافته: با حفظ یک اتصال مداوم، WebSocket تأخیر درگیر در ارتباطات را به حداقل می رساند.
            </li>
            <li>استفاده کارآمد از منابع: اتصال تکی و طولانی مدت WebSocket نسبت به اتصالات HTTP که برای هر درخواست باز و بسته می شوند، کارآمدتر است.
            </li>
        </ul>
        <ul>ملاحظات برای WebSocket
            <li>پیچیدگی در مقیاس‌بندی: مدیریت تعداد زیادی از اتصالات باز WebSocket می‌تواند چالش‌هایی را در مقیاس‌بندی و مدیریت منابع ایجاد کند.
            </li>
            <li>ملاحظات امنیتی: پیاده سازی اتصالات WebSocket ایمن (wss://) بسیار مهم است، زیرا اتصالات پایدار می توانند اهدافی برای تهدیدات امنیتی باشند.
            </li>
            <li>مکانیسم‌های بازگشتی: برای محیط‌هایی که WebSocket پشتیبانی نمی‌شود، مکانیسم‌های بازگشتی مانند نظرسنجی طولانی همچنان ممکن است مورد نیاز باشد.
            </li>
        </ul>
        <p>WebSocket یک پروتکل قدرتمند برای ساخت برنامه های کاربردی وب تعاملی و بلادرنگ ارائه می دهد. توانایی آن در تسهیل ارتباطات تمام دوبلکس از طریق یک اتصال، آن را برای برنامه‌هایی که نیاز به به‌روزرسانی فوری داده و تعامل دارند، ایده‌آل می‌کند. در حالی که WebSocket مزایای قابل توجهی در عملکرد و کارایی دارد، همچنین نیازمند بررسی دقیق مسائل امنیتی، مقیاس پذیری و سازگاری است. با استفاده مناسب از WebSocket، توسعه دهندگان می توانند تجربیات کاربر بسیار پاسخگو و جذاب ایجاد کنند.</p>
    </section>



    <section id="hook">
        <h3>وب هوک</h3><br>
        <img src="images/4.28 photo.png" width="450" alt=""><br>
        <p>WebHooks تماس‌های HTTP تعریف‌شده توسط کاربر هستند که روشی سبک و کارآمد برای پیاده‌سازی ارتباط رویداد محور بین برنامه‌ها بر روی وب ارائه می‌کنند. اساساً، WebHooks به یک برنامه اجازه می‌دهد تا به‌جای اینکه سیستم دریافت‌کننده را به‌طور مداوم تغییرات را نظرسنجی کند، در زمان وقوع یک رویداد، به یک سیستم یا سرویس دیگر اطلاع دهد. این مکانیسم WebHooks را به ویژه برای سناریوهایی مفید می‌کند که در آن واکنش‌های به‌موقع به رویدادهای خاص، مانند اعلان‌های پرداخت، به‌روزرسانی‌های سرویس‌های شخص ثالث، یا ادغام با سایر برنامه‌های وب، حیاتی هستند.</p><br>
    </section>
    <section id="hook1">
        <h3>ویژگی های اصلی WebHooks</h3><br>
        <p>رویداد محور: WebHok ها توسط رویدادهای خاصی مانند ثبت نام کاربر جدید، آپلود فایل یا تکمیل تراکنش فعال می شوند. هنگامی که رویداد تعریف شده رخ می دهد، WebHook یک درخواست HTTP را به یک URL پیکربندی شده ارسال می کند.
            ساده و انعطاف پذیر: پیاده سازی WebHooks فقط به توانایی رسیدگی به درخواست های HTTP و ارسال درخواست های HTTP POST نیاز دارد. این سادگی WebHooks را با موارد استفاده مختلف سازگار می کند.
            اعلان‌های بلادرنگ: WebHooks اعلان‌های تقریباً آنی در مورد رویدادها ارائه می‌کند و نیاز به مکانیسم‌های نظرسنجی با منابع فشرده را کاهش می‌دهد.
            خدمات جداشده: با تکیه بر WebHooks برای ارتباطات، سرویس‌ها می‌توانند به طور مستقل عمل کنند و اتصال محکم را کاهش دهند و ماژولار بودن را افزایش دهند.
            </p>
    </section>
    <section id="hook2">
        <h3>چه زمانی از WebHooks استفاده کنیم؟
        </h3><br>
        <p>WebHooks در شرایطی که ارتباط به موقع و کارآمد بین سیستم ها یا خدمات متفاوت مورد نیاز است ایده آل هستند، از جمله:</p>
        <ul>
            <li>WebHooks در شرایطی که ارتباط به موقع و کارآمد بین سیستم ها یا خدمات متفاوت مورد نیاز است ایده آل هستند، از جمله:</li>
            <li>Automating Workflows: راه‌اندازی دنباله‌ای از اقدامات در سیستم‌های مختلف هنگام وقوع یک رویداد، مانند ارسال ایمیل، به‌روزرسانی پایگاه‌های داده یا شروع فرآیندهای ساخت.</li>
            <li>ایجاد اکوسیستم‌های مبتنی بر API: به توسعه‌دهندگان شخص ثالث امکان می‌دهد تا عملکرد یک پلتفرم یا سرویس را با اشتراک در رویدادهای خاص گسترش دهند.</li>

            
        </ul>
    </section>
    <section id="hook3">
        <h3>مثالی از استفاده از WebHook</h3>
        <p>فروشگاه آنلاینی را در نظر بگیرید که هر زمان که فروش رخ می دهد نیاز به به روز رسانی سیستم مدیریت موجودی خارجی دارد. یک WebHook را می توان برای اطلاع رسانی به سیستم موجودی در زمان واقعی تنظیم کرد.
        </p>
        <ul>راه اندازی WebHook (شبه کد / Pseudo-code):
            <li>سیستم فروشگاه آنلاین امکان ثبت URL WebHook برای رویدادهای فروش را فراهم می کند.</li>
            <li>سیستم مدیریت موجودی یک URL (به عنوان مثال، https://inventory.example.com/webhook) برای دریافت اعلان ها ارائه می دهد.</li>
        </ul>
        <p>سمت فروشگاه اینترنتی:</p><br>
        <p>هنگامی که فروش کامل شد، سیستم فروشگاه یک درخواست HTTP POST به آدرس وب هوک سیستم موجودی با جزئیات مربوط به فروش ارسال می کند.</p>
        <img src="images/4.29 photo.png" width="450" alt=""><br>
        <p>سمت سیستم موجودی:
        </p><br>
        <p>سیستم موجودی به درخواست های HTTP POST دریافتی در نقطه پایانی /webhook گوش می دهد، جزئیات فروش را تجزیه می کند و موجودی را بر این اساس به روز می کند.
        </p>
        <ul>
            <li>مزایای WebHooks</li>
            <li>کارایی: WebHooks نیاز به نظرسنجی مداوم، کاهش ترافیک شبکه و بار سرور را از بین می برد.
            </li>
            <li>زمان واقعی: آنها اقدام فوری را در پاسخ به رویدادها فعال می کنند و برنامه های بلادرنگ را تسهیل می کنند.
            </li>
            <li>پیاده سازی ساده: WebHooks از روش های استاندارد HTTP استفاده می کند که پیاده سازی و درک آنها را آسان می کند.</li>
        </ul>
        <ul>
            <li>ملاحظاتی برای WebHooks</li>
            <li>امنیت: اطمینان از صحت و یکپارچگی درخواست های دریافتی WebHook بسیار مهم است. استراتژی های رایج شامل استفاده از نشانه های مخفی، HTTPS و اعتبارسنجی منابع درخواست است.</li>
            <li>مدیریت خطا: مدیریت خطاها برای مدیریت خرابی‌ها، مانند مشکلات شبکه یا خرابی سرور مقصد، ضروری است.
            </li>
            <li>مقیاس پذیری: مدیریت حجم زیادی از درخواست های WebHook می تواند چالش برانگیز باشد و به پردازش کارآمد و احتمالاً مکانیسم صف نیاز دارد.
            </li>
        </ul>
        <p>WebHooks یک راه ساده و موثر برای تسهیل ارتباطات بلادرنگ و رویداد محور بین سرویس های وب ارائه می دهد. با استفاده از WebHooks، توسعه‌دهندگان می‌توانند برنامه‌های تعاملی و پاسخ‌گوی بیشتری ایجاد کنند، گردش کار را خودکار کنند و به راحتی با خدمات شخص ثالث ادغام شوند. در حالی که سادگی و قابلیت های بلادرنگ WebHooks مزایای متعددی را به همراه دارد، توجه به ملاحظات امنیتی، مدیریت خطا و مقیاس پذیری برای اطمینان از اجرای قوی مهم است.</p>
    </section>



    <section id="mq">
        <h3>MQTT) Message Queuing Telemetry Transport)</h3><br>
        <img src="images/4.30 photo.png" width="450" alt=""><br>
        <p>MQTT که مخفف عبارت Message Queuing Telemetry Transport است، یک پروتکل پیام رسانی سبک است که برای شبکه های با پهنای باند کم، تأخیر بالا یا غیرقابل اعتماد طراحی شده است. MQTT که در اواخر دهه 1990 برای نظارت بر خطوط لوله نفت از طریق اتصالات ماهواره ای توسعه داده شد، به یک انتخاب محبوب برای برنامه های مختلف (Internet of Things (IoT تبدیل شده است که امکان ارتباط کارآمد و قابل اعتماد بین دستگاه ها را فراهم می کند.</p>
    </section>
    <section id="mq1">
        <h3>ویژگی های اصلی MQTT
        </h3>
        <img src="images/4.31 photo.png" width="450" alt="">
        <ul>
            <li>ightweight Protocol: پروتکل MQTT برای به حداقل رساندن پهنای باند شبکه و منابع مورد نیاز دستگاه طراحی شده است و آن را برای دستگاه ها و شبکه های محدود ایده آل می کند.</li>
            <li>مدل انتشار/اشتراک - Publish/Subscribe Model: برخلاف مدل‌های سنتی مشتری-سرور، MQTT بر روی یک مکانیسم انتشار/اشتراک عمل می‌کند، که در آن کلاینت‌ها مشترک موضوعات هستند و زمانی که داده‌ها در مورد آن موضوعات منتشر می‌شود، پیام‌ها به همه مشترکین ارسال می‌شود.</li>
            <li>Quality of Service (QoS) Levels: پروتکل MQTT از سه سطح QoS برای مدیریت تضمین های تحویل پیام، از تحویل "حداکثر یک بار" تا "دقیقا یک بار" پشتیبانی می کند و نیازهای مختلف قابل اطمینان و تحویل را برآورده می کند.</li>
            <li>(Last Will and Testament (LWT: قابلیتی که به مشتریان اجازه می دهد در صورت قطع غیرمنتظره ارتباط، پیامی از پیش تعریف شده را به یک موضوع مشخص ارسال کنند که برای نظارت بر اتصال و وضعیت دستگاه مفید است.</li>
            <li>(Last Will and Testament (LWT: قابلیتی که به مشتریان اجازه می دهد در صورت قطع غیرمنتظره ارتباط، پیامی از پیش تعریف شده را به یک موضوع مشخص ارسال کنند که برای نظارت بر اتصال و وضعیت دستگاه مفید است.</li>
        </ul>
    </section>
    <section id="mq2">
        <h3>چه زمانی از MQTT استفاده کنیم؟
        </h3>
        <p>MQTT به ویژه برای سناریوهایی مناسب است که کارایی شبکه، عمر باتری دستگاه و تحویل پیام قابل اعتماد بسیار مهم است، از جمله:</p>
        <ul>
            <li>ارتباطات IoT و M2M: اتصال تعداد زیادی از دستگاه های کم مصرف و پهنای باند کم در خانه های هوشمند، اینترنت اشیاء صنعتی و نظارت بر محیط زیست.</li>
            <li>به روز رسانی در زمان واقعی: ارائه اطلاعات به موقع در برنامه هایی مانند ردیابی خودرو، هشدارهای اضطراری و به روز رسانی زنده.</li>
            <li>نظارت و کنترل از راه دور: امکان نظارت و کنترل کارآمد و در زمان واقعی بر دستگاه ها و زیرساخت های راه دور.</li>

        </ul>
    </section>
    <section id="mq3">
        <h3>مثالی از استفاده از MQTT</h3><br>
        <img src="images/4.32 photo.png" width="450" alt=""><br>
        <p>یک سناریوی خانه هوشمند را در نظر بگیرید که در آن حسگرهای مختلف داده‌ها (مانند دما، رطوبت) را برای یک کارگزار MQTT منتشر می‌کنند و یک سیستم اتوماسیون خانگی مشترک این موضوعات می‌شود تا به‌روزرسانی‌ها را دریافت کند و بر اساس آنها عمل کند.</p><br>
        <img src="images/4.33 photo.png" width="450" alt=""><br>
        <div>
           <img src="images/4.33 photo.png" width="450" alt="">
        </div>
        <p>این مثال سنسوری را نشان می‌دهد که داده‌های دما را برای یک کارگزار MQTT و یک سیستم اتوماسیون خانگی مشترک برای دریافت این داده‌ها منتشر می‌کند و اقداماتی را بر اساس آخرین خوانش‌های دما انجام می‌دهد.</p>
        <ul>
            <li>مزایای MQTT
            </li>
            <li>کارایی: طراحی سبک MQTT به حداقل پهنای باند شبکه و منابع دستگاه نیاز دارد.</li>
            <li>قابلیت اطمینان: سطوح QoS پروتکل، تحویل پیام قابل اعتماد را حتی در شرایط شبکه ناپایدار تضمین می کند.</li>
            <li>مقیاس پذیری: MQTT می تواند هزاران دستگاه را از طریق یک کارگزار پشتیبانی کند و آن را برای استقرارهای بزرگ اینترنت اشیا مقیاس پذیر می کند.</li>
        </ul>
        <ul>
            <li>ملاحظات برای MQTT</li>
            <li>امنیت: در حالی که MQTT خود سبک وزن است، اجرای اقدامات امنیتی قوی (مانند رمزگذاری TLS/SSL، احراز هویت و مجوز) برای محافظت در برابر تهدیدات احتمالی بسیار مهم است.</li>
            <li>امنیت: در حالی که MQTT خود سبک وزن است، اجرای اقدامات امنیتی قوی (مانند رمزگذاری TLS/SSL، احراز هویت و مجوز) برای محافظت در برابر تهدیدات احتمالی بسیار مهم است.</li>
            <li>پیچیدگی در استقرار در مقیاس بزرگ: مدیریت تعداد زیادی از موضوعات و اشتراک ها در استقرار IoT در مقیاس بزرگ می تواند پیچیده شود و به قراردادهای نامگذاری موضوعات و برنامه ریزی معماری کارآمد نیاز دارد.</li>

        </ul>
        <p>MQTT به عنوان یک پروتکل پیام رسانی قوی و کارآمد برای ارتباطات IoT و M2M متمایز است که ویژگی‌هایی را ارائه می‌کند که برای محیط‌های با پهنای باند کم، تأخیر بالا و تضمین تحویل پیام قابل اعتماد طراحی شده است. سادگی آن، همراه با قابلیت‌های قدرتمندی مانند مدل انتشار/اشتراک و سطوح QoS، MQTT را به انتخابی ارجح برای توسعه‌دهندگانی که برنامه‌های کاربردی اینترنت اشیا متصل، پاسخگو و مقیاس‌پذیر می‌سازند، تبدیل می‌کند. مانند هر پروتکل ارتباطی، پرداختن به ملاحظات امنیتی و مقیاس‌پذیری کلید استقرار راه‌حل‌های موفق مبتنی بر MQTT است.</p>

    </section>
    <section id="am">
        <h3>AMQP) Advanced Message Queuing Protocol)</h3><br>
        <img src="images/4.34 photo.png" width="450" alt=""><br>
        <p>AMQP یا Advanced Message Queuing Protocol یک استاندارد باز برای ارسال پیام بین برنامه ها یا سازمان ها با قابلیت اطمینان و قابلیت همکاری بالا است. بر خلاف MQTT که عمدتاً برای ارتباط دستگاه به دستگاه با کمترین هزینه سربار طراحی شده است، AMQP بر کارگزاری پیام پیچیده و تضمین هایی مانند تحویل پیام، سفارش و مسیریابی تمرکز دارد. AMQP که در ابتدا برای بخش مالی توسعه یافته بود، کاربرد خود را در حوزه های مختلفی که به راه حل های پیام رسانی قوی نیاز دارند، از جمله سیستم های فناوری اطلاعات سازمانی، محاسبات ابری و اینترنت اشیا در مواقعی که الگوهای پیام رسانی پیچیده لازم است، گسترش داده است.</p>

    </section>
    <section id="am1">
        <h3>ویژگی های اصلی AMQP</h3>
        <ul>
            <li>قابلیت اطمینان و امنیت: AMQP مکانیزم‌های داخلی را برای دوام پیام، تأیید، تراکنش‌ها و احراز هویت و رمزگذاری امن ارائه می‌کند.</li>
            <li>مدل‌های پیام‌رسانی انعطاف‌پذیر: از مدل‌های پیام‌رسان نقطه به نقطه و انتشار/اشتراک پشتیبانی می‌کند و طیف وسیعی از موارد استفاده را ارائه می‌دهد.</li>
            <li>قابلیت همکاری: AMQP که با در نظر گرفتن قابلیت همکاری طراحی شده است، رفتار کارگزار پیام و مشتری را الزامی می کند و از رفتار سازگار در بین پیاده سازی های مختلف اطمینان می دهد.</li>
            <li>قابلیت همکاری: AMQP که با در نظر گرفتن قابلیت همکاری طراحی شده است، رفتار کارگزار پیام و مشتری را الزامی می کند و از رفتار سازگار در بین پیاده سازی های مختلف اطمینان می دهد.</li>
        </ul>
    </section>
    <section id="am2">
        <h3>چه زمانی از AMQP استفاده کنیم؟</h3><br>
        <p>AMQP به ویژه برای برنامه هایی مناسب است که در آنها:</p>
        <ul>
            <li>AMQP به ویژه برای برنامه هایی مناسب است که در آنها:</li>
            <li>الگوهای مسیریابی و پیام رسانی پیچیده برای پیاده سازی منطق تجاری و گردش کار پیچیده مورد نیاز است.</li>
            <li>قابلیت همکاری در میان سیستم‌های مختلف مورد نیاز است، که به اجزا و سرویس‌های مختلف، که احتمالاً به زبان‌های مختلف نوشته شده‌اند یا بر روی پلت‌فرم‌های مختلف اجرا می‌شوند، اجازه می‌دهد تا با اطمینان ارتباط برقرار کنند.</li>

        </ul>
    </section>
    <section id="am3">
        <h3>نمونه ای از استفاده از AMQP
        </h3><br>
        <p>یک پلتفرم تجارت الکترونیک را در نظر بگیرید که از AMQP برای پردازش سفارش استفاده می کند. این پلتفرم پیام‌هایی را در مورد سفارش‌های جدید به یک صف ارسال می‌کند که از آنجا چندین سرویس پیام‌ها را برای پردازش پرداخت‌ها، به‌روزرسانی موجودی و رسیدگی به حمل و نقل مصرف می‌کنند.</p>
        <img src="images/4.35 photo.png" width="450" alt=""><br>
        <div>
           <img src="images/4.36 photo.png" width="450" alt=""><br>
        </div>
        <img src="images/4.37 photo.png" width="450" alt=""><br>
        <p>این مثال نشان می‌دهد که چگونه یک پیام سفارش در یک صف AMQP منتشر می‌شود و چگونه یک مصرف‌کننده پیام‌ها را از صف پردازش می‌کند و ارتباط جداشده و قابل اعتماد بین بخش‌های مختلف سیستم را امکان‌پذیر می‌سازد.
        </p>
        <ul>
            <li>مزایای AMQP</li>
            <li>استحکام: تمرکز AMQP بر تحویل پیام و تراکنش‌های قابل اطمینان تضمین می‌کند که پیام‌ها از بین نمی‌روند و آن را برای فرآیندهای تجاری حیاتی ایده‌آل می‌کند.
            </li>
            <li>تطبیق پذیری: پشتیبانی آن از طیف گسترده ای از الگوهای پیام رسانی و گزینه های مسیریابی، انعطاف پذیری را در طراحی برنامه های کاربردی پیچیده فراهم می کند.
            </li>
            <li>قابلیت همکاری: استانداردسازی پروتکل تضمین می کند که پیاده سازی های مختلف AMQP می توانند به طور یکپارچه با هم کار کنند.
            </li>
            <li>قابلیت همکاری: استانداردسازی پروتکل تضمین می کند که پیاده سازی های مختلف AMQP می توانند به طور یکپارچه با هم کار کنند.
            </li>
            <li>پیچیدگی: ویژگی‌ها و قابلیت‌های گسترده AMQP می‌تواند پیچیدگی را در اجرا و عملیات ایجاد کند، به‌ویژه برای موارد استفاده ساده که پروتکل‌های سبک وزن ممکن است کافی باشد.
            </li>
            <li>عملکرد: در حالی که بسیار قابل اعتماد است، سربار اضافی مورد نیاز برای ویژگی های AMQP ممکن است بر عملکرد تأثیر بگذارد، به ویژه در سناریوهایی که تأخیر یک نگرانی اساسی است.
            </li>
            <li>وابستگی کارگزار: انتخاب واسطه پیام و پیکربندی آن می تواند به طور قابل توجهی بر عملکرد و قابلیت اطمینان سیستم های مبتنی بر AMQP تأثیر بگذارد.
            </li>
        </ul>
        <p>AMQP یک راه حل جامع برای پیام رسانی در سطح سازمانی ارائه می دهد که تحویل تضمینی، مسیریابی پیچیده و قابلیت همکاری بین سیستم های مختلف را ارائه می دهد. استحکام و انعطاف پذیری آن را به گزینه ای عالی برای کاربردهای پیچیده ای که نیاز به ارتباط قابل اعتماد دارند تبدیل می کند. با این حال، ملاحظات پیچیدگی و عملکرد به این معنی است که AMQP برای سناریوهایی که ویژگی‌های پیشرفته آن یک ضرورت هستند به جای برنامه‌های ساده‌تر و حساس به تأخیر، مناسب‌تر است. درک الزامات خاص برنامه شما شما را در انتخاب AMQP یا یک پروتکل پیام رسانی جایگزین راهنمایی می کند.</p>

    </section>
    <section id="memari">
        <h3>انتخاب معماری بهینه API
        </h3><br>
        <p>انتخاب معماری API مناسب یک تصمیم حیاتی است که بر عملکرد، امنیت و مقیاس پذیری برنامه تأثیر می گذارد. هر سبک معماری نقاط قوت خود را دارد و برای موارد استفاده خاص مناسب است:</p>
        <ul>
            <li>برای امنیت دقیق و یکپارچگی تراکنش: SOAP بهترین انتخاب است.</li>
            <li>هنگامی که سادگی و مقیاس پذیری کلیدی است: REST یک راه حل کارآمد ارائه می دهد.
            </li>
            <li>برای بهینه سازی بازیابی داده ها در چندین منبع: GraphQL انعطاف پذیری بی نظیری را ارائه می دهد.
            </li>
            <li>برای ارتباطات با کارایی بالا در میکروسرویس ها: gRPC بی همتا است.
            </li>
            <li>WebSocket در سناریوهایی که نیاز به به روز رسانی در زمان واقعی دارند برتر است، در حالی که WebHooks مکانیسم های اعلان رویداد ساده را ارائه می دهد. </li>
            <li>WebSocket در سناریوهایی که نیاز به به روز رسانی در زمان واقعی دارند برتر است، در حالی که WebHooks مکانیسم های اعلان رویداد ساده را ارائه می دهد. </li>
            <li>AMQP با مجموعه ویژگی های قوی خود نیازهای پیچیده پیام رسانی را برآورده می کند.</li>
        </ul>
        <p>درک نیازهای خاص برنامه شما در انتخاب مناسب ترین معماری API بسیار مهم است. خواه قابلیت‌های بلادرنگ WebSocket، دقت GraphQL یا قابلیت اطمینان AMQP باشد، انتخاب درست به اهداف برنامه و چالش‌هایی که می‌خواهد بر آن غلبه کند بستگی دارد.</p>
    </section>
  </section>
    <!--fasle5 gamhaye aval-->
    <section>
        <section id="js">
            <h3>
                فصل پنجم 
                <section id="js">
                <br>
                گام های اول جاوا اسکریپت: راهنمای مقدماتی
            </h3>
        </section>
        <img src="./images/5.1 photo.png" width="450"  alt="">
        <p>
            به سفر هیجان انگیز یادگیری جاوا اسکریپت خوش آمدید! همانطور که به قلمرو جاوا اسکریپت وارد می شویم، در
            مسیری اکتشافی قدم می گذاریم که قدرت، تطبیق پذیری و نحوه دمیدن آن به صفحات وب ثابت را نشان می دهد. این
            راهنما بهعنوان پلهای برای ورود به دنیای جاوا اسکریپت عمل میکند و دانش پایهای را که برای شروع
            اسکریپتنویسی
            نیاز دارید، ارائه میکند <br>
            جاوا اسکریپت یک زبان ضروری برای توسعه وب است که شکاف بین صفحات استاتیک و تجربیات تعاملی را پر می
            کند. همانطور که وارد دنیای جاوا اسکریپت می شوید، سفری را آغاز می کنید که به شما امکان می دهد صفحات وب
            خود را زنده کنید و الیه ای از پویایی و تعامل را اضافه کنید که HTML و CSS به تنهایی نمی توانند به آن دست
            یابند.
            بیایید به جنبه های اساسی جاوا اسکریپت بپردازیم و زمینه را برای اولین تالش شما برای کدنویسی با این زبان
            همه کاره
            آماده کنیم.
        </p>

        <section id="js1">
            <h2>
                جاوا اسکریپت چیست؟
            </h2>

        </section>
        <p>
            جاوا اسکریپت یک زبان برنامه نویسی قدرتمند و سطح باال است که عمدتاً برای توسعه وب استفاده میشود .این
            امکان
            را به شما می دهد تا ویژگی های پیچیده ای را در صفحات وب پیاده سازی کنید، از جمله نقشه های تعاملی، گرافیک
            های
            متحرک D/3D،2 اسکرول جوک باکس های ویدیویی و موارد دیگر. جاوا اسکریپت که در اصل برای زنده کردن
            صفحات وب طراحی شده بود، فراتر از ریشه های مبتنی بر مرورگر خود رشد کرده و تبدیل به یک زبان همه کاره شده
            است که در طیف وسیعی از محیط ها استفاده می شود. <br>
            کد جاوا اسکریپت شامل عبارات و دستورالعمل هایی است که به صورت سینتکس نوشته شده اند که موتور جاوا اسکریپت
            در مرورگر می تواند آن ها را تفسیر و اجرا کند. می توان آن را مستقیماً در صفحات HTML جاسازی کرد یا به
            عنوان
            فایل های جداگانه پیوند داد. یک مثال ساده جاوا اسکریپت ممکن است وقتی کاربر روی دکمه ای کلیک می کند، متن
            یک
            عنصر HTML را تغییر دهد.
        </p>
        <section id="js2">
            <h2>
                نقش جاوا اسکریپت در توسعه وب
            </h2>

        </section>
        <p>
            یک صفحه وب را به عنوان یک سند ثابت تصور کنید - این
            چیزی است که فقط با HTML و CSS بدست می آورید.
            HTML پایه و اساس را ایجاد میکند، محتوایی مانند متن،
            تصاویر و ویدیوها را ساختار میدهد، در حالی که CSS
            سبک، رنگها، فونتها و طرحبندیها را تحت تأثیر قرار
            میدهد. جاوا اسکریپت سه گانه را تکمیل می کند و حرکت و تعامل را به ارمغان می آورد. این به کاربران اجازه می
            دهد
            تا با عناصر موجود در صفحه در زمان واقعی تعامل داشته باشند و تجربه کاربر را به میزان قابل توجهی افزایش
            دهند.
            قبل از فرو رفتن در جاوا اسکریپت، باید با HTML و CSS راحت باشید، زیرا این فناوریها از نزدیک با هم کار
            میکنند. آشنایی با موضوعات زیر باعث می شود تجربه یادگیری روان تری داشته باشید:
        </p>
        <img src="./images/5.2 photo.png" width="450"  alt="">
        <ul>
            <li>
                ساختار اساسی و عناصر اسناد HTML.
            </li>
            <li>
                یک ظاهر طراحی با CSS، از جمله انتخابگرها، ویژگیها و تکنیکهای طرحبندی
            </li>
        </ul>
        <p>
            اگر با این مفاهیم تازه کار هستید، ماژول های ما در HTML و CSS را
            مجددا بررسی کنید تا یک پایه محکم بسازید.
        </p><br>
        <section id="js3">
            <h2>
                یک مثال ساده
            </h2>
            <p>
                یایید تئوری را با یک مثال اساسی برای نشان دادن نقش جاوا اسکریپت عملی کنیم, من از ویرایشگر زیر به
                صورت
                آنالین استفاده می کنم: <br>
                https://playcode.io/javascript
            </p><br>
            <ol>
                <li>
                    ابتدا اجازه دهید فایل html.index خود را آماده کنیم.
                </li>
                <div>
                  <img src="./images/5.3 photo.png" width="450"  alt="">

                </div>

                <img src="./images/5.4 photo.png" width="450"  alt="">
                <li> ساختار HTML: یک دکمه ساده ایجاد کنید.</li> <br> <br>
                <div>
                    <img src="./images/5.5 photo.png" width="450"  alt="" srcset="">

                </div>
                <div>
                    <img src="./images/5.6 photo.png" width="450"  alt=""> <br> <br>

                </div>
                <li>
                    حاال کد زیر را در فایل css.style اضافه کنید.
                </li> <br> <br>
                <img src="./images/5.7 photo.png" width="450"  alt=""> <br> <br>
                <div>
                    <img src="./images/5.8 photo.png" width="450"  alt=""> <br>

                </div>
                <li>
                    تعامل جاوا اسکریپت: کاری کنید که دکمه هنگام کلیک کردن، یک هشدار نمایش دهد. حاال کد جاوا اسکریپت
                    زیر را در فایل های js.script اضافه کنید:

                </li> <br>
                <img src="./images/5.9 photo.png" width="450"  alt=""> <br>
                <p> برای گنجاندن جاوا اسکریپت در سند HTML خود، می توانید از تگ <code>&lt;script&gt;</code>استفاده کنید. جاوا اسکریپت
                    می تواند
                    مستقیما در فایل HTML شما )جاوا اسکریپت درون خطی( گنجانده شود یا به عنوان یک فایل خارجی برای
                    سازماندهی ً
                    کد پاک تر پیوند داده شود. در اینجا نحوه پیوند دادن یک فایل جاوا اسکریپت خارجی آورده شده است,
                    کافی است که کد
                    زیر را در متن فایل html.index خود اضافه کنید:
                </p> <br>
                <img src="./images/5.10 photo.png" width="450"  alt=""> <br>
                <p>
                    ویژگی defer تضمین می کند که اسکریپت پس از تجزیه سند اجرا می شود و از خطاهای احتمالی ناشی از تالش
                    برای
                    دستکاری عناصری که هنوز بارگذاری نشده اند جلوگیری می کند <br><br>
                    حاال با کلیک بر روی دکمه با پیغام زیر مواجه می شوید:
                </p>
                <img src="./images/5.11 photo.png" width="450"  alt="">
                <p>
                    کد باال چگونه کار می کند؟
                </p>

            </ol>
            <ul>
                <li>HTML یک دکمه در صفحه تعریف می کند.</li>
                <li> CSS از یک استایل طراحی استفاده می کند تا دکمه را از نظر بصری جذاب کند.</li>
                <li>جاوا اسکریپت به یک رویداد کلیک روی دکمه گوش می دهد و هنگامی که رویداد رخ می دهد یک گفتگوی
                    هشدار ایجاد می کند</li>
            </ul>

        </section>
        <section id="js4">
            <h2>
                روش های مختلف برای اضافه کردن جاوا اسکریپت
            </h2>
            <p>
                در توسعه وب، دو رویکرد اساسی برای ادغام جاوا اسکریپت در یک وب سایت وجود دارد: داخلی و خارجی. هر دو
                روش موارد استفاده خاص، مزایا و معایب خود را دارند. در اینجا خالصه ای برای روشن شدن تفاوت ها و
                کاربردهای
                کد جاوا اسکریپت داخلی و خارجی آورده شده است:
            </p>
        </section>
        <section id="js5">
            <h2>کد داخلی جاوا اسکریپت</h2> <br>
            <p>
                تعریف: کد جاوا اسکریپت داخلی یا جاسازی شده
                مستقیما در فایل HTML درون تگ های <code>&lt;script&gt;</code>نوشته می شود. ً
                برای اسکریپت های کوچکتر یا کدهای جاوا اسکریپت که مختص یک صفحه است استفاده می شود. این رو
            </p> <br>
            <img src="./images/5.12 photo.png" width="450"  alt=""> <br>
            <p>مزایای کد داخلی:</p> <br>
            <ul>
                <li>سادگی: برای توابع کوچکتر جاوا اسکریپت یا زمانی که کد به طور محکم به نشانه گذاری یک صفحه خاص
                    مرتبط است.</li> <br>
                <li>نمونه سازی سریع: برای آزمایش سریع و نمونه سازی ویژگی ها خوب است.</li> <br>
            </ul>
            <p>معایب کد داخلی:</p> <br>
            <ul>
                <li>
                    عمیر و نگهداری: ممکن است گیج کننده باشد، به خصوص با کدهای بزرگ.
                </li> <br>
                <li>ابلیت استفاده مجدد: کد را نمی توان به راحتی در صفحات دیگر استفاده مجدد کرد.</li> <br>
                <li> سرعت بارگذاری: اگر بلوک اسکریپت بزرگ باشد و قبل از بارگیری صفحه اجرا شود، ممکن است بر سرعت
                    بارگذاری صفحه تأثیر بگذارد.</li> <br>
            </ul>

        </section>
        <section id="js6">
            <h2>کد خارجی جاوا اسکریپت</h2> <br>
            <p>عریف: کد خارجی جاوا اسکریپت در فایل های .js جداگانه ذخیره می شود و از طریق ویژگی src تگ <code>&lt;script&gt;</code>در
                صفحه HTML گنجانده می شود. این رویکرد برای برنامه های بزرگتر ایده آل است، اجازه استفاده مجدد از کد را
                می
                دهد و به ساختار و سازماندهی بهتر کد کمک می کند.</p> <br>
            <img src="./images/5.13 photo.png" width="450"  alt=""> <br>
            <p>در فایل js.script:

            </p>
            <img src="./images/5.14 photo.png" width="450"  alt=""> <br>
            <p>مزایای کد خارجی:</p> <br>
            <ul>
                <li>ابلیت نگهداری: جداسازی تمیز ساختار )HTML)، سبک )CSS )و رفتار )جاوا اسکریپت( را ترویج می کند.
                </li> <br>
                <li>حافظه پنهان: مرورگرها می توانند فایل جاوا اسکریپت خارجی را ذخیره کنند، که سرعت بارگذاری را در
                    بازدیدهای مکرر بهبود می بخشد.</li> <br>
                <li>ابلیت استفاده مجدد: از یک کد به راحتی می توان در چندین صفحه یا پروژه استفاده کرد</li> <br>

            </ul>
            <p>معایب کد خارجی:</p> <br>
            <ul>
                <li> درخواست HTTP اضافی: هر فایل خارجی به درخواست HTTP خود نیاز دارد، که در صورت نیاز به
                    بارگیری بسیاری از اسکریپت های خارجی، می تواند بر زمان بارگذاری تأثیر بگذارد.</li><br>
                <li>وابستگی به ترتیب: ترتیب بارگذاری اسکریپت ها می تواند مهم باشد، به خصوص زمانی که اسکریپت ها به
                    یکدیگر وابسته باشند.</li><br>
            </ul>
            <p>صمیم گیری بین جاوا اسکریپت داخلی و خارجی به عوامل مختلفی از جمله اندازه پروژه، نیاز به استفاده مجدد
                از کد و
                نیازهای خاص وب سایت بستگی دارد. به طور کلی، برای پروژه های بزرگتر و ماژوالر و برای بهبود قابلیت
                نگهداری
                و عملکرد، استفاده از جاوا اسکریپت خارجی ترجیح داده می شود. با این حال، کد داخلی می تواند برای پروژه
                های
                کوچکتر یا توابع خاص مرتبط با صفحه مفید باشد.</p>
        </section>
        <section id="js7">
            <h3>  کنترل کننده های درون خطی جاوا اسکریپت - Javascript Inline</h3> <br>
            <p>کنترل کنندههای جاوا اسکریپت درون خطی، تکههایی از کد جاوا اسکریپت هستند که مستقیماً در تگهای HTML با
                استفاده از ویژگیهای رویداد جاسازی شدهاند. این دستهها برای اجرای توابع یا کدهای جاوا اسکریپت زمانی که
                رویدادهای خاصی روی یک عنصر رخ میدهند، مانند کلیکها، حرکتهای ماوس، ارسالهای فرم، یا هر تعامل کاربر
                دیگری که توسط ویژگیهای رویداد موجود HTML تعریف شده است، استفاده میشود. <br> <br>
                در اینجا یک مثال اساسی وجود دارد که در آن از یک هندلر جاوا اسکریپت درون خطی برای نمایش هشدار هنگام
                کلیک
                روی یک دکمه استفاده می شود:</p> <br>
            <img src="./images/5.15 photo.png" width="450"  alt=""> <br>
            <p>در این مثال، ویژگی onclick در تگ >button >به عنوان کنترل کننده رویداد درون خطی استفاده می شود. هنگامی
                که دکمه کلیک می شود، کد جاوا اسکریپت در ویژگی attribute onclick اجرا می شود و یک جعبه هشدار را به
                کاربر نمایش می دهد.</p> <br>
            <p><strong>onclick (alert('Hello, world!'))
                </strong></p> <br>
            <p><strong>!Best Practices!</strong></p> <br>
            <p>در حالی که کنترل کنندههای جاوا اسکریپت درون خطی میتوانند برای تعامالت ساده یا نمونهسازی سریع مفید
                باشند،
                استفاده از آنها را به نفع جاوا اسکریپت محجوب توصیه نمیکنند. این رویکرد شامل
                شیوههای توسعه وب مدرن عموماً
                جداسازی جاوا اسکریپت از نشانهگذاری HTML و پیوست کردن شنوندگان رویداد به عناصر درون تگهای >script>
                خارجی یا داخلی است. این روش قابلیت نگهداری، قابلیت استفاده مجدد و مقیاس پذیری برنامه های وب را
                افزایش می
                دهد:</p> <br>
            <img src="./images/5.16 photo.png" width="450"  alt=""> <br>
            <p>ین مثال همان نتیجه را به دست میدهد که هندلر درون خطی دارد، اما این کار را بهگونهای انجام میدهد که
                نگهداری آن
                آسانتر است و برای کاربردهای بزرگتر مقیاس بهتری دارد.</p>

        </section>

        <section id="add">
            <h3>
              addEventListener به عنوان جایگزینی برای کنترل کننده های جاوا اسکریپت درون خطی
            </h3>
            <br>
            <p>
                شما می توانید و باید از addEventListener به عنوان جایگزینی برای کنترل کننده های جاوا اسکریپت درون
                خطی
                استفاده کنید و در واقع بهترین روش در توسعه وب مدرن محسوب می شود. متد addEventListener به شما امکان
                می دهد شنوندگان رویداد را بدون جاسازی جاوا اسکریپت مستقیماً در نشانه گذاری HTML خود به عناصر متصل
                کنید.
                این رویکرد با اصول جاوا اسکریپت بدون مزاحمت، که بر جداسازی نگرانی ها تأکید می کند، همسو می شود - جدا
                نگه
                داشتن کدهای CSS ،HTML و جاوا اسکریپت.
            </p> <br>
            <section id="add1">
            <h3>چرا addEventListener ترجیح داده می شود؟
            </h3> <br>
            <ul>
                <li>
                    جداسازی نگرانی ها: کد جاوا اسکریپت شما را جدا از HTML نگه می دارد و نشانه گذاری شما را تمیزتر و
                    خواناتر می کند. این جداسازی تعمیر و نگهداری و رفع اشکال را آسان تر می کند.
                </li>
                <li>قابلیت استفاده مجدد و ماژوالر بودن: با جدا نگه داشتن جاوا اسکریپت، می توان از توابع در عناصر و
                    صفحات
                    مختلف استفاده مجدد کرد و ماژوالر بودن کد را افزایش داد.</li>
                <li>نعطاف پذیری: addEventListener به شما امکان می دهد چندین کنترل کننده رویداد را به یک رویداد در
                    یک عنصر متصل کنید و انعطاف پذیری بیشتری را در نحوه مدیریت رویدادها فراهم می کند.</li>
                <li>قیاس پذیری: با رشد برنامه ها، مدیریت رویدادها با addEventListener مقیاس پذیرتر می شود. مدیریت و
                    بهروزرسانی شنوندگان رویداد در یک اسکریپت متمرکز آسانتر از ردیابی کنترلکنندههای رویداد درون خطی
                    پراکنده در فایلهای HTML است.</li>
            </ul> <br>
            </section>

            <section id="add2">
            <h3> نمونه ای از استفاده از addEventListener</h3>
            <p>در اینجا یک مثال ساده آورده شده است که نحوه استفاده از addEventListener را برای پیوست کردن رویداد
                کلیک
                به یک دکمه نشان می دهد:</p> 
                <br>
            <img src="./images/5.17 photo.png" width="450"  alt=""> <br>
            <p>در این مثال، جاوا اسکریپت به طور کامل از ساختار HTML جدا شده است. شنونده رویداد با شناسه
                clickMeButton
                به دکمه متصل می شود و وقتی دکمه کلیک می شود، یک جعبه هشدار ظاهر می شود. این روش تمیزتر و قابل
                نگهداری
                تر است، به خصوص با افزایش پیچیدگی تعامالت.</p> <br>
            <p>
                ستفاده از addEventListener برای مدیریت رویدادها در جاوا اسکریپت نه تنها توصیه می شود، بلکه سنگ بنای
                شیوه های مدرن و حرفه ای توسعه وب در نظر گرفته می شود. مزایای قابل توجهی از نظر قابلیت نگهداری، مقیاس
                پذیری و عملکرد نسبت به کنترل کننده های رویداد درون خطی ارائه می دهد. اتخاذ این رویکرد در مراحل اولیه
                توسعه
                میتواند به کد پاکتر، اشکالزدایی آسانتر و پایهای بهتر برای رشد پروژههای شما منجر شود.

            </p> <br>
        </section>
        <section id="strategy">
            <h3>استراتژی های بارگذاری اسکریپت و بهترین روش</h3> <br>
            <p>
                در توسعه وب، بارگیری و اجرای موثر جاوا اسکریپت برای بهینه سازی عملکرد و افزایش تجربه کاربر بسیار مهم
                است. استراتژیهای بارگذاری اسکریپت مختلفی را میتوان به کار گرفت که هر کدام دارای مزایا و موارد
                استفاده مناسب
                هستند. در اینجا یک مرور کلی از استراتژی های بارگذاری اسکریپت اولیه و بحثی در مورد بهترین شیوه ها
                وجود دارد.
            </p> <br>
            <ol>
                <li>
                    بارگیری همزمان برچسب اسکریپت استاندارد( / )Tag Script Standard (Loading Synch)
                </li> <br>
                <p>به طور سنتی، اسکریپت ها به طور همزمان با استفاده از تگ <code>&lt;script&gt;</code>دقرار داده شده در <code>&lt;head&gt;</code>د یا  <code>&lt;body&gt;</code>دسند
                    HTML بارگذاری می شوند.</p> <br>
                <img src="./images/5.18 photo.png" width="450"  alt=""> <br>
                <li>
                    بارگیری ناهمزمان( ویژگی ناهمگام)/(Attribute async)Loading Async
                </li> <br>
                <p>ویژگی async را می توان به تگ اسکریپت اضافه کرد تا اسکریپت به صورت ناهمزمان با توجه به بقیه صفحه
                    بارگذاری شود. این بدان معناست که اسکریپت به محض دانلود اجرا می شود، بدون اینکه منتظر بمانید تا
                    تجزیه کامل
                    شود.</p>
                     <br>
                <img src="./images/5.19 photo.png" width="450"  alt=""> <br>
                <li>
                    بارگذاری معوق (به تعویق انداختن ویژگی)/Defer 
                </li>
                <p>
                    ویژگی defer به مرورگر می گوید که اسکریپت را پس از تجزیه سند اما قبل از اجرای رویداد
                    DOMContentLoaded اجرا کند. این راهی است برای اطمینان از اینکه اسکریپت تجزیه سند را مسدود نمی کند
                    و
                    در عین حال نظم اجرا را حفظ می کند.
                </p> <br>
                <img src="./images/5.20 photo.png" width="450"  alt=""> <br>
                <li>
                    بارگذاری اسکریپت پویا - Dynamic Loding
                </li>
                <p>
                    اسکریپت ها را می توان با استفاده از جاوا اسکریپت به صورت پویا بارگذاری و در صفحه قرار داد. این
                    روش کنترل
                    دقیقی را روی زمان و نحوه بارگذاری اسکریپت ها فراهم می کند.
                </p> <br>
                <img src="./images/5.21 photo.png" width="450"  alt=""> <br>
            </ol>

        </section>
        <section id="strategy1">
            <h3>
                بهترین روش بارگذاری اسکریپت - Best Practices
            </h3> <br>
            <img src="./images/5.22 photo.png" width="450"  alt=""> <br>
            <p>
                ستراتژی "بهترین" به نیازها و محدودیت های خاص شما بستگی دارد. با این حال، ترکیبی از بهترین شیوه ها می
                تواند
                به عملکرد مطلوب منجر شود:
            </p> <br>
            <ul>
                <li>ستفاده از defer به صورت پیش فرض: برای اکثر اسکریپت ها، به ویژه آنهایی که نیاز به تعامل یا تغییر
                    DOM دارند، استفاده از defer تضمین می کند که اسکریپت ها تجزیه کننده HTML را مسدود نمی کنند و پس
                    از تجزیه سند به ترتیب صحیح اجرا می شوند.</li> <br>
                <li>nc Reserve برای اسکریپتهای مستقل: برای اسکریپتهایی که کامالً مستقل هستند - آنهایی که به
                    آمادگی DOM یا سایر اسکریپتها متکی نیستند - همگامسازی میتواند یک راه عالی برای کاهش زمان
                    بارگذاری درکشده باشد.</li> <br>
                <li>بارگذاری پویا / dynamic اسکریپت ها در صورت لزوم: برای اسکریپت هایی که باید بر اساس تعامل کاربر
                    یا سایر شرایط زمان اجرا بارگذاری شوند، بارگذاری پویا انعطاف الزم را ارائه می دهد</li> <br>
                <li>به حداقل رساندن اسکریپت های درون خطی: اگرچه گاهی اوقات برای تعامالت سریع یا تزریق داده های اولیه
                    ضروری است، استفاده از اسکریپت های درون خطی را به حداقل برسانید. برای تعامالت اساسی تر، به
                    اسکریپت های خارجی با defer پیوند دهید</li> <br>
                <li> اتخاذ این شیوهها به حفظ تعادل بین بهینه سازی عملکرد و الزامات عملکردی کمک میکند و منجر به صفحات
                    وب سریعتر و پاسخگوتر میشود</li> <br>
            </ul>
        </section>
        <section id="comment">
            <h3>
                نظرات(توضیحات)درجاواسکریپت - comments
            </h3> <br>
            <p>
                نظرات در جاوا اسکریپت حاشیه نویسی در کد هستند که توسط مفسر نادیده گرفته می شوند. آنها برای توسعه
                دهندگان
                طراحی شده اند تا یادداشت ها یا توضیحاتی را در کد بنویسند تا درک آن آسان تر شود. نظرات می توانند
                توصیف کنند که
                یک بلوک کد خاص چه می کند، چرا تصمیمات خاصی گرفته شده است، یا اینکه به طور موقت یک قطعه کد برای
                اهداف اشکال زدایی غیرفعال شود. جاوا اسکریپت از دو نوع کامنت پشتیبانی می کند: نظرات تک خطی و نظرات
                چند
                خطی (بلاک).
            </p> <br>

        </section>
        <section id="comment1">
            <h3>
                نظرات تک خطی
            </h3> <br>
            <p>
                نظرات تک خطی با // شروع می شود. همه چیزهای زیر // در همان خط به عنوان یک نظر در نظر گرفته می شود و
                در هنگام اجرای کد نادیده گرفته می شود.
            </p> <br>
            <img src="./images/5.23 photo.png" width="450"  alt=""> <br>
            <p>برای توضیحات کوتاه یا حاشیه نویسی در کد استفاده می شود. نظرات تک خطی
            </p> <br>
        </section>
        <section id="comment2">
            <h3>نظرات چند خطی</h3> <br>
            <p>
                نظرات چند خطی یا بلوکی با /* شروع و با */ ختم می شود. هر چیزی بین این دو نشانگر، صرف نظر از اینکه
                چند خط
                را در بر می گیرد، یک نظر در نظر گرفته می شود.
            </p> <br>
            <img src="./images/5.24 photo.png" width="450"  alt=""> <br>
            <div>
                <img src="./images/5.25 photo.png" width="450"  alt=""> <br>

            </div>
            <p>
                نظرات چند خطی برای توضیحات طوالنیتر، کامنت گذاشتن بلوکهای بزرگ کد در طول آزمایش یا اشکالزدایی، یا
                برای اهداف مستندسازی مفید هستند.
            </p> <br>
            <p>
                بهترین توصیه ها برای استفاده از نظرات:
            </p> <br>
            <ul>
                <li>
                    وضوح: نظراتی واضح و مختصر بنویسید که "چرا" پشت منطق پیچیده را به جای "چی" توضیح دهد. خود کد
                    باید توضیحی برای "چه" باشد.
                </li> <br>
                <li>
                    عمیر و نگهداری: نظرات را با تغییر کد به روز نگه دارید. نظرات منسوخ شده می توانند بیشتر از عدم
                    اظهار
                    نظر گمراه کننده باشند.
                </li> <br>
                <li>
                    ستفاده کم: اظهار نظر بیش از حد می تواند کد را به هم ریخته و خواندن آن را سخت تر کند. فقط در صورت
                    لزوم برای توضیح منطق پیچیده، فرضیات یا تصمیمات مهم اظهار نظر کنید.
                </li> <br>
                <li> اجتناب از نظرات واضح: در مورد چیزی که قبالً از کد مشخص است نظر ندهید. به عنوان مثال، از نظراتی
                    مانند //افزایش i توسط 1 در کنار i++ اجتناب کنید.</li> <br>
                <li>ستندسازی: از نظرات برای ارائه مستندات برای توابع، کالسها و ماژولها استفاده کنید. توضیح دهید که
                    آنها
                    چه کاری انجام می دهند، پارامترهای آنها و آنچه که آنها برمی گردند. این می تواند به ویژه در پروژه
                    های
                    بزرگ یا هنگام استفاده از ابزارهایی که اسناد را از نظرات ایجاد می کنند مفید باشد.</li> <br>
            </ul> <br>
        </section>
        <section id="comment3">
            <h3>
                غیرفعال کردن کد برای اشکال زدایی
            </h3> <br>
            <p>
                نظرات را می توان به سرعت اضافه یا حذف کرد تا بخش هایی از کد را برای اهداف آزمایش و اشکال زدایی فعال
                یا
                غیرفعال کند. این یک مورد استفاده رایج در توسعه است:
            </p> <br>
            <img src="./images/5.26 photo.png" width="450"  alt=""> <br>
            <p>
                به طور خالصه، نظرات ابزار قدرتمندی در جعبه ابزار توسعهدهنده هستند که هم به عنوان شکلی از اسناد و هم
                به عنوان
                روشی مناسب برای مدیریت کد در طول توسعه و اشکالزدایی عمل میکنند. استفاده موثر از نظرات می تواند
                خوانایی و
                قابلیت نگهداری کد جاوا اسکریپت شما را تا حد زیادی افزایش دهد.
            </p> <br> <br>

        </section>
        <section id="code">
            <h3>
                کدهای جاوا اسکریپت به چه ترتیبی اجرا می شوند؟
            </h3> <br>
            <p>
              هنگامی که یک مرورگر با کد جاوا اسکریپت مواجه می شود، اسکریپت را به صورت متوالی، از خط اول تا آخرین خط، اجرا می کند، مگر اینکه جریان توسط ساختارهای کنترلی (مانند حلقه ها و شرطی ها) یا عملیات ناهمزمان (مانند مهلت زمانی یا فچ کردن داده ها از یک سرور) تغییر یابد. این ترتیب اجرای از بالا به پایین برای نحوه عملکرد جاوا اسکریپت در مرورگر اساسی است. با این حال، توجه به این نکته مهم است که عملیات ناهمزمان بسته به مدت زمانی که هر عملیات طول می کشد، می تواند با یک ترتیب شروع شود اما با ترتیب متفاوتی کامل شود.
            </p>
           <br>
            <img src="./images/5.27 photo.png" width="450"  alt=""> <br>
            <div>
                          <img src="./images/5.28 photo.png" width="450"  alt=""> <br>

            </div>
            <p>
                در این مثال:
            </p> <br>
            <ol>
                <li>سکریپت ابتدا می نویسد "Initialized 1: Step". به سند این بالفاصله زمانی که مرورگر جاوا اسکریپت را
                    پردازش می کند، اتفاق می افتد.</li> <br>
                <li>پس، setTimeout برای شبیهسازی یک عملیات ناهمزمان، مانند فچ دادهها از یک منبع خارجی، استفاده
                    میشود. این عملیات قرار است پس از 2 ثانیه عملکرد بازگشت به تماس خود را اجرا کند، اما مرورگر قبل
                    از
                    رفتن به خطوط بعدی کد منتظر نمی ماند تا کامل شود. در عوض، کار را زمان بندی می کند و به اجرای کد
                    بعدی ادامه می دهد.</li> <br>
                <li>پس اسکریپت مینویسد »مرحله :2 اجرا در حالی که منتظر پایان کار است«. به سند اگرچه این خط بعد از
                    setTimeout میآید، اما قبل از فراخوانی setTimeout اجرا میشود زیرا مرورگر رشته اصلی در انتظار
                    setTimeout را مسدود نمیکند.</li> <br>
                <li>پس از ۲ ثانیه، تابع callback setTimeout اجرا می‌شود و عبارت «Step 3: Completed task asynchronous» را می‌نویسد. به سند این نشان می‌دهد که چگونه عملیات ناهمزمان جاوا اسکریپت را می‌توان با یک ترتیب شروع کرد اما به ترتیبی دیگر کامل شد، بر اساس مدت زمان عملیات ناهمزمان.</li>
                <br>
            </ol> <br> <br>
            <p>
                این مثال به وضوح اجرای متوالی جاوا اسکریپت و نحوه رسیدگی به تماسهای ناهمزمان را نشان میدهد و بینشی
                در
                مورد مدل اجرای جاوا اسکریپت در مرورگر ارائه میدهد.
            </p> <br>
        </section>
        <section id="code1">
            <h3>
                کد تفسیر شده در مقابل کد کامپایل شده / Interpreted versus <br>compiled code
            </h3> <br>
            <p>
                ممکن است اصطالحاتی را بشنوید که در زمینه برنامه نویسی تفسیر و کامپایل شده اند. در زبان های تفسیر
                شده، کد از
                باال به پایین اجرا می شود و نتیجه اجرای کد بالفاصله برمی گردد. قبل از اجرای مرورگر، الزم نیست کد را
                به شکل
                دیگری تبدیل کنید. کد به شکل متن مناسب برنامه نویس دریافت می شود و مستقیماً از آن پردازش می شود. <br>
                از طرف دیگر زبان های کامپایل شده قبل از اجرا توسط کامپیوتر به شکل دیگری تبدیل می شوند )کامپایل می
                شوند(. به
                عنوان مثال، C/C++ در کد ماشین کامپایل می شود که سپس توسط کامپیوتر اجرا می شود. این برنامه از یک فرمت
                باینری که از کد منبع اصلی برنامه تولید شده است اجرا می شود. <br>
                جاوا اسکریپت یک زبان برنامه نویسی تفسیر شده سبک وزن است. مرورگر وب کد جاوا اسکریپت را به شکل متن
                اصلی خود دریافت می کند و اسکریپت را از روی آن اجرا می کند. از نقطه نظر فنی، اکثر مفسران جاوا اسکریپت
                مدرن
                در واقع از تکنیکی به نام کامپایل بهنگام برای بهبود عملکرد استفاده می کنند. کد منبع جاوا اسکریپت در
                حین استفاده از
                اسکریپت به فرمت باینری سریعتر کامپایل می شود تا بتوان آن را در سریع ترین زمان ممکن اجرا کرد. با این
                حال، جاوا
                اسکریپت هنوز به عنوان یک زبان تفسیر شده در نظر گرفته می شود، زیرا کامپایل در زمان اجرا انجام می شود،
                نه
                زودتر از زمان. <br>
                هر دو نوع زبان مزایایی دارند، اما ما در حال حاضر در مورد آنها صحبت نمی کنیم. <br>
            </p>
        </section>
        <section id="code2">
            <h4>
                کد سمت سرور side-Server در مقابل کد سمت سرویس گیرنده
                <br>
                Client-side
            </h4>
            <p>
                ممکن است اصطالحات کد سمت سرور و سمت سرویس گیرنده را نیز بشنوید، به خصوص در زمینه توسعه وب. کد
                سمت کالینت کدی است که بر روی رایانه کاربر اجرا می شود - وقتی یک صفحه وب مشاهده می شود، کد سمت مشتری
                آن صفحه دانلود می شود، سپس اجرا می شود و توسط مرورگر نمایش داده می شود. در این ماژول به صراحت در
                مورد
                جاوا اسکریپت سمت کالینت صحبت می کنیم. <br>
                از طرف دیگر کد سمت سرور بر روی سرور اجرا می شود، سپس نتایج آن دانلود و در مرورگر نمایش داده می شود.
                نمونه هایی از زبان های محبوب وب سمت سرور عبارتند از NET.ASP ،Ruby ،Python ،PHP و حتی جاوا
                اسکریپت! جاوا اسکریپت همچنین می تواند به عنوان یک زبان سمت سرور استفاده شود، به عنوان مثال در محیط
                محبوب js.Node - می توانید در مورد جاوا اسکریپت سمت سرور در وب سایت های پویا - مبحث برنامه نویسی سمت
                سرور اطالعات بیشتری کسب کنید.
            </p> <br>
        </section>
        <section id="code3">
            <h4>
                کد پویا Dynamic در مقابل استاتیک Static
            </h4> <br>
            <p>
              کلمه پویا برای توصیف هر دو زبان جاوا اسکریپت سمت سرویس گیرنده و زبان های سمت سرور استفاده می شود - به توانایی به روز رسانی صفحه وب / برنامه برای نشان دادن چیزهای مختلف در شرایط مختلف و تولید محتوای جدید در صورت لزوم اشاره دارد. کد سمت سرور به صورت پویا محتوای جدیدی را در سرور تولید می کند، به عنوان مثال. کشیدن داده ها از پایگاه داده، در حالی که جاوا اسکریپت سمت کلاینت به صورت پویا محتوای جدیدی را در داخل مرورگر روی کلاینت تولید می کند، به عنوان مثال. ایجاد یک جدول HTML جدید، پر کردن آن با داده های درخواست شده از سرور، سپس نمایش جدول در یک صفحه وب که به کاربر نشان داده شده است. معنی در دو زمینه کمی متفاوت است، اما مرتبط است، و هر دو رویکرد (سمت سرور و سمت مشتری) معمولاً با هم کار می کنند. یک صفحه وب بدون محتوای به روز رسانی پویا به عنوان ثابت شناخته می شود - فقط یک محتوا را همیشه نشان می دهد.
            </p> <br>
        </section>
        <section id="API">
            <h4>
                چرا API ها در جاوا اسکریپت مهم هستند؟
            </h4> <br>
            <img src="./images/5.29 photo.png" width="450"  alt=""> <br>
            <p>
                برای توسعه دهندگان جاوا اسکریپت، API ها اهمیت ویژه ای دارند. آنها به برنامه های کاربردی وب اجازه می
                دهند تا
                به صورت پویا داده ها را فچ و دستکاری کنند، با مرورگر تعامل داشته باشند و کارهای پیچیده را بدون
                بارگذاری مجدد
                صفحه انجام دهند. ماهیت ناهمزمان جاوا اسکریپت، همراه با APIها، امکان ایجاد برنامه های کاربردی وب غنی،
                تعاملی
                و بسیار پاسخگو را فراهم می کند. با استفاده از APIها، توسعهدهندگان میتوانند قابلیتهایی مانند نقشهها،
                سیستمهای
                پرداخت و خدمات رسانههای اجتماعی را
                مستقیما در برنامههای خود ادغام کنند و تجربه کاربر را افزایش دهند. ً<br>
                عالوه بر این، با ظهور js.Node، جاوا اسکریپت فراتر از مرورگر به برنامه نویسی سمت سرور گسترش یافته
                است.
                این امر اهمیت API ها را در جاوا اسکریپت افزایش داده است، زیرا توسعه دهندگان اکنون می توانند برنامه
                های
                کاربردی تمام پشته بسازند که با سرویس ها و پایگاه های داده مختلف ارتباط برقرار می کنند و همگی با
                استفاده از یک
                زبان برنامه نویسی واحد. <br>
                جاوا اسکریپت، زبانی است که در درجه اول برای ایجاد صفحات وب تعاملی استفاده میشود، از APIها بسیار سود
                میبرد. در اینجا دلیل آن است:
            </p> <br>
            <ol>
                <li> عملکرد پیشرفته: APIها قابلیتهای جاوا اسکریپت را گسترش میدهند و به آن اجازه میدهند بیشتر از آنچه
                    میتواند به تنهایی انجام دهد. به عنوان مثال، جاوا اسکریپت می تواند محتوای صفحه وب را از طریق API
                    Model Object Document یا DOM دستکاری کند، به ورودی های کاربر پاسخ دهد و حتی چند رسانه
                    ای را کنترل کند.</li> <br>
                <li>کارایی: توسعهدهندگان میتوانند بهجای کدنویسی عملیات پیچیده از ابتدا از APIها برای پیادهسازی سریع
                    عملکرد، صرفهجویی در زمان و کاهش خطاها استفاده کنند. این اجازه می دهد تا تمرکز بیشتری بر ایجاد یک
                    تجربه کاربری بهتر به جای پرداختن به جزئیات دقیق پیاده سازی شود.</li> <br>
                <li>یکپارچهسازی: APIها به برنامههای جاوا اسکریپت اجازه میدهند با سرویسهای خارجی و منابع داده به طور
                    یکپارچه تعامل داشته باشند. این برای ساخت برنامههای کاربردی وب مدرن که بر دادههای بالدرنگ تکیه
                    میکنند، مانند فید رسانههای اجتماعی، نقشهها یا دادههای مالی بسیار مهم است.</li> <br>
            </ol> <br>
        </section>
        <section id="API1">
            <h4>
                دسته بندی API ها در جاوا اسکریپت
            </h4> <br>
            <p>
                API های جاوا اسکریپت به طور کلی به دو دسته تقسیم می شوند: API های مرورگر و API های شخص ثالث. <br>
                API های مرورگر در مرورگر وب شما تعبیه شده اند و دسترسی به عملکردهای خاص مرورگر را فراهم می کنند.
                مثالها
                عبارتند از:
            </p> <br>
            <ul>
                <li>ML :API DOM و CSS را دستکاری می کند و محتوا و سبک را به صورت پویا تغییر می دهد.</li> <br>
                <li>API Geolocation: موقعیت جغرافیایی را بازیابی می کند و خدمات مبتنی بر مکان را فعال می کند.</li>
                <br>
                <li>Vanvas و API WebGL: گرافیک و انیمیشن ایجاد کنید و جذابیت بصری برنامه های وب را افزایش دهید.</li>
                <br>
                <li>API های صوتی و تصویری: مدیریت چند رسانه ای، امکان ادغام صدا و تصویر در صفحات وب را فراهم می
                    کند.
                </li> <br>
            </ul> <br>
            <p>API های شخص ثالث توسط سرویس های خارجی ارائه می شوند و باید در برنامه های شما ادغام شوند. مثالها
                عبارتند
                از:</p> <br>
            <ul>
                <li>API Twitter: توییت ها را نمایش می دهد یا با سرویس های توییتر تعامل دارد.</li> <br>
                <li>API Maps Google: نقشه ها و خدمات مکان را در صفحات وب شما جاسازی می کند.</li> <br>
            </ul> <br>
            <p>این APIها به میزان قابل توجهی آنچه را که می توانید با جاوا اسکریپت به دست آورید افزایش می دهند و
                دنیایی از
                امکانات را برای برنامه های کاربردی وب تعاملی و پویا باز می کنند.</p> <br>
        </section>
        <section id="API2">
            <h4>
                استفاده عملی از API ها در جاوا اسکریپت
            </h4> <br>
            <p>
                یک مورد استفاده ساده را در نظر بگیرید که در آن می خواهید آب و هوای فعلی را در وب سایت خود نمایش
                دهید.
                بهجای جمعآوری دادههای آب و هوا، میتوانید از API یک سرویس آب و هوا برای فچ اطالعات آبوهوای فعلی
                استفاده
                کنید. با چند خط جاوا اسکریپت، می توانید درخواستی را به API ارسال کنید، داده های آب و هوا را دریافت
                کنید و به
                صورت پویا صفحه وب خود را با این اطالعات به روز کنید.
            </p> <br>
            <img src="./images/5.30 photo.png" width="450"  alt=""> <br>
            <p>
                این قطعه نشان میدهد که چگونه APIها میتوانند کد جاوا اسکریپت شما را برای جمعآوری دادهها از منابع
                خارجی
                تقویت کنند و برنامههای وب شما را با حداقل تالش غنی کنند. <br>
                همانطور که عمیقتر در جاوا اسکریپت و اکوسیستم آن کاوش میکنید، با APIهای زیادی مواجه میشوید که
                میتوانند
                برنامههای کاربردی شما را به روشهای متعددی ارتقا دهند. در حالی که کشف این قابلیت ها هیجان انگیز است،
                به یاد
                داشته باشید که تسلط بر اصول جاوا اسکریپت بسیار مهم است. با یک پایه محکم، می توانید به طور موثر از
                API ها
                برای ساخت برنامه های کاربردی وب قوی، تعاملی و پویا استفاده کنید. <br> <br>
                APIها در توسعه وب مدرن ضروری هستند، و به عنوان بلوک های سازنده ای عمل می کنند که به توسعه دهندگان
                اجازه میدهد روی شانه های غول ها بایستند. این APIها خواه فچ کردن داده های آب و هوای زنده، ارسال توییت
                ها یا
                ادغام یک دروازه پرداخت باشد، به توسعه دهندگان این امکان را می دهد که برنامه های پیچیده تر و غنی تر
                را به طور
                کارآمد بسازند. همانطور که به کاوش جاوا اسکریپت ادامه می دهید، تعمیق درک شما از انواع مختلف API ها و
                معماری
                آنها در استفاده از پتانسیل کامل این زبان همه کاره بسیار مهم خواهد بود.
            </p> <br>
        </section>
        <section id="karbord">
            <h4>
                جاوا اسکریپت چه کاری می تواند انجام دهد؟
            </h4> <br>
            <img src="./images/5.31 photo.png" width="450"  alt=""> <br>
            <p>
              بیایید به طور خلاصه داستان اتفاقی که هنگام بارگذاری یک صفحه وب در یک مرورگر رخ می دهد را مرور کنیم (برای اولین بار در مقاله نحوه عملکرد CSS ما صحبت شد). هنگامی که یک صفحه وب را در مرورگر خود بارگذاری می کنید، کد خود (HTML، CSS و جاوا اسکریپت) را در یک محیط اجرایی (برگه مرورگر) اجرا می کنید. این مانند کارخانه ای است که مواد خام (کد) را می گیرد و یک محصول (صفحه وب) را تولید می کند. 

کدهای HTML، CSS و جاوا اسکریپت برای ایجاد محتوا در برگه مرورگر هنگام بارگذاری صفحه با هم ترکیب می شوند. یک استفاده بسیار رایج از جاوا اسکریپت، تغییر پویا HTML و CSS برای به روز رسانی یک رابط کاربری، از طریق Document Object Model API است (همانطور که در بالا ذکر شد). توجه داشته باشید که کد موجود در اسناد وب شما معمولاً به ترتیبی که در صفحه ظاهر می شود بارگیری و اجرا می شود. اگر جاوا اسکریپت قبل از HTML و CSS که قرار است اصلاح شود، بارگیری و اجرا شود، ممکن است خطاهایی رخ دهد. در ادامه مقاله، در بخش استراتژی‌های بارگذاری اسکریپت، راه‌هایی برای رفع این مشکل خواهید آموخت.

جاوا اسکریپت صفحه وب شما را با معرفی تعاملی، به روز رسانی محتوای پویا و تجربیات کاربری پیشرفته که تنها با HTML و CSS قابل دستیابی نیستند، غنی می کند. هنگامی که جاوا اسکریپت در صفحه شما اجرا می شود، در اینجا نگاهی اجمالی به قابلیت ها و اقدامات آن داریم:
            </p> <br>
            <ul>
                <li>ستکاری DOM: جاوا اسکریپت به صورت پویا با Model Object Document در تعامل است و به شما
                    امکان می دهد محتوا، ساختار و سبک ها را تغییر دهید. به عنوان مثال، می تواند عناصر و ویژگی ها را
                    در
                    پاسخ به اقدامات کاربر اضافه، حذف یا تغییر دهد.</li> <br>
                <li> مدیریت رویدادهای کاربر: به رویدادهای کاربر مانند کلیک، حرکت ماوس، فشار دادن کلید یا لمس گوش می
                    دهد و به آنها پاسخ می دهد. این کار جاوا اسکریپت را قادر می سازد تا کد را در پاسخ به تعامالت
                    کاربر اجرا
                    کند و صفحه شما را تعاملی تر کند.</li> <br>
                <li>اعتبار سنجی فرم ها: جاوا اسکریپت اعتبار سنجی فرم سمت سرویس گیرنده را قبل از ارسال داده ها به
                    سرور
                    انجام می دهد. این بازخورد فوری میتواند تجربه کاربر را با تشخیص خطاها و درخواست اصالحات در زمانی
                    که کاربر فرم را پر میکند، افزایش دهد.
                </li> <br>
                <li>متحرک سازی عناصر: می تواند عناصر موجود در صفحه را متحرک کند و جلوه هایی مانند اسالیدها، محو
                    شدن ها یا حرکات ایجاد کند. این انیمیشن ها می توانند توجه کاربران را هدایت کنند یا جذابیت بصری
                    سایت شما
                    را افزایش دهند.</li> <br>
                <li>ایجاد درخواست های ناهمزمان: با AJAX (جاوا اسکریپت ناهمزمان و XML) و API هایی مانند Fetch API، جاوا اسکریپت می تواند بدون بارگیری مجدد صفحه، داده ها را به صورت ناهمزمان از یک سرور درخواست کند. این در بارگذاری محتوای جدید به صورت پویا، مانند به روز رسانی فید خبری یا بارگذاری تصاویر جدید در یک گالری استفاده می شود.</li> <br>
                <li>ذخیره سازی داده ها به صورت محلی: جاوا اسکریپت می تواند از Web Storage API (localStorage و sessionStorage) برای ذخیره داده ها در رایانه مشتری استفاده کند. این می تواند تجربه کاربر را با به خاطر سپردن تنظیمات برگزیده کاربر یا ذخیره پیشرفت بازی بدون نیاز به برقراری ارتباط با سرور افزایش دهد.</li> <br>
                <li>ایجاد برنامه های کاربردی یک صفحه (SPA): این ستون فقرات SPA است که اکثر تعاملات در یک صفحه وب اتفاق می افتد. جاوا اسکریپت فچ  داده‌ها، مسیریابی و به‌روزرسانی‌های رابط کاربری را مدیریت می‌کند و تجربه‌ای روان‌تر و شبیه به برنامه را در مرورگر ارائه می‌دهد.</li> <br>
            </ul> <br>
            <p>
                قابلیت های جاوا اسکریپت بسیار زیاد است و می تواند:
            </p> <br>
            <ul>
                <li>از طریق فرم ها و دیالوگ ها با کاربر تعامل داشته باشید.</li> <br>
                <li>محتوای صفحه وب و سبک را به صورت پویا دستکاری کنید.</li> <br>
                <li> ورودی کاربر را اعتبارسنجی کنید تا مطمئن شوید که معیارهای خاصی را قبل از ارسال به سرور رعایت می
                    کند</li> <br>
                <li>رویدادهایی مانند کلیکها، ارسالهای فرم و بارگیری صفحه را مدیریت کنید.</li> <br>
                <li>انجام عملیات پیچیده با آرایه ها، اشیاء و توابع.</li> <br>
                <li> با سرورهای خارجی از طریق APIها برای فچ ، نمایش یا ذخیره داده ها بدون نیاز به بارگیری مجدد صفحه
                    ارتباط برقرار کنید.</li> <br>
                <li>بازی های تعاملی را مستقیماً در مرورگر ایجاد کنید.</li> <br>
                <li> ساخت برنامه های کاربردی وب با رابط های کاربری پیچیده.</li> <br>

            </ul> <br>
            <p>
                این مقدمه
                صرفا سطح آنچه را که با جاوا اسکریپت ممکن است خراش می دهد. همانطور که پیشرفت می کنید، با ً
                متغیرها، توابع، حلقه ها و موارد دیگر آشنا خواهید شد و به تدریج به سمت ایجاد تجربیات وب غنی و تعاملی
                خواهید
                رفت. به یاد داشته باشید، کلید تسلط بر جاوا اسکریپت تمرین و آزمایش است. بنابراین، برای غواصی عمیقتر
                در
                فصلهای بعدی آماده شوید و بیایید صفحات وب خود را زنده کنیم!
            </p> <br>

        </section>
    </section>



    <!--fasle6 tasalot-->
  <section id="fasle6"><h2>فصل ششم تسلط بر مبانی جاوا اسکریپت</h2>
    <p>
        به فصل بعدی سفر جاوا اسکریپت خود خوش آمدید! همانطور که شروع به آشنایی
      با زبان و قابلیت های آن برای زنده کردن صفحات وب کرده اید،<br />
      زمان آن رسیده است که عمیق تر در مفاهیم اصلی که ستون فقرات برنامه نویسی
      جاوا اسکریپت را تشکیل می دهند، کاوش کنید. <br />این فصل به گونه ای
      طراحی شده است که راهنمای شما از طریق عناصر اساسی جاوا اسکریپت، از جمله
      متغیرها، توابع،<br />
      حلقه ها و متدها و غیره باشد. درک این عناصر برای نوشتن کد کارآمد، موثر
      و تمیز بسیار مهم است.
    </p>
    <ul>
      <li>
        Variables: متغیرها واحدهای اساسی ذخیره سازی در برنامه نویسی هستند.
        در جاوا اسکریپت، آنها به شما اجازه می دهند داده ها را <br />در سراسر
        کد خود ذخیره و دستکاری کنید. ما نحوه اعلان متغیرها، انواع مختلف داده
        هایی که می توانید ذخیره کنید و اهمیت تایپ پویا <br />جاوا اسکریپت را
        بررسی خواهیم کرد. درک متغیرها اولین گام برای ایجاد تجربه های وب
        تعاملی و پویا است.
      </li>
      <li>
        Functions: توابع بلوک هایی از کد هستند که برای انجام وظایف خاص طراحی
        شده اند. آنها برای جاوا اسکریپت اساسی هستند و به <br />شما امکان می
        دهند کدهای قابل استفاده مجدد بنویسید، اسکریپت های خود را در بخش های
        قابل مدیریت سازماندهی کنید و کد را در پاسخ به رویدادها اجرا کنید.
        <br />ما نحوه تعریف توابع، ارسال داده به آنها، برگرداندن مقادیر و
        استفاده از نحو جدیدتر مانند توابع پیکان را برای کد مختصرتر پوشش
        خواهیم داد.
      </li>
      <li>
        : حلقه ها راهی برای تکرار اقدامات بدون چندین بار نوشتن یک خط کد
        ارائه می دهند. چه در حال تکرار روی آرایه ها، پردازش ورودی کاربر،<br />
        یا تکرار اقدامات تا زمانی که یک شرط برآورده شود، حلقه ها کد شما را
        کارآمدتر و وظایف شما را قابل مدیریت تر می کنند. <br />
        ما در مورد انواع حلقه های موجود در جاوا اسکریپت بحث خواهیم کرد، از
        جمله حلقه های for، while، و do...while و زمان استفاده از هر کدام.
      </li>
      <li>
        Methods: متدها توابعی هستند که با یک شی مرتبط هستند. جاوا اسکریپت،
        <br />به عنوان یک زبان شی گرا، مجموعه ای از روش های داخلی را برای
        رشته ها، آرایه ها و سایر اشیاء ارائه می دهد که به شما امکان می دهد
        ساختارهای داده را به طور موثر<br />
        دستکاری کنید. ما نحوه استفاده از این روش ها و نحوه تعریف روش های خود
        را برای گسترش عملکرد اشیاء خود بررسی خواهیم کرد.
      </li>
      <li>
        Control Structures: ساختارهای کنترلی، مانند دستورات if و موارد
        سوئیچ، به شما این امکان را می دهند که در کد خود بر اساس <br />شرایط
        خاصی تصمیم گیری کنید. این ساختارها جریان اجرا را در برنامه شما هدایت
        می کنند و رفتارها و منطق پیچیده را قادر می سازند. <br />ما به نحوه
        استفاده از این ساختارها برای هدایت مسیرهای اجرای برنامه خود خواهیم
        پرداخت.
        <p>
          در حالی که متغیرها، توابع، حلقه‌ها و روش‌ها هسته اصلی را تشکیل
          می‌دهند، جاوا اسکریپت یک زبان غنی و در حال تکامل است که چیزهای
          بیشتری برای ارائه دارد. <br />از رسیدگی به خطاها و رویدادها گرفته
          تا موضوعات پیشرفته‌تر مانند بسته شدن، برنامه‌نویسی ناهمزمان، و
          Document Object Model (DOM)، چشم‌انداز وسیعی برای <br />کاوش وجود
          دارد. این فصل زمینه را برای این موضوعات پیشرفته و موارد دیگر فراهم
          خواهد کرد.
          <p>
            ر پایان این فصل، شما درک کاملی از مفاهیم اساسی خواهید داشت که به شما قدرت می‌دهد تا با مشکلات پیچیده‌تر مقابله کنید
              و برنامه‌های کاربردی<br/> پیچیده‌تری بسازید. چه بخواهید یک توسعه‌دهنده فرانت‌اند باشید، چه روی برنامه‌های سمت سرور با Node.js کار کنید یا صرفاً به دنبال افزودن تعامل<br/> به صفحات وب خود باشید، این مفاهیم سنگ‌های پله شما هستند.
              بیایید با هم این سفر را آغاز کنیم 
              و ایده های شما را با قدرت جاوا اسکریپت به واقعیت تبدیل کنیم.
          </p>
        </p>
      </li>
    </ul>
<section id="declare">
    <h3>
Variables Declaration / اعلان‌های متغیرها
</h3>
<p>
در جاوا اسکریپت،
متغیرها مفاهیم اساسی هستند که به شما اجازه می دهند داده ها را در برنامه های خود ذخیره و دستکاری کنید.
جاوا اسکریپت راه های مختلفی<br/> برای اعلام متغیرها ارائه می دهد که هر کدام مجموعه ای از قوانین و موارد
استفاده خاص خود را دارند. در این میان، var، let و const کلیدواژه‌هایی هستند <br/>که برای اعلان‌های
  متغیر استفاده می‌شوند، با let و const در (ES6 (ECMAScript 2015 برای رفع برخی از کاستی‌های var معرفی شده‌اند. در اینجا، ما بر let و const تمرکز خواهیم کرد.
</p>
<ol>
<li>

var: قدیمی ترین کلمه کلیدی، با عملکرد یا دامنه جهانی. var مدتهاست که روش استاندارد برای
<br/> اعلام متغیرها در جاوا اسکریپت بوده است. 
متغیرهای  اعلام شده با var، زمانی که در داخل یک تابع اعلان می شوند،
دامنه تابعی دارند یا زمانی که خارج <br/>از تابع اعلام می شوند، دامنه جهانی دارند. 
آنها می توانند قبل از اعلام آنها از طریق مفهوم بالا بردن قابل دسترسی باشند.
</li>
<li>
let: کلمه کلیدی let به شما امکان می دهد متغیرهای محدوده بلوک را اعلام کنید، به این معنی که
متغیر به بلوکی (که با {} مشخص می شود) <br/>محدود می شود که در آن تعریف شده است. 
این یک پیشرفت قابل‌توجه نسبت به var است که متغیرهای آن دارای محدوده عملکرد هستند و می‌تواند 
منجر به <br/>رفتار غیرمنتظره‌ای 
به دلیل بالابردن شود (که در آن اعلان‌های متغیر به بالای محدوده حاوی خود منتقل می‌شوند). 
</li>
<li>
const: کلمه کلیدی const برای اعلام متغیرهایی استفاده 
می شود که قرار است در طول چرخه عمر خود ثابت باشند، به این معنی که 
ارزش آنها پس از مقداردهی<br/> اولیه قابل تخصیص مجدد نیست. مانند let، const
نیز محدوده‌بندی بلوکی را ارائه می‌کند.
</li>
</ol>
</section>
<section id="declare1"> <h3>تفاوت های کلیدی بین let و const
</h3>
<p>
تغییرپذیری: متغیرهایی که با let اعلان می‌شوند می‌توانند مقادیرشان تغییر کند
(آنها قابل تغییر هستند). در مقابل، متغیرهای اعلام شده با const <br/>
از نظر مرجع تغییرناپذیر باشند
(شما نمی توانید آنها 
را مجدداً اختصاص دهید).
با این حال، اگر یک متغیر const یک شی یا آرایه را در خود
جای دهد، محتوای شی یا آرایه <br/>همچنان قابل تغییر است.
</p>
<h5>
موارد استفاده:
</h5>
<ul>
<li>
از let برای متغیرهایی استفاده کنید که انتظار می‌رود
  در طول زمان تغییر کنند، 
  مانند شمارنده‌هایی در یک حلقه، یا مقادیری که به صورت شرطی اختصاص داده شده‌اند.
</li>
<li>
از const برای متغیرهایی که نباید پس از تخصیص 
اولیه تغییر کنند استفاده کنید. 
این شامل ماژول های وارد شده، پیکربندی ها یا هر مقدار ثابتی است که در کد شما استفاده می شود.
</li>
</ul>
</section>
<section id="declare2">
<h3>بهترین  روش ها / Best Practices</h3>
    <ul>
      <li>
        ترجیحا const: از const به طور پیش فرض برای اعلام متغیرها استفاده کنید. 
        این کار با نشان دادن عدم تخصیص مجدد این متغیرها،
          خواندن کد شما را آسان‌تر می‌کند و بار شناختی و احتمال بروز باگ را کاهش می‌دهد.
      </li>
      <li>
        استفاده از let فقط در صورت لزوم: فقط از let برای متغیرهایی استفاده کنید که 
        می دانید تغییر خواهند کرد، مانند شمارنده در حلقه ها یا مقادیری که به یک شرط بستگی دارند.
      </li>
    </ul>
    <section id="var"><h3>Data Types </h3>
      </section>
      
      
      <section id="var1">
      <h4>شماره ها / Numbers </h4>
    <p>
      اعداد می توانند اعداد صحیح یا ممیز شناور (اعشاری) باشند.</p>
          <img src="./images/6.1 photo.png" width="450" alt="photo1">
          </section>
          <section id="var2" >
          <h4> رشته ها / Strings </h4>
          <p>
          رشته ها دنباله ای از کاراکترها 
          هستند که
            برای متن استفاده می شوند. آنها را می توان در گیومه های تکی (')، گیومه های دوتایی 
          (")، یا بک تیک ها (') برای حروف اللفظی الگو قرار داد.
          </p>
          <img src="./images/6.2 photo.PNG" width="450" alt=" photo2 ">
                </section>

<section id="var3">
          <h4>
          بولین ها / Booleans
          </h4>
          <p>
          بولی ها مقادیر true/false هستند – آنها می توانند دو مقدار true یا false داشته باشند. 
          اینها عموماً برای آزمایش یک شرط استفاده می‌شوند و پس از آن کد مطابق مناسب اجرا می‌شود.
          </p>
          <img src="./images/6.3 photo.PNG" width="450" alt="photo3">
          </section>
          <section id="var4">
          <h4>
          آرایه ها / Arrays
          </h4>
          <p>
          آرایه یک شی منفرد 
          است که حاوی مقادیر
            متعددی است که در کروشه های مربع محصور شده و با کاما از هم جدا شده اند.
            آرایه ها برای ذخیره <br/>چندین مقدار در یک متغیر استفاده می شوند.
            آنها دارای شاخص صفر هستند، به این معنی که شاخص عنصر اول 0 است. 
          </p>
          <img src="./images/6.4 photo.PNG" width="450" alt="photo4">
          <p>
          هنگامی که این آرایه ها تعریف شدند، می توانید
            به هر مقدار با توجه به موقعیت آنها در آرایه دسترسی داشته باشید.  </p>
            <img src="./images/6.5 photo.PNG" width="450" alt="photo5">
            </section>
            <section id="var5">
            <h4>
            اشیاء / Objects
            </h4>
            <p>
            در برنامه نویسی، 
            یک شی ساختاری از کد است که یک شی واقعی را مدل می کند. شما می توانید یک شی ساده داشته
              باشید که نشان دهنده یک جعبه باشد و حاوی <br/>اطلاعاتی در مورد عرض، طول و ارتفاع آن باشد، 
            یا می توانید یک شی داشته باشید که نشان دهنده یک شخص باشد و حاوی <br/>اطلاعاتی در مورد 
            نام، قد، وزن، زبان و نحوه صحبت آنها باشد. برای سلام کردن به آنها و موارد دیگر.
            <br/>اشیا مجموعه‌ای 
            از ویژگی‌ها هستند که هر ویژگی یک
            جفت کلید-مقدار است. کلیدها همیشه رشته هستند و مقادیر می توانند هر نوع داده ای باشند.
            </p>
            <img src="./images/6.6 photo .PNG" width="450" alt="photo">
            <p>
            جاوا اسکریپت انواع دیگری مانند null، undefined، Symbol و اشیاء
              پیچیده تری مانند Function، Date، RegExp و غیره دارد. </p>
              <ul>
              <li>
                null: عدم وجود عمدی هر مقدار شی را نشان می دهد. 
              </li>
              <li>
                undefined: نشان می دهد که به یک متغیر مقداری اختصاص داده نشده است. 
              </li>
            </ul>
            <img src="./images/6.7 photo .PNG" width="450" alt="photo7">
            </section>
            <section id="var6">
            <h3>تایپ پویا / Dynamic Type</h3>
            <p>جاوا اسکریپت یک زبان با تایپ آزاد 
              یا پویا است، به این معنی که نیازی نیست نوع متغیر
                را از قبل اعلام کنید. نوع یک متغیر می تواند با ادامه اجرا تغییر کند.</p>
                <img src="./images/6.8 photo.PNG"  width="450" alt="photo8">
                <p>
                درک متغیرها و انواع داده ها در برنامه نویسی 
                جاوا اسکریپت اساسی است، زیرا آنها بلوک های 
                سازنده برای ذخیره و دستکاری داده ها هستند. <br/>همانطور که پیشرفت می کنید، خواهید دید 
                که چگونه می توان از این نوع داده های ساده در توابع، حلقه ها و ساختارهای 
                دیگر برای ایجاد برنامه های کاربردی پیچیده و کاربردی استفاده کرد. 
                </p>
                </section>
                </section>
                
    <section id="hesab">
      <h3>اعداد و عملگرهای حسابی</h3></section>
    <p>
      جاوا اسکریپت از طیف گسترده ای 
      از عملیات ریاضی پشتیبانی می کند و
        آن را به ابزاری قدرتمند برای محاسبات عددی، از محاسبات پایه تا 
      محاسبات ریاضی پیچیده تر<br/> تبدیل می کند.
        درک نحوه کار با اعداد و
        عملگرها برای دستکاری داده ها
          و پیاده سازی منطق در برنامه های جاوا اسکریپت شما بسیار مهم است.
    </p>
    <section id="hesab1">
    <h3>
      اعداد صحیح در مقابل اعداد ممیز شناور
    </h3>
    <p>
      در جاوا اسکریپت، 
      اعداد را می توان با 
      <br/> اعشار یا بدون اعشار نوشت. برخلاف برخی از زبان های برنامه نویسی دیگر، جاوا اسکریپت
        بین انواع اعداد (مانند اعداد صحیح در مقابل اعداد ممیز شناور) <br/>تفاوت قائل نمی شود.
        همه اعداد در جاوا اسکریپت به صورت مقادیر ممیز شناور نمایش داده می شوند.
    </p>
    <img src="./images/6.9 photo.PNG" width="450" alt="photo9">
    </section>
    <section id="hesab2">
    <h3>
      عملگرهای حسابی 
    </h3>
    <p>جاوا اسکریپت شامل چندین عملگر برای انجام عملیات حسابی اساسی است:
</p>
<ul>
<li>
+ جمع: دو عدد را اضافه می کند.
</li>
<li>
- تفریق: عدد دوم را از عدد اول کم می کند.
</li>
<li>
* ضرب: دو عدد را ضرب می کند.
</li>
<li>
/ تقسیم: عدد اول را بر عدد دوم تقسیم می کند.
</li>
<li>
% مدول (باقی مانده): باقیمانده تقسیم عدد اول بر عدد دوم را برمی گرداند.
</li>
<li>
++ افزایش: یک را به عملوند خود اضافه می کند.
</li>
<li>
-- کاهش: یک را از عملوند آن کم می کند.
</li>
</ul>
<img src="./images/6.10 photo.PNG" width="450" width="450"alt="photo10">
<div>
  <img src="./images/6.11 photo.PNG" width="450" alt="photo11">
</div>

</section>
<section id="hesab3">
<h4>اپراتورهای واگذاری
</h4>
<p>عملگرهای انتساب برای تخصیص مقادیر به متغیرها استفاده می شوند. عملگر تخصیص پایه = است، اما عملگرهای انتساب مرکب نیز وجود دارند که یک عملیات حسابی را با انتساب ترکیب می کنند.</p>
<ul>
<li>= مقداری را به یک متغیر اختصاص می دهد.
</li>
<li>+= اضافه می کند و اختصاص می دهد.
</li>
<li>-= تفریق و اختصاص می دهد.
</li>
<li>*= ضرب و اختصاص می دهد.
</li>
<li>/= تقسیم و اختصاص می دهد.
</li>
<li>
  %= مدول را اعمال می کند و تخصیص می دهد.

</li>
</ul>
<img src="/images/6.12.1 photo.png" width="450" alt="">
</section>
    <section id="hesab4">
      <h3>مقایسه و عملگرهای منطقی</h3>
      <p>
        عملگرهای مقایسه برای مقایسه دو مقدار استفاده می شوند،
        در حالی که عملگرهای منطقی برای تعیین منطق بین متغیرها یا مقادیر استفاده می شوند. 
      </p>
      <ul>
        <li>
          عملگرهای مقایسه: == (برابر)، != (مساوی نیست)، > (بزرگتر از)، 
          < (کمتر از)، >= (بزرگتر یا مساوی)، <= (کمتر یا مساوی)، = == (به طور دقیق برابر)،
            !== (به شدت برابر نیست).
        </li>
        <li>
          عملگرهای منطقی: && (منطقی AND)، || (یا منطقی)، ! (منطقی نه).
        </li>
      </ul>
    </section>
    <section id="hesab5">
      <h3>مقادیر عددی ویژه</h3>
  
    <h4>
      جاوا اسکریپت چندین مقدار عددی ویژه دارد:
    </h4>
    <ul>
      <li>
      بی نهایت: بیانگر بی نهایت ریاضی است. هر عدد مثبت تقسیم بر صفر
      </li>
      <li>
        -بی نهایت: نشان دهنده بی نهایت منفی است. هر عدد منفی تقسیم بر صفر 
      </li>
      <li>
        NaN: مخفف "Not-a-Number" است. نتیجه یک عملیات ریاضی نامعتبر یا تعریف نشده است.
      </li>
    </ul>
    <img src="./images/6.12 photo.PNG" width="450" alt="photo12">
    <p>
      اعداد و عملگرها پایه و اساس عملیات ریاضی در جاوا اسکریپت را تشکیل می دهند. با درک نحوه استفاده موثر از اینها، می توانید طیف گسترده ای 
      از <br/>محاسبات ریاضی را برای حل مسائل، دستکاری داده ها و
        پیاده سازی منطق پیچیده در برنامه های کاربردی وب خود انجام دهید. چه در حال محاسبه <br/>امتیازات در یک بازی، پردازش تراکنش های مالی، یا به سادگی
        شمارش کلیک ها باشید، تسلط بر اعداد و اپراتورها برای هر توسعه دهنده جاوا اسکریپت ضروری است.
      </p>
  </section>


    <section id="modir"><h3>
      مدیریت متن در جاوا اسکریپت
    </h3>
    <p>
      مدیریت متن در جاوا اسکریپت در درجه اول از طریق رشته ها انجام می شود که دنباله ای از کاراکترها هستند که برای نمایش متن استفاده می شوند. <br/>رشته‌ها در 
      جاوا اسکریپت را می‌توان با استفاده از نقل‌قول‌های تکی (')، 
      گیومه‌های دوتایی (»)، یا بک‌تیک‌ها (`) برای قالب‌های تحت اللفظی قالب ایجاد کرد. <br/>درک نحوه کار با رشته‌ها تقریباً برای هر برنامه جاوا اسکریپت،
      از نمایش پیام‌ها به کاربران، تا تجزیه داده های دریافتی از وب سرور 
    </p>
    </section>
    
    <section id="modir1"><h3>
      ایجاد رشته ها
    </h3>
    <p>
      شما می توانید رشته ها را با قرار دادن متن در داخل نقل قول ایجاد کنید. در اینجا چگونه است:
    </p>
    <img src="./images/6.13 photo.PNG" width="450" alt="photo13">
    <p>هر دو روش به یک اندازه معتبر هستند. انتخاب بین
      نقل قول های تکی و دوگانه اغلب به ترجیحات سبک شخصی یا پروژه بستگی دارد.</p>
      </section>

    <section id="modir2"><h3>
      الفاظ الگو - Template Literals
    </h3>
    <p>
      حروف الفبای 
      الگو با بک تیک (`) نشان داده می شوند، نه گیومه های تک سنتی (" ") یا
        دو نقل قول (" "). در این بکتیک‌ها، می‌توانید<br/> متن معمولی و عبارات تعبیه‌شده
        را بنویسید که در پرانتزهای فرفری محصور شده و قبل از آن علامت دلار (${}) وجود دارد.
    </p>
    <img src="./images/6.14 photo.PNG" width="450" alt="photo14">
    <div>   
       <img src="./images/6.15 photo.PNG" width="450" alt="photo15">
</div>
    <p>
      حروف الفبای الگو با بکتیک (`) تعریف می شوند
        و می توانند چندین خط را در بر گیرند. یکی از مزایای بزرگ قالب 
        literals پشتیبانی از رشته های چند خطی بدون نیاز به درج صریح 
      خطوط شکسته است:
    </p>
    <img src="./images/6.16 photo.PNG" width="450" alt="photo16">
    </section>


    <section id="modir3"><h3>
      الفبای الگوی تو در تو
    </h3>
    <p>
      الفاظ قالب همچنین می تواند تودرتو باشد، که می تواند هنگام ایجاد رشته های پیچیده مفید باشد:
    </p>
    <img src="./images/6.17 photo.PNG" width="450" alt="photo17">
    </section>

    <section id="modir4"><h3>
      برچسب‌گذاری شده با واژه‌های قالب / Tagged Template Literals
    </h3>
    <p>
      یک تابع گسترده از لفظ های قالب، به اصطلاح "الگوهای برچسب گذاری شده" هستند. 
      یک تابع برای پردازش خروجی 
      الگو قبل از نهایی کردن رشته استفاده می شود. <br/>این می تواند برای محلی سازی، اقدامات امنیتی در برابر حملات XSS یا دستکاری های پیچیده رشته مفید
        باشد.
    </p>
    <img src="./images/6.18 photo.PNG" width="450" alt="photo18">
    <div> 
        <img src="./images/6.19 photo.PNG" width="450" alt="photo19">
</div>
    </section>

    <section id="modir5"><h3>
      رشته های رایج - String Methods
    </h3>
    <p>
      در جاوا، رشته ها اشیایی از کلاس String هستند که روش های مختلفی را برای دستکاری و برخورد با رشته ها 
      ارائه می دهند. این روش ها <br/>به توسعه دهندگان اجازه می دهد
        تا به راحتی کارهایی مانند جستجوی محتوا، مقایسه رشته ها، 
        تقسیم رشته ها به زیر رشته ها و بسیاری <br/>از توابع دیگر را انجام دهند. در اینجا برخی از متدهای رایج کلاس String در جاوا آورده شده است:
    </p>
    </section>
    <section id="modir6"><h3>
      Concatenation
    </h3>
    <p>
      Concatenation فرآیند اتصال دو یا چند رشته به یکدیگر است. این را می توان با استفاده از عملگر + یا متد ()concat انجام داد.
    </p>
    <img src="./images/6.20 photo.PNG" width="450" alt="photo20">
    <div>   
      <img src="./images/6.21 photo.PNG" alt="photo21" width="450">
</div>
    </section>
    <section id="modir7"><h3>
      length
    </h3>
    <p>
      ویژگی length تعداد کاراکترهای یک رشته را برمی گرداند.
    </p>
    <img src="./images/6.22 photo.PNG" width="450" alt="photo22">
    </section id="modir8">
    <section><h3>
      دسترسی به کاراکترها - Characters 
    </h3>
    <p>
      شما می توانید با استفاده 
      از علامت گذاری براکت، مانند دسترسی به عناصر
        آرایه، به کاراکترهای جداگانه در یک رشته دسترسی داشته باشید. 
      به یاد داشته باشید که شاخص های رشته ای مبتنی بر صفر هستند.
    </p>
    <img src="./images/6.23 photo.PNG" width="450" alt="photo23">
    </section>
    <section id="modir9"><h3>
          جستجو در یک رشته - Searching Within a String
  </h3>
  <p>
      جاوا اسکریپت چندین روش برای جستجو در یک رشته فراهم می کند، مانند indexOf()، lastIndexOf() و include().
  </p>
  <img src="./images/6.24 photo.PNG" width="450" alt="photo24">
  </section>

    <section id="modir10"><h3>
      استخراج زیر رشته ها - Extracting Substrings
    </h3>
    <p>
      برای استخراج بخش هایی از یک رشته، می توانید از متدهایی مانند 
      slice()، substring() و substr() استفاده کنید.
    </p>
    <img src="./images/6.25 photo.PNG" width="450" alt="photo25">
    </section>

    <section id="modir11"><h3>
      جایگزینی محتوا - Replacing Content
    </h3>
    <p>
      متد ()replace وقوع یک زیر رشته در یک رشته را با یک زیررشته جدید جایگزین می کند. 
    </p>
    <img src="./images/6.26 photo.PNG" width="450" alt="photo26">
    </section>
    <section id="modir12"><h3>
      تغییر حروف - Changing Case
    </h3>
    <p>
      برای تغییر حروف یک رشته، می توانید از ()toUpperCase و ()toLowerCase استفاده کنید.

    </p>
    <img src="./images/6.27 photo.PNG" width="450" alt="photo27">
    <div>
      <img src="./images/6.28 photo.PNG" alt="photo28" width="450">
    </div>
    <p>
      رشته ها بخش اساسی برنامه نویسی جاوا اسکریپت هستند که به شما
      امکان می دهند متن را به روش های مختلف دستکاری کنید. <br/>از ایجاد تبریک های ساده تا پردازش داده های پیچیده، درک نحوه کار موثر با رشته ها 
      به شما امکان می دهد برنامه های وب تعاملی و <br/>کاربرپسندتری بسازید. با تسلط بر عملیات رشته، مجموعه وسیعی از امکانات 
      را برای دستکاری متن و ارائه داده ها در پروژه های جاوا اسکریپت خود باز می کنید.
    </p>
    </section>

    <section id="araye">
      <h3>
      شرح مفصل آرایه ها / Arrays در جاوا اسکریپت 
    </h3>
    <p>
      آرایه ها یکی از جنبه های اساسی جاوا اسکریپت هستند که به توسعه 
      دهندگان اجازه می دهند چندین مقدار را در یک ساختار داده سازمان یافته ذخیره کنند. <br/>
        آنها می توانند هر نوع مقداری، از رشته ها و اعداد
        گرفته تا ساختارهای پیچیده تر مانند اشیاء یا حتی آرایه های دیگر را در خود نگه دارند.
        بیایید عمیق‌تر <br/>در آرایه‌ها غوطه‌ور شویم، پیچیدگی‌های آن‌ها را درک کنیم، 
      و یاد بگیریم چگونه آنها را به طور مؤثر دستکاری کنیم.
    </p>
    <section id="araye1"><h3>
      ایجاد و راه اندازی آرایه ها
    </h3>
    <p>
      آرایه ها با قرار دادن لیستی از عناصر جدا شده با کاما در داخل پرانتز ایجاد می شوند. این عناصر می توانند از هر نوع باشند، از جمله اعداد، رشته ها و یا حتی آرایه های دیگر (منجر به آرایه های چند بعدی):

    </p>
    <img src="./images/6.29 photo.PNG" width="450" alt="photo29">
    </section>

    <section id="araye2"><h3>
      دسترسی به آیتم های آرایه
    </h3>
    <p>
      به هر عنصر در یک آرایه یک شاخص متوالی اختصاص داده می شود که با 0 شروع می شود. این دستور اولین آیتم آرایه را که 'apple' است فچ  می کند:
    </p>
    <img src="./images/6.30 photo.PNG" width="450" alt="photo30">
    </section>
    <section id="araye3"><h3>
      اصلاح آیتم های آرایه
    </h3>
    <p>
      شما می توانید یک آیتم موجود در یک آرایه را با استفاده از فهرست آن تغییر دهید. برای به روز رسانی آرایه، مقدار جدیدی به آیتم در شاخص مشخص شده اختصاص دهید. در اینجا، مورد دوم را از "موز" به "blueberry" تغییر دادیم: 
    </p>
    <img src="./images/6.31 photo.PNG" width="450" alt="photo31">
    </section>
    <section id="araye4"><h3>
      دسترسی و اصلاح آیتم های آرایه
    </h3>
    <p>
      به هر عنصر در یک آرایه یک شاخص متوالی اختصاص داده می شود که با 0 شروع می شود. این دستور اولین آیتم آرایه را که 'apple' است فچ  می کند:
    </p>
    <img src="./images/6.32 photo.PNG"  width="450" alt="photo32">
    </section>

    <section id="araye5"><h3>
      آرایه های چند بعدی - Multidimensional Arrays
    </h3>
    <p>
      آرایه‌ای که شامل آرایه‌های دیگری به عنوان عناصر خود است، به عنوان آرایه چند بعدی شناخته می‌شود. می‌توانید با زنجیره‌ای کردن شاخص‌ها با استفاده از علامت‌گذاری براکت، به موارد موجود در یک آرایه چند بعدی دسترسی داشته باشید. این به آیتم دوم (شاخص 1) در آیتم سوم (شاخص 2) MultiArray که عدد 1 است دسترسی پیدا می کند: 
    </p>
    <img src="./images/6.33 photo.PNG" width="450" alt="photo33">
    </section>

    <section id="shakhes" ><h2>
      ویژگی ها و روش های آرایه / Array Properties and Methods <br/>
      <section id="shakhes1">
      <h3>
        ویژگی length
      </h3>
    </section>
    </h2>
    <p>
      ویژگی length یک آرایه تعداد عناصر موجود در آن را برمی گرداند.
    </p>
    <img src="./images/6.34 photo.PNG" width="450" alt="photo34">
    <section id="shakhes2"><h3>
      افزودن و حذف موارد
    </h3></section>
    <p>
    Push and Pop: موارد را با push() به انتهای آرایه اضافه کنید و آخرین مورد را با pop() حذف کنید.  
    </p>
    <img src="./images/6.35 photo.PNG" width="450" alt="photo35">
    <p>
      Unshift و Shift: به طور مشابه، unshift () موارد را به ابتدا اضافه می کند و shift() اولین مورد را حذف می کند. 
    </p>
    <div>
      <img src="./images/6.36 photo.PNG" width="450" alt="photo36">
    </div>

    <section id="shakhes3"><h3>
      یافتن آیتم ها و شاخص ها
    </h3>
    <p>
      indexOf(): شاخص اولین رخداد یک عنصر مشخص را پیدا می کند.
    </p>
    <img src="./images/6.37 photo.PNG" width="450" alt="photo37">
    <p>
      include(): بررسی می کند که آیا یک آرایه حاوی مقدار خاصی است یا خیر.
    </p>
    <img src="./images/6.38 photo.PNG" width="450" alt="photo38">
    <p>
      آرایه ها در جاوا اسکریپت همه کاره و قدرتمند هستند و قادر به نگهداری ساختارهای داده پیچیده و ارائه طیف گسترده ای <br/>
      از روش ها برای دستکاری آنها هستند. درک آرایه ها و تکنیک های دستکاری آن ها برای مدیریت موثر داده ها و <br/>
      عملیات در جاوا اسکریپت بسیار مهم است. آرایه‌ها چه برای ذخیره‌سازی فهرست ساده‌ای از نام‌ها یا ساختاردهی داده‌های <br/>
      چند بعدی، انعطاف‌پذیری و عملکرد مورد نیاز برای طیف وسیعی از سناریوهای برنامه‌نویسی را ارائه می‌دهند.
    </p>
    </section>

    <section id="loop"><h3>
      حلقه روی آرایه ها - Looping over Arrays
    </h3>
    <p>
      حلقه زدن روی آرایه ها جنبه اساسی کار با لیست های داده در جاوا اسکریپت است. حلقه ها به شما امکان می دهند یک <br/>
    بلوک کد را به طور مکرر اجرا کنید و آنها را برای انجام عملیات روی هر آیتم در یک آرایه بسیار مفید می کند. بیایید <br/>
      روش های مختلف برای حلقه زدن آرایه ها را با جزئیات بررسی کنیم. 
    <section id="loop1"><h4>
      حلقه for
    </h4>
    <p>
      حلقه for سنتی روشی همه کاره برای تکرار روی یک آرایه است. به تنظیم یک شمارنده اولیه، شرطی که باید برای ادامه <br/>
      
      <h5>
        مثال: </h5>
    </p>
    <img src="./images/6.93 photo.PNG" width="450" alt="photo39">
    <div>
      <img src="./images/6.40 photo.PNG" width="450" alt="photo40">

    </div>
    <p>
      در این مثال، i از 0 شروع می شود و تا زمانی که i کمتر از طول آرایه میوه ها باشد
      ، حلقه ادامه می یابد
      . پس از هر تکرار، i 1 افزایش می یابد.
    </p>
    </section>
    <section id="loop2"><h3>
      حلقه برای... از - For…of 
    </h3>
    <p>
      حلقه for...of که در ES6 معرفی شد، نحو ساده‌تری را برای تکرار روی اشیاء تکرارپذیر مانند آرایه‌ها فراهم می‌کند. <br/>
      این نیاز به دسترسی مستقیم به طول آرایه یا استفاده از یک شاخص برای دسترسی به آیتم های آرایه را از بین می برد.

        <h5>
        مثال:
        </h5>
        </p>
        <p>
        این حلقه روی هر میوه در آرایه میوه‌ها تکرار می‌شود و مستقیماً مقدار هر آیتم را به متغیر میوه در هر تکرار اختصاص <br/>
        می‌دهد.
        </p>
        </section>

    <section id="loop3"><h3>
      متد forEach()
    </h3>
    <p>
      متد forEach() یک روش آرایه ای است که یک تابع ارائه شده را یک بار برای هر عنصر آرایه اجرا می کند. این <br/>
      بخشی از نمونه اولیه Array است و رویکرد برنامه نویسی کاربردی تری را ارائه می دهد.
        <h5>
          مثال: 
        </h5>
    </p>
    <img src="./images/6.41 photo.PNG" width="450" alt="photo41">
    <p>
    ()forEach آیتم فعلی، شاخص آن و کل آرایه را در طول هر تکرار به تابع callback ارسال می کند. اگر به ایندکس یا <br/>
    آرایه نیاز ندارید، می توانید این پارامترها را حذف کنید:
    </p>
    <img src="./images/6.42 photo.PNG" width="450" alt="photo42">
    </section>
    <section id="map"><h3>
      روش نقشه () - The map() Method 
    </h3>
    <p>
      در حالی که به طور دقیق برای حلقه زدن به روش های بالا استفاده نمی شود، map() یک آرایه جدید با تبدیل هر عنصر <br/>
      در آرایه اصلی به صورت جداگانه ایجاد می کند. اغلب زمانی استفاده می شود که می خواهید عملیات خاصی را برای هر <br/>
      مورد اعمال کنید و از نتایج یک آرایه جدید ایجاد کنید.
  
      <h5>
        مثال:
      </h5>
    </p>
    <img src="./images/6.43 photo.PNG" width="450" alt="photo43">
    <p>
      این مثال نام هر میوه را به حروف بزرگ تبدیل می کند و نتایج را در یک آرایه جدید جمع آوری می کند. 
    </p>
    <section id="nokte"><h3>
      نکاتی برای حلقه زدن آرایه ها
    </h3>
    <ul>
      <li>
    انتخاب حلقه مناسب: برای تکرار ساده، for...of و forEach () جایگزین‌های مدرن‌تر و خواناتری برای حلقه <br/>
    for سنتی هستند. زمانی که نیاز به تبدیل عناصر و ایجاد یک آرایه جدید دارید، از map() استفاده کنید.
      </li>
      <li>
          ملاحظات عملکرد: در حالی که forEach()، for...of، و map() نحو تمیزتری را ارائه می دهند، حلقه for <br/>
        سنتی ممکن است در برخی سناریوها، به ویژه برای آرایه های بزرگ، مزایای عملکرد جزئی را ارائه دهد. با <br/>
        این حال، برای بیشتر موارد استفاده، تفاوت ناچیز است. 
      </li>
      <li>
          تکرار به عقب: اگر نیاز دارید از طریق یک آرایه به ترتیب معکوس حلقه بزنید، یک حلقه for سنتی که در آن <br/>
          شمارنده را کاهش می دهید می تواند ساده تر باشد.
      </li>
    </ul>
    <p>
      تکرار به عقب: اگر نیاز دارید از طریق یک آرایه به ترتیب معکوس حلقه بزنید، یک حلقه for سنتی که در آن <br/>
      لیست را به طور موثر پردازش و دستکاری کنید. چه در حال جمع‌آوری امتیازات، ایجاد نشانه‌گذاری HTML از داده‌ها، <br/>
      یا انجام محاسبات بر روی اقلام مجموعه‌ای هستید، تسلط بر تکرار آرایه به طور قابل توجهی توانایی شما را برای کار با <br/>
      داده‌های پویا در برنامه‌هایتان افزایش می‌دهد. برای یافتن بهترین مناسب برای سناریوها و ترجیحات خاص خود، این <br/>
      روش های مختلف حلقه را آزمایش کنید.
    </p>
    </section>
    <section id="tasmim"><h3>
      تصمیم گیری: تسلط بر شرایط در جاوا اسکریپت
    </h3>
    <p>
      تصمیم گیری در کد شما: تسلط بر شرایط در جاوا اسکریپت<br/>
      در برنامه نویسی، درست مانند زندگی واقعی، اغلب نیاز به تصمیم گیری داریم. این تصمیمات بر اساس شرایط مختلف، با <br/>
      تقلید از فرآیند تصمیم گیری منطقی، جریان اجرا را تعیین می کنند. جاوا اسکریپت راه های مختلفی برای انجام بررسی <br/>
      های شرطی و اجرای کد بر اساس آن ارائه می دهد و برنامه های شما را قادر می سازد به صورت پویا به ورودی ها یا <br/>
      موقعیت های مختلف پاسخ دهند. در این فصل، ما عمیقاً به عبارات شرطی در جاوا اسکریپت می پردازیم، نحو، استفاده و <br/>
      بهترین شیوه ها را از طریق مثال های دنیای واقعی بررسی می کنیم.
    </p>
    <p>
      درک عبارات مشروط<br/>
      عبارات شرطی به شما امکان می دهد تا قطعات خاصی از کد را بر اساس شرایط خاص اجرا کنید. اینها ستون فقرات <br/>
      تصمیم گیری در برنامه نویسی هستند و به کد شما اجازه می دهند به مسیرهای مختلف منشعب شوند و اقداماتی را بر <br/>
      اساس داده های ورودی انجام دهند.
    </p>
    <section id="tasmim1"><h3>
      بیانیه if
    </h3>
    <b>
      ساده ترین شکل شرطی عبارت if است. اگر شرط مشخص شده درست باشد، یک بلوک کد را اجرا می کند. <br/>
      مثال: فرض کنید می‌خواهیم بررسی کنیم که آیا سن یک کاربر به اندازه کافی برای دسترسی به بخش خاصی از وب‌سایت <br/>
      کافی است یا خیر.
    </p>
    <img src="./images/6.44 photo.PNG" width="450" alt="photo44">
    </section>

    <section id="tasmim2"><h3>
      بیانیه دیگر- else 
    </h3>
    <p>
      اغلب، اگر شرط درست نباشد، می خواهید یک عمل جایگزین انجام دهید. اینجاست که عبارت else وارد می شود. <br/>
      مثال: درپی مثال قبلی برای رسیدگی به کاربران زیر سن قانونی:
    </p>
    <img src="./images/6.45 photo.PNG" width="450" alt="photo45">
    </section>

    <section id="tasmim3"><h3>
      بیانیه else if 
    </h3>
    <p>
      برای چند شرط، اگر شرط اول نادرست است، از else if استفاده کنید تا یک شرط جدید را مشخص کنید. <br/>
      مثال: اضافه کردن یک شرط تخفیف بر اساس سن:
    </p>
    <img src="./images/6.46 photo.PNG" width="450" alt="photo46">
    </section>
    <section id="tasmim4"><h3>
      Nested if Statements
    </h3>
    <p>
      می‌توانید برای بررسی چند شرط، دستورهای if را درون یکدیگر قرار دهید. <br/>
      مثال: بررسی شرایط چندگانه برای دسترسی یک رویداد خاص:
    </p>
    <img src="./images/6.47 photo.PNG" width="450" width="450"alt="photo47">
    <div>
    <img src="./images/6.48 photo.PNG" width="450" alt="photo48">

    </div>
    </section>
    <section id="tasmim5"><h3>
      اپراتورهای مقایسه - Comparison Operators
    </h3>
    <p>
      عملگرهای مقایسه (==، !=، ===، !==، >، <، >=، <=) در شرایط شرطی برای مقایسه مقادیر استفاده می شوند. <br/>
      == برابری را بررسی می کند. <br/>
      === برابری دقیق (مقدار و نوع) را بررسی می کند. <br/>
      != و !== به ترتیب نابرابری و نابرابری شدید را بررسی کنید. <br/>
      >، <، >=، <s= مقادیر عددی را مقایسه کنید.
    </p>
    <section id="tasmim6"><h3>
      عملگرهای منطقی - Logical Operators
    </h3>
    <p>
      عملگرهای منطقی (&&، ||، !) اجازه ترکیب چند شرط را می دهند. <br/>
      && (AND) درست بودن هر دو شرط را بررسی می کند. <br/>
      || (OR) بررسی می کند که آیا حداقل یک شرط درست است یا خیر. <br/>
      ! (NOT) یک شرط را نفی می کند. <br/>
      مثال: بررسی شرایط متعدد برای ارتقاء:
    </p>
    <img src="./images/6.94 photo.PNG" width="450" alt="photo49">
    </section>
    <section id="tasmim7"> <h3>
      
اپراتور سه گانه - The Ternary Operator

    </h3>
    <p>
      
        
عملگر سه گانه مخفف عبارات if-else است که برای شرطی های ساده استفاده می شود. <br/>

مثال: اعطای تخفیف بر اساس سن:
</p>
<img src="./images/6.50 photo.PNG" width="450" alt="photo50">
</section>
    <section id="tasmim8"><h3>
      بیانیه سوئیچ - The switch Statement
    </h3>
    <p>
      دستور switch برای بررسی های چندگانه در برابر یک مقدار واحد استفاده می شود. این جایگزینی برای چندین شرط <br/>
      if-else است. <br/>
      مثال: تخصیص نقش ها بر اساس نوع کاربر:
    </p>
    <img src="./images/6.51 photo.PNG" width="450" alt="photo51">
    <div>
      <img src="./images/6.52 photo.PNG" width="450" alt="photo52">
    </div>
    <p>
      عبارات شرطی برای ایجاد برنامه های کاربردی وب پویا و تعاملی ضروری هستند. با درک نحوه استفاده از if، else <br/>
      if، else، شرط های تودرتو، عملگر سه تایی و دستور switch، می توانید جریان برنامه های جاوا اسکریپت خود را به <br/>
      طور موثر کنترل کنید. این ابزارها به شما امکان می‌دهند در کد خود تصمیم بگیرید و به برنامه‌های منطقی‌تر، کارآمدتر و <br/>
      پاسخگوتر کاربر منجر شود. استفاده از این شرطی ها را با سناریوهای مختلف تمرین کنید تا قدرت و انعطاف پذیری آنها <br/>
      را به طور کامل درک کنید. 
    </p>
    <p>
      بیایید مثال‌های ارائه‌شده در بحث در مورد عبارات شرطی در جاوا اسکریپت را با ترکیب HTML و CSS برای ایجاد <br/>
      یک سناریوی کامل‌تر گسترش دهیم. این به نشان دادن نحوه کار جاوا اسکریپت، HTML و CSS برای ساخت صفحات  <br/>
      وب تعاملی کمک می کند.
    </p>
    <p>
      
سناریو: تأیید سن برای دسترسی به وب سایت
<br/>
وب سایتی را تصور کنید که برای دسترسی به محتوای خاصی نیاز به تأیید سن دارد. ما از یک فرم ساده HTML برای <br/>
بدست آوردن سن کاربر استفاده می کنیم و سپس برای تعیین سطح دسترسی از شرطی های جاوا اسکریپت استفاده می <br/>
کنیم. علاوه بر این، ما از CSS برای یک ظاهر طراحی اولیه استفاده خواهیم کرد.
    </p>
    </section>
    <section id="tasmim9"><h3>
      HTML
    </h3>
    <p>
      
ابتدا، اجازه دهید یک فرم HTML ایجاد کنیم که در آن کاربران می توانند سن خود را وارد کنند، و یک مکان نگهدار که 
<br/>
در آن پیام نمایش داده می شود.
    </p>
    <img src="./images/photo ebrahim.PNG" alt="photo ebrahim" width="450">
    </section>

    <section id="tasmim10"><h3>
      CSS (style.css)
    </h3>
    <p>
      حالا، بیایید یک استایل اولیه اضافه کنیم تا فرم کمی زیباتر به نظر برسد.
    </p>
    <img src="./images/6.53 photo.PNG" width="450" alt="53">
    <div>
<img src="./images/6.54 photo.PNG " alt="54" width="450" >
    </div>
    
    <img src="./images/6.55 photo.PNG" width="450" alt="55">
    </section>
    
    <section id="tasmim11"><h3>
      جاوا اسکریپت (script.js) 
    </h3>
    <p>
      در نهایت، بیایید منطق را با جاوا اسکریپت پیاده سازی کنیم. ما از عبارت if-else برای تعیین سطح دسترسی بر اساس <br/>
      سن وارد شده توسط کاربر استفاده خواهیم کرد.
    </p>
    <img src="./images/6.56 photo.PNG" width="450" alt="56">
    <div>
    <img src="./images/6.57 photo.PNG" width="450" alt="57">

    </div>
    </section>

    <section id="tasmim12"><h3>
      توضیح 
    </h3>
    <ul>
      <li>
        HTML: ساختار شامل یک فرم برای ورودی سن و یک div برای نمایش پیام ها است. با کلیک روی دکمه، <br/>
        تابع verifyAge تعریف شده در فایل جاوا اسکریپت را فراخوانی می کند.
      </li>
      <li>
        CSS: سبک‌هایی اضافه می‌شوند تا ظاهر فرم و صفحه به طور کلی بهبود یابد. این شامل یک ظاهر طراحی  <br/>
        شده برای بدنه، فرم، جعبه ورودی، دکمه و div پیام است.
      </li>
      <li>
        جاوا اسکریپت: این اسکریپت سن وارد شده توسط کاربر را می گیرد و از منطق شرطی برای تعیین پیام برای <br/>
        نمایش استفاده می کند. سپس پیام در div با پیام شناسه نمایش داده می شود.
      </li>
    </ul>
    <p>
      با ادغام HTML، CSS و جاوا اسکریپت، ما یک سیستم تأیید سن ساده و در عین حال تعاملی ایجاد کرده ایم. کاربران <br/>
      می توانند سن خود را وارد کنند و بسته به مقدار، پیام مربوطه در مورد سطح دسترسی آنها نمایش داده می شود. این مثال <br/>
      قدرت جاوا اسکریپت را برای افزودن تعامل به صفحات وب، نشان دادن اصول دستکاری DOM و منطق شرطی نشان <br/>
      می دهد. 
    </p>
    <img src="./images/6.58 photo.png" width="450" alt="58">
    </section>

    <section id="halghe"><h3>
      قدرت حلقه ها / Loops در جاوا اسکریپت
    </h3>
    <p>
      حلقه ها سنگ بنای برنامه نویسی هستند که ما را قادر می سازند کارهای تکراری را سریع و موثر انجام دهیم. در جاوا <br/>
      اسکریپت، حلقه ها نقش مهمی در دستکاری داده ها، خودکارسازی وظایف و افزایش تعامل برنامه های کاربردی وب <br/>
      دارند. این فصل به ساختارهای حلقه‌ای مختلف موجود در جاوا اسکریپت می‌پردازد و اهمیت آنها را از طریق سناریوها و <br/>
      مثال‌های عملی نشان می‌دهد.
    </p>

    <section id="halghe1"><h3>
      چرا حلقه ها اهمیت دارند
    </h3>
    <p>
      حلقه ها در برنامه نویسی برای خودکارسازی کارهای تکراری ضروری هستند. چه در حال پردازش مجموعه‌ای از <br/>
      داده‌ها، تولید عناصر UI پویا یا پیاده‌سازی منطق بازی باشید، حلقه‌ها یک رویکرد ساده برای اجرای چندین بار یک بلوک <br/>
      کد ارائه می‌دهند. این نه تنها در زمان صرفه جویی می کند، بلکه افزونگی کد را نیز به حداقل می رساند و اسکریپت های <br/>
    شما را خواناتر و قابل نگهداری تر می کند. بدون حلقه‌ها، انجام چندین بار یک عمل یکسان مستلزم نوشتن کد آن عمل در <br/>
      هر بار اجرای آن است که باعث طولانی‌تر شدن کد، نگهداری سخت‌تر و مستعد خطا می‌شود. 
    </p>
    </section>

    <section id="halghe2"><h4>
      مثال: نمایش فهرستی از نام ها 
    </h4>
    <p>
      تصور کنید لیستی از اسامی دارید که می خواهید در یک صفحه وب نمایش دهید. با یک حلقه، می توانید به راحتی در <br/>
      لیست تکرار کنید و هر نام را تنها با چند خط کد نمایش دهید. بیایید ببینیم این سناریو با و بدون استفاده از یک حلقه چگونه <br/>
      به نظر می رسد.
    </p>
    <section id="halghe3"><h3>
      با یک حلقه
    </h3>
    <img src="./images/6.59 photo.PNG" width="450" alt="59">
    <p>
      در این مثال، صرف نظر از تعداد نام‌ها در آرایه، حلقه for به طور موثر نمایش همه آنها را با یک بلوک مختصر از کد <br/>
      کنترل می‌کند. 
    </p>
    </section>
    <section id="halghe4"><h3>
      بدون حلقه
    </h3>
    <p>
      بدون استفاده از حلقه، باید به صورت دستی یک عبارت برای نمایش هر نام بنویسید. برای همان لیست اسامی، کد چیزی <br/>
      شبیه به این خواهد بود:
    </p>
    <img src="./images/6.60 photo.PNG" width="450" alt="60">
    <p>
      این رویکرد نه تنها ناکارآمد است بلکه مقیاس پذیر نیز نیست. اگر لیست به صدها یا هزاران نام افزایش یابد، نوشتن دستی <br/>
      یک عبارت console.log برای هر یک غیر عملی است. علاوه بر این، افزودن یا حذف نام‌ها از لیست نیاز به تغییر کد <br/>
      برای تنظیم تعداد عبارات دارد و خطر خطا را افزایش می‌دهد.
    </p>
    </section>

    <section id="halghe5"><h3>
      تاثیر حلقه ها 
    </h3>
    <p>
      
مقایسه به وضوح نشان می دهد که چرا حلقه ها در برنامه نویسی بسیار مهم هستند:

    </p>
    <ul>
      <li>
        کارایی: حلقه‌ها وظایف تکراری را خودکار می‌کنند و مقدار کد مورد نیاز برای نوشتن را به میزان قابل توجهی <br/>
        کاهش می‌دهند. 
      </li>
      <li>
        قابلیت نگهداری: با حلقه ها، افزودن یا حذف موارد از یک لیست نیازی به تغییر در خود حلقه ندارد و حفظ کد <br/>
        را آسان تر می کند.
      </li>
      <li>
        مقیاس پذیری: حلقه ها می توانند هر تعداد آیتم را مدیریت کنند، و کد شما را مقیاس پذیرتر و سازگارتر با اندازه <br/>
        های مختلف داده می کند.
      </li>
    </ul>
    <p>
      به طور خلاصه، حلقه ها یک ابزار اساسی در جعبه ابزار برنامه نویس هستند که کدهای کارآمدتر، خوانا و قابل نگهداری <br/>
      را امکان پذیر می کنند. بدون حلقه، مدیریت وظایف تکراری دشوار و مستعد خطا خواهد بود، به ویژه با افزایش پیچیدگی <br/>
      و اندازه داده ها. جاوا اسکریپت انواع مختلفی از حلقه ها را ارائه می دهد که هر کدام برای سناریوهای مختلف مناسب <br/>
      هستند. بیایید این ساختارهای حلقه‌ای را با مثال‌های واقعی بررسی کنیم:
    </p>
    </section>
    <section id="halghe6"><h3>
      حلقه for
    </h3>
    <p>
      حلقه for همه کاره ترین ساختار حلقه در جاوا اسکریپت است. این برای موقعیت هایی ایده آل است که از قبل می دانید <br/>
      چند بار باید یک بلوک کد را اجرا کنید. <br/>
      <h4>
        مثال: ایجاد لیستی از اعداد زوج تا حد معین.
      </h4>
    </p>
    <img src="./images/6.61 photo.PNG" width="450" alt="61">
    <div>
      <img src="./images/6.62 photo.PNG" width="450" alt="62">
    </div>
    </section>
    <section id="halghe7"><h3>
      حلقه while
    </h3>
    <p>
      حلقه while زمانی مناسب است که تعداد تکرارها قبل از شروع حلقه مشخص نباشد. تا زمانی که شرایط آن به درستی <br/>
      ارزیابی شود، ادامه می یابد. <br/>
      <h4>
        مثال: یافتن فاکتوریل یک عدد.
      </h4>
    </p>
    <img src="./images/6.63 photo.PNG" width="450" alt="63">
    </section>

    <section id="halghe8"><h3>
      حلقه do...while
    </h3></section>
    <p>
      حلقه do...while مشابه حلقه while است، اما تضمین می کند که بلوک کد حداقل یک بار اجرا شود. <br/>
      <h4>
      مثال: اعتبار سنجی ورودی کاربر.
      </h4> 
    </p>
    <img src="./images/6.64 photo.PNG" width="450" alt="64">
    </section>

    <section id="halghe9"><h3>
      حلقه for...of
    </h3>
    <p>
      حلقه for...of یک نحو ساده برای تکرار بر روی اشیاء تکرارپذیر مانند آرایه ها و رشته ها فراهم می کند. <br/>
      <h4>
        مثال: تکرار روی آرایه ای از نام ها.
      </h4>
    </p>
    <img src="./images/6.65 photo.PNG" width="450" alt="65">
    </section>

    <section id="halghe10"><h3>
      حلقه for...in 
    </h3>
    <p>
      اگرچه منحصراً برای آرایه ها نیست، حلقه for...in برای تکرار روی کلیدهای یک شی استفاده می شود. <br/>
      <h4>
        مثال: چاپ خواص شی.
      </h4>
    </p>
    <img src="./images/6.66 photo.PNG" width="450" alt="66">
    </section>

    <section id="halghe11"><h3>
      استفاده بهینه از حلقه ها<br/>
      </h3>
      
      <p>
        ترکیب حلقه ها با دستورات شرطی
      </p>
      </section>
    

    <p>
      حلقه ها اغلب دست در دست هم با دستورات شرطی کار می کنند تا عملیات پیچیده تری را بر اساس شرایط خاص انجام <br/>
      دهند. <br/>
      <h4>
        مثال: فیلتر کردن اعداد زوج از یک آرایه.
      </h4>
    </p>
    <img src="./images/6.67 photo.PNG" width="450" alt="67">
        </section>

    <section id="halghe12"><h3>
      بیانیه های کنترل حلقه Loop Control Statements
    </h3>
    <p>
      <h4>
        break: حلقه را خاتمه می دهد. <br/>
        continue: بقیه تکرار حلقه را رد می کند و با مورد بعدی ادامه می دهد. <br/>
        مثال: بیرون آمدن از یک حلقه زمانی که یک شرط برآورده شود.

      </h4>
    </p>
    <img src="./images/6.68 photo.PNG" width="450" alt="68">
    <p>
      حلقه ها یک جنبه اساسی جاوا اسکریپت هستند که به توسعه دهندگان امکان می دهد کدهای کارآمد، مختصر و خوانا <br/>
      بنویسند. با درک انواع مختلف حلقه ها و موارد استفاده مناسب از آنها، می توانید از پتانسیل کامل آنها برای بهبود برنامه <br/>
      های کاربردی وب خود استفاده کنید. به یاد داشته باشید، بهترین راه برای تسلط بر حلقه ها تمرین است، بنابراین با این <br/>
      مثال ها آزمایش کنید و سناریوهای خود را ایجاد کنید تا ببینید با حلقه ها در جاوا اسکریپت به چه چیزی می توانید برسید.
    </p>
    </section>
    <section id="halghe13"><h3>
      مثال حلقه‌ها
    </h3>
    <p>
      بیایید مثال نمایش لیستی از نام‌ها با حلقه‌ها را با ادغام HTML و CSS تقویت کنیم تا نه تنها نشان دهیم که حلقه‌ها چگونه <br/>
      در جاوا اسکریپت کار می‌کنند، بلکه چگونه در یک صفحه وب کامل ادغام می‌شوند. این نشان می دهد که چگونه <br/>
      HTML، CSS و جاوا اسکریپت می توانند برای نمایش پویا محتوا با هم کار کنند.
    </p>
    </section>
    <section id="halghe14"><h3>
      HTML 
    </h3>
    <p>
      ابتدا یک ساختار ساده HTML راه اندازی می کنیم. ما یک لیست نامرتب (<ul>) خواهیم داشت که در آن آیتم های لیست <br/> 
        (<li>) را به صورت برنامه نویسی برای هر نام درج می کنیم. 
    </p>
    <img src="./images/6.69 photo.PNG" width="450" alt="69">
    <div> 
       <img src="./images/6.70 photo.PNG" width="450" alt="70">
</div>
    </section>


    <section id="halghe15"><h3>
      CSS (styles.css)

    </h3>
    <p>
      در مرحله بعد، چند سبک اساسی را اضافه کنید تا لیست از نظر بصری جذاب شود.
    </p>
    <div>
<img src="./images/6.71 photo.PNG" alt="71" width="450">
    </div>
    
    <img src="./images/6.72 photo.PNG" width="450" alt="72">
    </section>
    <section id="halghe16"><h3>
      جاوا اسکریپت (script.js)
    </h3>
    <p>
      در نهایت، اجازه دهید از جاوا اسکریپت برای درج پویا هر نام در لیست با استفاده از یک حلقه استفاده کنیم.
        آرایه نام‌ها را از قبل و برای هر نام می‌گیریم، یک عنصر <li> جدید ایجاد می‌کنیم، 
        محتوای متن آن را روی نام فعلی تنظیم می‌کنیم و آن را به <ul> اضافه می‌کنیم.
    </p>
    <img src="./images/6.73 photo.PNG" width="450" alt="73">
    </section>

    <section id="halghe17"><h3>
      توضیح
    </h3>
    <ul><li>
    HTML: ساختار صفحه را تنظیم می کند، از جمله یک عنوان و یک لیست خالی نامرتب که در آن نام ها به صورت پویا درج می شوند.
    <div>
        <img src="./images/6.74 photo.PNG" width="450" alt="74">

    </div>
    <div>
    <img src="./images/6.75 photo.PNG" width="450" alt="75">

    </div>
    </li>
    <li>
      CSS: یک ظاهر طراحی برای صفحه و موارد فهرست، از جمله چیدمان اولیه و زیبایی‌شناسی مانند رنگ پس‌زمینه، بالشتک‌ها، حاشیه‌ها و سایه جعبه برای ظاهر بصری دلپذیر ارائه می‌کند.
    </li>
    <li>
      جاوا اسکریپت: منتظر می ماند تا DOM به طور کامل بارگیری شود (رویداد DOMContentLoaded) قبل از اجرای اسکریپت برای اطمینان 
      از در دسترس بودن عناصری مانند لیست نامرتب. سپس از یک حلقه for برای تکرار در میان آرایه نام ها استفاده می کند، 
      یک آیتم لیست جدید برای هر نام ایجاد می کند و آن را به لیست نامرتب در HTML اضافه می کند.
        این نشان می دهد که چگونه حلقه ها در جاوا اسکریپت می توانند برای تولید و نمایش پویا محتوا در یک صفحه وب بر اساس داده ها استفاده شوند.
    </li>
  </ul>
  <p>
    

در این مثال یکپارچه، ما قدرت استفاده از حلقه ها در جاوا اسکریپت برای تعامل با DOM را می بینیم که امکان تولید محتوای پویا را فراهم می کند. این رویکرد در توسعه وب اساسی است، 
جایی که محتوای صفحات وب اغلب باید بر اساس داده های سرور، ورودی کاربر یا منابع دیگر تولید یا به روز شود.

  </p>
  <img src="./images/6.76 photo.PNG" width="450" alt="76">

  </section>
    <section id="tabe"><h3>
      استفاده از قدرت توابع / Functions در جاوا اسکریپت 
    </h3>
    <p>
      توابع بلوک های سازنده کدهای قابل خواندن، قابل نگهداری و قابل استفاده مجدد در جاوا اسکریپت 
      هستند. آنها دنباله ای از عبارات را برای انجام یک کار خاص در یک واحد واحد کپسوله می کنند که می تواند از قسمت های مختلف یک برنامه به تعداد دفعات مورد نیاز فراخوانی شود. 
      این فصل شما را از طریق مفاهیم اساسی توابع در جاوا اسکریپت راهنمایی می کند و اهمیت آنها را با مثال های عملی نشان می دهد.
    </p>

    <section id="tabe1"><h3>
      مقدمه ای بر توابع
    </h3>
    <p>
      یک تابع / Funktion در جاوا اسکریپت مجموعه ای 
      از دستورات است که یک کار را انجام می دهد یا یک مقدار را محاسبه می کند.
        با تعریف یک تابع، می‌توانید یک قطعه از برنامه
        را در یک مقدار «پیچید» کنید و به شما این امکان را می‌دهد
        که آن را هر کجا که به آن عملکرد خاص نیاز دارید،
        بدون نیاز به نوشتن دوباره کد، فراخوانی کنید.
    </p>
    </section>
    <section id="tabe2"><h3>
      تعریف توابع
    </h3>
    <p>
      روش های مختلفی برای تعریف یک تابع در جاوا اسکریپت وجود دارد،
      <br/>اما متداول ترین روش، اعلان تابع است که به عنوان دستور تابع نیز شناخته می شود.
      Syntax

    </p>
    <img src="./images/6.77 photo.PNG" width="450" alt="77">
    <ul>
      <li>
        functionName نام تابع است.
      </li>
      <li>
        پارامترها / parameters نام ورودی هایی هستند که تابع می پذیرد و با کاما از هم جدا شده اند. 
      </li>
      <li>
        بلوک کد داخل پرانتزهای فرفری {} هنگام فراخوانی تابع اجرا می شود.
      </li>
      <h5>
        مثال
      </h5>
    </ul>
    <img src="./images/6.78 photo.PNG" width="450" alt="78">
    </section>
    <section id="tabe3"><h3>
      فراخوانی توابع
    </h3>
    <p>
      پس از تعریف یک تابع، می توانید آن را با نام آن و به دنبال پرانتز فراخوانی کنید. <br/>
      <h5>
      مثال
      </h5> 
    </p>
    <img src="./images/6.79 photo.PNG" width="450" alt="79">
    </section>

    <section id="tabe4"><h3>
      پارامترهای تابع و آرگومان ها
    </h3>
    <p>
      پارامترها متغیرهایی هستند که به عنوان مکان نگهدار برای مقادیر ارسال شده
        به تابع عمل می کنند. مقادیر واقعی ارائه شده هنگام فراخوانی یک تابع به عنوان آرگومان شناخته می شوند. <br/>
        <h5>
        مثال
        </h5>
    </p>
    <img src="./images/6.80 photo.PNG" width="450" alt="80">
    </section>
    <section id="tabe5"><h3>
      محدوده عملکرد - Function Scope
    </h3>
    <p>
      محدوده دسترسی متغیرها را تعیین می کند. 
      متغیرهای تعریف شده در داخل یک تابع را نمی توان از خارج از تابع در دسترس قرار داد،
        زیرا تابع یک محدوده محلی برای متغیرهای خود ایجاد می کند. <br/>
        <h5>
        مثال
        </h5>
    </p>
    <img src="./images/6.81 photo.PNG" width="450" alt="81">
    <div>   
       <img src="./images/6.82 photo.PNG" width="450" alt="82">
</div>
    <p>
      با غواصی در قلمرو توابع جاوا اسکریپت، با یک مفهوم محوری مواجه می شویم: محدوده.
        این مفهوم
        فقط یک جزئیات فنی نیست. نقش مهمی در ساختار و امنیت کد ما دارد. اساساً scope قابلیت مشاهده
        و
        دسترسی متغیرها و توابع را در بخش‌های مختلف کد ما تعریف می‌کند.
    </p>
    </section>
    <section id="tabe6"><h3>
      محدوده عملکرد داخل
    </h3>
    <p>
      هنگامی که یک متغیر یا یک تابع را در یک تابع دیگر اعلام می کنید، 
      آن را در یک فضای بسته و مجزا قرار می دهید
        که به عنوان محدوده تابع شناخته می شود. به این فکر کنید که یک اتاق خصوصی در کد خود
        ایجاد می کنید که در آن هر چیزی که در داخل آن اعلام شده فقط در آن اتاق قابل دسترسی است. <br/>
      این انزوا خودسرانه نیست. اهداف مهمی مانند به حداقل رساندن خطر تداخل نام‌گذاری 
      و محافظت در برابر دستکاری ناخواسته سایر اسکریپت‌ها یا بخش‌هایی از کد انجام می‌شود. 
    </p>
    </section>
    <section id="tabe7"><h3>
      دامنه جهانی
    </h3>
    <p>
      خارج از همه عملکردها، دامنه جهانی قرار دارد. متغیرها و توابع اعلام شده در اینجا 
      از هر بخشی از کد قابل دسترسی هستند. اگرچه این ممکن است راحت به نظر برسد،
        اما یک شمشیر دو لبه است. متغیرهای جهانی را می توان از هر جایی تغییر داد، 
      که به طور بالقوه منجر به رفتار غیرقابل پیش بینی و ردیابی اشکالات سخت می شود.
    </p>
    </section>
    <section id="tabe8"><h3>
      پیمایش درگیری ها و نگرانی های امنیتی
    </h3>
    <p>
      بیایید یک سناریوی گویا 
      را در نظر بگیریم. تصور کنید در حال ادغام دو فایل جاوا اسکریپت مجزا در سند HTML
        خود هستید و هر دو فایل یک تابع و یک متغیر را با نام‌های یکسان اعلام می‌کنند:
    </p>
    <img src="./images/6.83 photo.PNG" width="450" alt="83">
    <p>
      جاوا اسکریپت
    </p>
    <img src="./images/6.84 photo.PNG" width="450" alt="84">
    <p>
      ممکن است قصد فراخوانی تابع greeting() تعریف شده در هر دو اسکریپت باشد،
        اما مدیریت جاوا اسکریپت با دامنه جهانی به این معنی است که فقط اولین مورد قابل دسترسی است و باعث می شود دومی نادیده گرفته شود.
        بعلاوه، تلاش برای تخصیص مجدد متغیر نام در second.js به دلیل اعلام const در first.js خطایی ایجاد می کند.

این نشان می‌دهد که چگونه متغیرها و توابع جهانی می‌توانند منجر به درگیری و عوارض جانبی ناخواسته شوند، به‌ویژه هنگام ادغام چند اسکریپت.

    </p>
    </section>
    <section id="tabe9"><h3>
      قیاس باغ وحش: تصویری در محدوده
    </h3>
    <p>
      تصور کنید ساختار کد ما را با یک باغ وحش مقایسه کنید که در آن هر گونه حیوانی (شیر، گورخر، ببر، پنگوئن) در محوطه خود زندگی می کند. 
      هر محفظه ای شبیه به یک محدوده عملکردی است: حاوی همه چیزهایی است که حیوانات به آن نیاز دارند،
      اما آنها نمی توانند به چیزهای خارج از فضای خود دسترسی داشته باشند یا با آنها تداخل داشته باشند.
      نگهبان باغ وحش، با دسترسی به تمام محوطه ها، مانند محدوده جهانی در کد ما است.

این تنظیمات از هرج و مرج جلوگیری می کند. همانطور که حیواناتی که آزادانه رومینگ می‌کنند و وارد محوطه‌های دیگر می‌شوند منجر به مشکل می‌شوند،
متغیرها و عملکردهایی که از محدوده آنها فرار می‌کنند می‌توانند کد ما را ویران کنند.

    </p>
    </section>
    <section id="tabe10"><h3>
      Best Practices
    </h3>
    <p>
      برای کاهش خطرات مرتبط با گستره جهانی و اطمینان از سازماندهی و ایمن ماندن کد ما، بهترین روش‌ها کپسوله کردن کد در توابع را توصیه می‌کنند. این رویکرد نه تنها از تضاد بین اسکریپت ها جلوگیری می کند، بلکه قابلیت نگهداری و خوانایی کد ما را نیز افزایش می دهد. با سازماندهی مدبرانه کد خود و رعایت مرزهای محدوده، می‌توانیم برنامه‌های کاربردی قوی و کارآمد و عاری از خطرات تعاملات ناخواسته جهانی بسازیم.
    </p>
    </section>
    <section id="tabe11"><h3>
      توابع ناشناس و عبارات تابع - Anonymous Functions and Function Expressions 
    </h3>
    <p>
      یک عبارت تابع شبیه به و دارای همان نحوی / syntax است <br/>که اعلان / declaration تابع است با این تفاوت که نام تابع را می توان حذف کرد و یک تابع ناشناس ایجاد کرد. <br/>عبارات تابع را می توان در متغیرها ذخیره کرد، به عنوان آرگومان به توابع دیگر ارسال کرد و موارد دیگر. <br/>
      <h5>
        مثال 
      </h5>
    </p>
    <img src="./images/6.85 photo.PNG" width="450" alt="85">
    <p>
      تا اینجا ما فقط یک تابع مانند این ایجاد کرده ایم:
    </p>
    <img src="./images/6.86 photo.PNG" width="450" alt="86">
    <p>
      
اما شما همچنین می توانید تابعی ایجاد کنید که نامی نداشته باشد:

    </p>
    <img src="./images/6.87 photo.PNG" width="450" alt="87">
    <p>
      این تابع ناشناس / Anonymous نامیده می شود، زیرا نامی ندارد. <br/> هنگامی که یک تابع انتظار دارد تابع دیگری را به عنوان پارامتر دریافت کند، اغلب توابع ناشناس را مشاهده خواهید کرد. <br/> در این حالت، پارامتر تابع اغلب به عنوان یک تابع ناشناس ارسال می شود.

توجه: این شکل از ایجاد یک تابع به عنوان عبارت تابع نیز شناخته می شود. برخلاف اعلان های تابع، عبارات تابع بالا نمی روند.
به عنوان مثال، فرض کنید <br/>زمانی که کاربر در یک کادر متنی تایپ می کند،<br/> می خواهید کدی را اجرا کنید. برای این کار می توانید تابع addEventListener() کادر متن را فراخوانی کنید. این تابع از شما انتظار دارد که آن را (حداقل) دو پارامتر ارسال کنید:

    </p>
    <ul><li>
            نام رویداد برای گوش دادن، که در این مورد keydown است
    </li>
    <li>
        یک تابع برای اجرا در هنگام وقوع رویداد / event.
    </li>
  </ul>
  <p>
    هنگامی که کاربر کلیدی را فشار می‌دهد، مرورگر تابعی را که ارائه کرده‌اید فراخوانی می‌کند<br/> و پارامتری حاوی اطلاعات مربوط به این رویداد، از جمله کلید خاصی که کاربر فشار داده است، به آن ارسال می‌کند:
  </p>
  <img src="./images/6.88 photo.PNG" width="450" alt="88">
  <p>
    
به جای تعریف یک تابع logKey() جداگانه، می توانید یک تابع ناشناس را به addEventListener():

  </p>
  <img src="./images/6.89 photo.PNG" width="450" alt="89">
  </section>
    <section id="tabe12"><h3>
      توابع پیکان - Arrow Functions
    </h3></section>
    <p>
      ES6 توابع فلش را معرفی کرد، روشی مختصر برای نوشتن توابع در جاوا اسکریپت. <br/>
    توابع پیکان مخصوصاً برای توابع درون خطی و فراخوانی مفید هستند. 
    </p> 
    <div>
        <img src="./images/6.90 photo.PNG" width="450" alt="90">

    </div>
    <p>
      توابع یک مفهوم اساسی در جاوا اسکریپت و به 
      طور کلی برنامه نویسی هستند. آنها به شما کمک می کنند کد خود را در <br/>
      بخش های معنی دار ساختار دهید، کد خود را خشک نگه 
      دارید (خودتان را تکرار نکنید) و کد خود را خواناتر و اشکال <br/>
      زدایی آن آسان تر کنید. درک چگونگی تعریف، فراخوانی و ارسال داده به توابع،
        و همچنین درک مفهوم محدوده، گام <br/>
        های مهمی برای مهارت در جاوا اسکریپت است. همانطور که به عنوان یک توسعه دهنده رشد می کنید، کارکردهایی را <br/>
        خواهید یافت که در نوشتن کدهای کارآمد و قابل نگهداری ضروری هستند.
    </p>
    </section>
    <section id="tabe13"><h3>یک مثال عملی توابع</h3>
      <p>
      بیایید یک مثال عملی بسازیم که نشان می دهد چگونه توابع جاوا اسکریپت با HTML و CSS تعامل دارند و بر دامنه <br/>
        عملکرد و کپسوله کردن کد تأکید می کند. ما یک برنامه وب ساده ایجاد خواهیم کرد که در آن کاربران می توانند نام خود <br/>
        چگونه کپسوله کردن متغیرها در توابع از تضادها جلوگیری می کند و کدهای ماژولار و تمیز را حفظ می کند.را وارد کنند و با کلیک بر روی یک دکمه، یک تبریک شخصی ظاهر می شود. این مثال همچنین نشان می دهد که <br/>

      </p>
    </section>
    <section id="tabe14"><h3>ساختار HTML</h3>
      <p>
        ابتدا ساختار HTML را برای ورودی کاربر و یک دکمه برای راه اندازی تبریک تنظیم می کنیم: 
        
      </p>
      <div>
            <img src="./images/6.91 photo.PNG" width="450" alt="91">

      </div>
      <div>
        <img src="./images/6.92 photo.PNG" width="450" alt="92">

      </div>
    </section>
    <section id="tabe15"><h3>CSS Style</h3>
      <p>
        در مرحله بعد، برای افزایش جذابیت بصری، یک استایل اولیه اضافه کنید:
      </p>
      <img src="./images/6.93 photo.PNG" width="450" alt="93">
      <div>
          <img src="./images/6.94 photo.PNG" width="450" alt="94">

      </div>
      <section id="tabe16"><h3>توابع جاوا اسکریپت</h3>
        <p> اکنون، اجازه دهید عملکرد را با استفاده از جاوا اسکریپت پیاده سازی کنیم. ما منطق خوشامدگویی را در یک تابع <br/>
        محصور می‌کنیم تا محدوده تمیزی داشته باشیم و از تضاد با سایر اسکریپت‌ها یا توابع بالقوه جلوگیری کنیم.
        </p>
        <img src="./images/6.95 photo.png" width="450" alt="95">
        <div>
          <img src="./images/6.96 photo.PNG" width="450" alt="96">
        </div>
        <ol>
        <li>تابع greetUser درون تابع ناشناس ارسال شده به شنونده رویداد DOMContentLoaded کپسوله شده  <br/>
          است. این بدان معنی است که دامنه greetUser به این تابع ناشناس محدود می شود و خطر تداخل نامگذاری با <br/>
          سایر اسکریپت ها یا بخش هایی از کد را کاهش می دهد.
        </li>
        <li>کپسوله‌سازی تابع با تعریف تابع greetUser در پاسخ به تماس شنونده رویداد و نه در محدوده جهانی نش <br/>
          داده می‌شود. این امر دسترسی آن را محدود می کند و کد را امن تر و سازماندهی می کند.
        </li>
        <li>
          متغیرهای greetBtn، nameInput و greetingText در ابتدای اسکریپت برای ارجاع به عناصر خاص <br/>
          در سند HTML تعریف می شوند. این به ما اجازه می دهد تا به راحتی این عناصر را در کد جاوا اسکریپت <br/>
          خود دستکاری کنیم.
        </li>
        <li>
          متد addEventListener در greetBtn به رویداد کلیک گوش می دهد، که تابع greetUser محصور شده <br/>
          را فعال می کند و نشان می دهد که چگونه رویدادها می توانند با منطق تابع کپسوله شده تعامل داشته باشند.
        </li>
        </ol>
        <section id="tabe17"><h3>
        توضیح گام به گام:
        </h3>
        <ul>
        <li>
          HTML Setup: ساختار را با یک فیلد ورودی برای نام، یک دکمه برای راه اندازی تبریک و یک پاراگراف <br/>
          برای نمایش پیام تبریک تعریف می کند.
        </li>
        <li>CSS Styling: یک سبک ساده و کاربر پسند برای قسمت ورودی، دکمه و پاراگراف ارائه می دهد.</li>
        <li>
          منطق جاوا اسکریپت:
          <ul>
            <li>Event Listener برای DOMContentLoaded: اطمینان حاصل می کند که جاوا اسکریپت فقط پس از بارگیری کامل سند HTML اجرا می شود و تضمین می کند که همه عناصر در دسترس هستند.</li>
            <li>Variable Declarations: ارجاع به عناصر HTML را که با آنها تعامل خواهیم داشت شناسایی و ذخیره می کند.</li>
            <li>شنونده رویداد کلیک روی دکمه: شنونده رویداد را به "Greet Me!" دکمه، هنگام کلیک کردن،
                تابع greetUser را فراخوانی می کند</li>
            <li>greetUser Function: این تابع منطق تبریک را کپسوله می کند.
                نام کاربر را از قسمت ورودی بازیابی می کند. اگر نامی ارائه شود، یک تبریک شخصی نمایش داده می شود.
                در غیر این صورت، از کاربر می خواهد که نام خود را وارد کند.</li>
          </ul>
        </li>
        </ul>
        <p>با کپسوله کردن متغیرها و عملکردها در تابع greetUser،
          از تداخل احتمالی با سایر اسکریپت ها جلوگیری می کنیم و ساختار کد به خوبی سازماندهی شده را حفظ می کنیم. 
          این مثال قدرت توابع در ایجاد برنامه های کاربردی وب تعاملی را نشان می دهد
          و اهمیت مدیریت محدوده برای کدهای تمیز و بدون تضاد را برجسته می کند. <br/>
          <h5>نتیجه:</h5>
          <img src="./images/6.97 photo.PNG" width="450" alt="97">
        </p>
          </section>
      </section>

      <section id="meghdar"><h3>
        مقدمه ای بر مقادیر بازگشتی تابع - Function Return Values 
      </h3>
      <p>
        در سفر خود از طریق جاوا اسکریپت، با بلوک‌های سازنده مختلفی مواجه شده‌ایم که هسته اصلی نوشتن برنامه‌های کاربردی و تعاملی وب را تشکیل می‌دهند.
          در این میان، مقادیر بازگشتی تابع به عنوان یک مفهوم محوری است که توابع را با قابلیت خروجی داده‌ها پس از اجرا غنی می‌کند. درک چگونگی مهار این مقادیر بازگشتی برای برنامه نویسی موثر بسیار مهم است، و شما را قادر می سازد از توابع نه تنها به عنوان وسیله ای برای انجام اقدامات، بلکه به عنوان ابزاری برای محاسبه و ارسال داده ها نیز استفاده کنید.
          این بحث شما را از طریق تفاوت‌های ظریف مقادیر بازگشتی تابع، کاربردهای آن‌ها و نحوه ایجاد توابعی که داده‌های معنادار را برمی‌گردانند، راهنمایی می‌کند. <br/>
          قبل از شروع این کاوش، باید درک اساسی از HTML، CSS، و اصول اولیه جاوا اسکریپت،
            از جمله دانش مقدماتی از توابع داشته باشید. 
            هدف ما در اینجا این است که درک شما را از اینکه چگونه توابع می‌توانند مقادیر را برگردانند 
            و چگونه می‌توان از این مقادیر بازگشتی در کد جاوا اسکریپت استفاده کرد، عمیق‌تر کرد.
      </p>
    </section>
    <section id="meghdar1"><h3>
      ارزش های بازگشتی / Return Values دقیقاً چیست؟
    </h3>
    <p>
      به بیان ساده، مقادیر بازگشتی، نتایجی هستند که توسط توابع پس از تکمیل آنها تولید می شوند.
        در حالی که برخی از توابع برای اجرای وظایف بدون خروجی مستقیم طراحی شده‌اند،
        برخی دیگر مقادیر خاصی را محاسبه
        و برمی‌گردانند. این مقادیر بازگشتی می‌توانند فوق‌العاده همه‌کاره باشند و به عنوان ورودی‌های 
        مستقیم برای محاسبات بیشتر یا به‌عنوان داده‌هایی برای پردازش و نمایش در برنامه شما عمل کنند. <br/>
      یک مثال اساسی را در نظر بگیرید که مقدار بازگشتی یک تابع را در عمل نشان می دهد:
    </p>
    <img src="./images/6.98 photo.PNG" width="450" alt="98">
    <p>
      در این قطعه، تابع calculateArea مساحت یک مستطیل را با توجه به عرض و ارتفاع آن محاسبه می کند و سپس نتیجه را برمی گرداند. این مقدار بازگشتی در متغیر roomArea ذخیره می‌شود و متعاقباً در کنسول ثبت می‌شود.
    </p>
  </section>
  <section id="meghdar2"><h3>
    استفاده از مقادیر بازگشتی در توابع سفارشی
  </h3>
  <p>
    برای فعال کردن یک تابع برای برگرداندن یک مقدار، کلمه کلیدی بازگشتی را به همراه مقدار یا عبارتی که می‌خواهید برگردانید وارد کنید. این مکانیسم نه تنها برای توابع داخلی مانند Array.prototype.map یا String.prototype.replace محفوظ است، بلکه برای تعریف توابع سفارشی نیز در اختیار شماست. <br/>
    بیایید تابع drawCircles را بررسی کنیم که برای پر کردن یک بوم با تعداد مشخصی از دایره‌های تصادفی طراحی شده است:
  </p> <img src="./images/6.99 photo.PNG" width="450" alt="99"><br/>
  در این مثال، تابع getRandom یک عدد تصادفی تا حداکثر مقدار مشخص شده تولید می کند و آن را برمی گرداند. هنگام ترسیم دایره ها، هر فراخوانی به getRandom مقداری را برمی گرداند که برای تعیین موقعیت و اندازه دایره استفاده می شود.
  </section>
  <section id="meghdar3"><h3>
    کاربرد دنیای واقعی: تحلیل اعداد تعاملی
  </h3>
  <p>
    یک ابزار وب ساده را تصور کنید که در آن کاربران یک عدد را وارد می‌کنند و در پاسخ، برنامه ویژگی‌های مختلف ریاضی آن عدد را نمایش می‌دهد (به عنوان مثال، مربع، مکعب، وضعیت اول). با استفاده از مقادیر بازگشتی، می توانید توابعی را پیاده سازی کنید که این ویژگی ها را محاسبه کرده و سپس از داده های برگشتی برای به روز رسانی پویا UI استفاده کنید.
  </p> 
  <img src="./images/6.100 photo.PNG" width="450" alt="100">
  <div>
    <img src="./images/6.101 photo.PNG" width="450" alt="101" width="450">
  </div>
  
  <img src="./images/6.102 photo.PNG" width="450" alt="102"> <br/>
  <h5>نتیجه‌:</h5>
  <img src="./images/6.103 photo.PNG" width="450" alt="103">
</section>
<section id="meghdar4"><h3>
  نتیجه‌گیری: ارزش‌های بازده
  </h3><p>
  توابع در جاوا اسکریپت دنباله ای از دستورالعمل ها نیستند. آنها ساختارهای قدرتمندی هستند که می توانند
  داده ها را محاسبه و ارسال کنند. از طریق مقادیر بازگشتی، توابع به اجزای جدایی ناپذیر منطق کد شما تبدیل می شوند، که قادر به انجام محاسبات و 
  ارائه نتایج در هر کجا که لازم است می شوند. چه در حال دستکاری داده ها، به روز رسانی DOM یا اجرای الگوریتم های پیچیده باشید،
    درک و استفاده از مقادیر بازگشتی تابع به طور قابل توجهی مهارت برنامه نویسی جاوا اسکریپت شما را افزایش می دهد. <br/>
    همانطور که به سفر خود در جاوا اسکریپت ادامه می دهید،
    مقادیر بازگشتی را در زمینه های مختلف آزمایش کنید و مشاهده کنید که چگونه می توانند کد شما را کارآمدتر و ماژولار کنند.
      به یاد داشته باشید، تمرین و کاوش کلید تسلط بر این مفاهیم است.</p></section>

</section>

</section>

<section id="roydad"><h3>
  مقدمه ای بر رویدادهای جاوا اسکریپت - Events in JS
</h3>
<p>
  هدف این مقدمه روشن کردن مفهوم رویدادها در جاوا اسکریپت، به طور خاص بر رفتار آنها در مرورگرهای وب است. اگرچه این یک کاوش جامع نیست، اما موارد ضروری را که در این مقطع باید بدانید را پوشش می دهد.
</p>
</section>
<section id="roydad1"><h3>
یک رویداد دقیقاً چیست؟
</h3>
<p>
در حوزه برنامه نویسی، به ویژه در جاوا اسکریپت،
رویدادها به معنای اعمال یا رخدادهایی هستند که توسط سیستم شناسایی می شوند 
و به کد شما اجازه می دهند به صورت پویا پاسخ دهند. به عنوان مثال، هنگامی که کاربر روی دکمه صفحه وب کلیک می کند، ممکن است یک هشدار نمایش داده شود یا محتوا را به عنوان یک واکنش تغییر دهید. 
رویدادها در مرورگر رخ می‌دهند که اغلب با عناصر خاصی (مانند یک دکمه یا فرم)، خود سند HTML یا پنجره مرورگر مرتبط هستند. <br/>
نمونه‌هایی از رویدادها عبارتند از تعاملات کاربر مانند کلیک‌ها،
  شناور کردن، یا فشار دادن کلید. اتمام بارگذاری صفحه وب؛ فرم های ارسالی؛ و پخش رسانه ها مجموعه گسترده ای از رویدادهای ممکن به این معنی است که چشم انداز غنی برای بهبود تجربه کاربر پویا وجود دارد.
  برای مدیریت یک رویداد،
    یک کنترل کننده رویداد را به آن متصل می کنید. این یک قطعه کد است، معمولاً یک تابع جاوا اسکریپت که شما نوشته اید، که در پاسخ به رویداد اجرا می شود. این فرآیند به عنوان ثبت کنترل کننده رویداد شناخته می شود. <br/>
    مدیریت یک رویداد کلیک: یک تصویر <br/>
    یک صفحه وب را با یک دکمه ساده در نظر بگیرید:
    <ul>
    <li>
("document.querySelector("button دکمه را از سند انتخاب می کند.
</li>
    <li>addEventListener یک کنترل کننده رویداد را برای رویداد "کلیک" متصل می کند.</li>

    <li>با کلیک روی این تابع، رنگ پس‌زمینه بدنه به رنگ تصادفی تغییر می‌کند.</li>
    </ul>
        </p>
        </section>
      <section id="roydad2"><h3>استفاده از addEventListener()</h3>
        <p>
          متد addEventListener () روش ترجیحی برای پیوست کردن کنترل کننده رویداد به عناصر است. 
          این اجازه می دهد تا انعطاف پذیری بیشتری داشته باشید، 
          از جمله توانایی اتصال چندین کنترل کننده رویداد به یک رویداد واحد و
            استفاده از ضبط و حباب کردن رویداد (در ادامه در مورد این موارد بیشتر توضیح خواهیم داد). <br/>
            <h5>مثال با addEventListener():</h5>
            <img src="./images/6.104 photo.PNG" width="450" alt="104">
            <div>
             <img src="./images/6.105 photo.PNG" width="450" alt="105">
            </div>
            <ul>
            <li>
              
تابع changeColor برای تغییر رنگ پس زمینه تعریف شده است.
</li>
            <li>سپس به عنوان یک کنترل کننده رویداد برای رویداد کلیک دکمه ثبت می شود.</li>
            </ul>
            
        </p>
        </section>
        <section id="roydad3"><h3>
          گسترش افق رویداد
        </h3>
        <p>
          فراتر از کلیک ها، عناصر می توانند رویدادهای مختلفی را تحریک کنند. با مشاهده تغییرات تعامل، با جایگزین کردن «کلیک» با رویدادهایی مانند «mouseover»، «focus» یا «dblclick» در کدتان آزمایش کنید.
        </p></section>

        <section id="roydad4"><h3>حذف شنوندگان رویداد</h3>
          <p>همانطور که می توانید کنترل کننده های رویداد را با addEventListener() ضمیمه کنید، می توانید آنها را با removeEventListener() حذف کنید. این می تواند برای مدیریت حافظه و عملکرد در برنامه های پیچیده تر بسیار مهم باشد.</p>
        </section>
        <section id="roydad5"><h3>انتشار رویداد: حباب زدن و گرفتن</h3><p>
          انتشار رویداد در DOM می تواند به دو صورت اتفاق بیفتد: حباب و ضبط. به‌طور پیش‌فرض، رویدادها از عنصر هدف تا ریشه درخت سند حباب می‌شوند و مکانیسم‌هایی مانند تفویض رویداد را امکان‌پذیر می‌کنند. گرفتن عکس برعکس است، جایی که رویداد از ریشه به سمت عنصر هدف حرکت می کند.
        </p></section>
        <section id="roydad6"><h3>قدرت نمایندگی رویداد</h3><p>تفویض رویداد از حباب رویداد برای تنظیم یک شنونده رویداد بر روی یک عنصر والد استفاده می کند که می تواند رویدادهای چند فرزند را مدیریت کند. برای مدیریت رویدادهای مشابه در بسیاری از عناصر کارآمد است.</p></section>
            <section id="roydad7"><h3>رویدادهای فراتر از صفحه وب</h3><p>در حالی که این بحث بر رویدادهای وب متمرکز است، شایان ذکر است که مدل رویداد جاوا اسکریپت در محیط‌های مختلف، مانند Node.js یا برنامه‌های افزودنی مرورگر، متفاوت است. هر زمینه ممکن است ویژگی های مدیریت رویداد منحصر به فردی داشته باشد.</p>
          <p>درک رویدادها و مدیریت آنها برای توسعه وب پویا بسیار مهم است. 
            همانطور که پیشرفت می کنید، به یاد داشته باشید که رویدادها شکاف بین محتوای ثابت و تجربیات تعاملی را پر می کنند. این دانش بنیادی 
            از برنامه های کاربردی و تعاملات پیچیده تری که در آینده توسعه خواهید داد پشتیبانی می کند.</p></section>
            <section id="roydad8"><h3>سناریوی عملی: گالری تصاویر تعاملی</h3><p>
              در این سناریو، یک گالری عکس تعاملی ساده ایجاد خواهیم کرد. هنگامی که کاربر روی یک تصویر کوچک کلیک می کند، تصویر در اندازه کامل در یک منطقه مشخص نمایش داده می شود. این مثال مفهوم تفویض رویداد را نشان می‌دهد و به ما امکان می‌دهد یک شنونده رویداد واحد را به عنصر اصلی تصاویر کوچک متصل کنیم تا شنوندگان جداگانه برای هر تصویر کوچک.
            </p></section>
            <section id="roydad9"><h3>ساختار HTML:</h3>
            <img src="./images/6.106 photo.PNG" width="450" alt="106">
            <div>
                <img src="./images/6.107 photo.PNG" width="450" alt="107">

            </div>
        <ul><li>بخش #gallery شامل تصاویر کوچک از تصاویر است.</li>
        <li>وقتی روی یک تصویر کوچک کلیک می‌شود، #main-image div تصویر را در اندازه کامل نمایش می‌دهد.</li>
        <li>فایل script.js حاوی کد جاوا اسکریپت ما برای مدیریت رویدادهای کلیک خواهد بود.</li></ul></section>
        <section id="roydad10"><h3>CSS (style.css) </h3>
          <img src="./images/6.108 photo.PNG" width="450" alt="108">
          
          <ul><li>گالری به عنوان یک ظرف انعطاف پذیر برای چیدمان آسان نمایش داده می شود.</li>
          <li>تصاویر بندانگشتی دارای مکان نما هستند که نشان می دهد قابل کلیک هستند و با نگه داشتن ماوس کمی بزرگتر می شوند.</li>
          <li>تصویر اصلی در مرکز قرار دارد و 90٪ از عرض ظرف را اشغال می کند.</li></ul></section>
          <section id="roydad11"><h3>جاوا اسکریپت (script.js):</h3>
          <img src="./images/6.109 photo.PNG" width="450" alt="109">
        <h5>توضیحات:</h5>
      <ul><li>ما یک شنونده رویداد را به بخش #gallery متصل می کنیم که به رویدادهای کلیک گوش می دهد.</li>
      <li>هنگامی که یک رویداد کلیک فعال می شود، بررسی می کنیم که آیا عنصر کلیک شده دارای یک کلاس از تصویر کوچک است یا خیر.</li>
      <li>اگر چنین است، ویژگی src آن را تغییر می‌دهیم تا به تصویر با اندازه کامل اشاره کند (با فرض اینکه تصاویر با اندازه کامل نام‌های مشابهی دارند اما در فهرستی متفاوت قرار دارند یا نامگذاری متفاوتی دارند). این با جایگزینی «تصویر کوچک» با «اندازه کامل» در src تصویر شبیه‌سازی می‌شود.</li>
      <li>سپس src تصویر اصلی به منبع جدید به روز می شود و تصویر در اندازه کامل نمایش داده می شود.
این مثال عملی نحوه استفاده از تفویض رویداد برای مدیریت موثر رویدادها را نشان می‌دهد، به‌ویژه زمانی که با چندین عنصر مشابه مانند گالری تصاویر سروکار دارید.
    </li></ul>
  <img src="./images/6.110 photo.PNG" width="450" alt="110"></section>
      </section>
    </section>
    </section>

    <!-- Chapter 7-->

  <section id="fasl7">
    <h2>مقدمه فصل هفتم: برنامه نویسی شی گرا</h2>
      <section id="shey">
        <h3>(OOP) Object Oriented Programming</h3>
        <p>مطمئناً درک برنامه نویسی شی گرا (OOP) برای درک اینکه چرا و چگونه جاوا اسکریپت ماهیت شی گرا خود را پیاده سازی می کند بسیار مهم است. بیایید به مفهوم OOP و کاربرد آن در جاوا اسکریپت بپردازیم.</p>



    <section id="shey1">
<h2>برنامه‌نویسی شی‌گرا (OOP)</h2>
<p>
برنامه‌نویسی شی‌گرا (OOP) یک الگوی برنامه‌نویسی است که از "اشیاء" برای طراحی برنامه‌های کاربردی و برنامه‌های کامپیوتری استفاده می‌کند. از چندین اصل مانند کپسوله‌سازی، وراثت و چند شکلی برای افزایش خوانایی کد، قابلیت استفاده مجدد و مقیاس‌پذیری استفاده می‌کند.
</p>
<ul>
<li>
  <strong>کپسوله‌سازی / Encapsulation:</strong>
  این اصل داده‌ها (ویژگی‌ها) و روش‌ها (توابع) را که روی داده‌ها کار می‌کنند در واحدهای واحدی به نام «اشیاء» دسته‌بندی می‌کند. دسترسی مستقیم به برخی از اجزای یک شی را محدود می کند، که می تواند از تغییر تصادفی داده ها جلوگیری کند.
</li>
<li>
  <strong>وراثت / Inheritance:</strong>
  این به یک کلاس اجازه می دهد تا ویژگی ها و متدهای کلاس دیگر را به ارث ببرد. ما از آن برای ایجاد یک کلاس جدید استفاده می کنیم که نسخه اصلاح شده یک کلاس موجود است.
</li>
<li>
  <strong>چند شکلی / Polymorphy:</strong>
  این اصل اجازه می دهد تا اشیاء از کلاس های مختلف به عنوان اشیاء یک ابر کلاس مشترک در نظر گرفته شوند. این یک رابط واحد را قادر می سازد تا فرم های مختلف زیرین (انواع داده) را نشان دهد.
</li>
<li>
  <strong>Abstraction:</strong>
  این اصل جزئیات پیاده سازی پیچیده را پنهان می کند و فقط ویژگی های ضروری یک شی را نشان می دهد. این به کاهش پیچیدگی و تلاش برنامه نویسی کمک می کند.
</li>
</ul>
</section>
<section id="shey2">
<h2>چرا جاوا اسکریپت یک زبان شی گرا در نظر گرفته می شود؟</h2>
<p>
جاوا اسکریپت یک زبان برنامه نویسی شی گرا در نظر گرفته می شود زیرا از اصول OOP از طریق نمونه های اولیه و سیستم کلاس خود (معرفی شده در ECMAScript 2015/ES6) پشتیبانی می کند. علیرغم اینکه جاوا اسکریپت مبتنی بر نمونه اولیه است، می توان از روشی شی گرا استفاده کرد.
</p>
<h3>نحوه هماهنگی جاوا اسکریپت با اصول OOP:</h3>
<ul>
<li>
  <strong>اشیاء و نمونه های اولیه:</strong>
  جاوا اسکریپت اساساً در مورد اشیا است. یک شی در جاوا اسکریپت یک موجودیت مستقل با خصوصیات و نوع است. این زبان به جای وراثت کلاسیک از نمونه‌های اولیه استفاده می‌کند، اما با تنظیم نمونه اولیه (یعنی شی والد) یک شی به شی دیگر، برنامه‌نویسی شی‌گرا را امکان‌پذیر می‌کند.
</li>
<li>
  <strong>کلاس ها (ES6):</strong>
  جاوا اسکریپت دستور کلاسی را برای ایجاد اشیا و مدیریت وراثت معرفی کرد. زیر سرپوش، کلاس ها در جاوا اسکریپت فقط توابع ویژه هستند. سینتکس کلاس یک مدل ارثی شی گرا جدید به جاوا اسکریپت معرفی نمی کند. این فقط قند نحوی بر وراثت مبتنی بر نمونه اولیه موجود است و استفاده از آن را آسان‌تر می‌کند.
</li>
<li>
  <strong>Encapsulation:</strong>
  جاوا اسکریپت با ایجاد توابع و متغیرهایی که از خارج از تابع کپسوله‌سازی قابل دسترسی نیستند، از کپسوله‌سازی پشتیبانی می‌کند. افزوده‌های اخیر «let» و «const» برای محدوده بلوک و استفاده از بسته‌ها، این قابلیت را افزایش می‌دهد.
</li>
<li>
  <strong>وراثت:</strong>
  از طریق زنجیره‌سازی نمونه اولیه، اشیاء جاوا اسکریپت ویژگی‌هایی را از اشیاء دیگر به ارث می‌برند و به طور موثر به یک نوع شی اجازه می‌دهد تا متدها و ویژگی‌ها را از دیگری به ارث ببرد.
</li>
<li>
  <strong>چند شکلی:</strong>
  جاوا اسکریپت از چندشکلی پشتیبانی می کند. به عنوان مثال، یک تابع را می توان بر روی اشیاء مختلف به ارث رسیده از یک والد یا رابط استفاده کرد.
</li>
</ul>
<p>
درک اصول OOP زمینه ای را به این موضوع می دهد که چرا جاوا اسکریپت بر اشیاء تأکید دارد. در جاوا اسکریپت، تقریباً همه چیز یک شی است، از انواع داده های اولیه (زمانی که مانند اشیاء استفاده می شوند) تا ساختارهای داده پیچیده تر. جاوا اسکریپت از اشیاء برای ساخت برنامه های کاربردی انعطاف پذیرتر و مقیاس پذیرتر استفاده می کند و با الگوی OOP برای ساختار برنامه ها همسو می شود.
</p>
</section>
<section id="shey3">
<h2>اشیاء جاوا اسکریپت - Object in JS</h2>
<p>
جاوا اسکریپت به عنوان یک زبان چند پارادایم می ایستد و دارای ویژگی های فراوانی است که به آن تطبیق پذیری برای مقابله با طیف گسترده ای از وظایف می دهد. محور قابلیت های آن مفهوم اشیا است. این عنصر اساسی نه تنها ساختارهای خود زبان، مانند آرایه‌ها و توابع را زیربنا می‌دهد، بلکه به گستره وسیعی از APIهای مرورگر که بر روی جاوا اسکریپت ساخته شده‌اند نیز قدرت می‌دهد.
</p>
<p>
علاوه بر این، این زبان به شما این امکان را می دهد که اشیاء سفارشی خود را بسازید، در نتیجه یک راه ساده برای بسته بندی توابع و متغیرهای مرتبط در واحدهای منسجم فراهم می کند. این اشیاء دارای اهداف دوگانه هستند، هم به عنوان محفظه های کارآمد برای داده ها و هم به عنوان مکانیسم هایی برای محصور کردن عملکردها عمل می کنند.
</p>
<p>
با کاوش عمیق تر در جاوا اسکریپت، درک ماهیت شی گرا زبان ضروری می شود.
</p>
<p>
این فصل به ابهام زدایی از اشیاء در جاوا اسکریپت اختصاص یافته است و کاوش کاملی در مورد تئوری پشت اشیاء و نحو مورد استفاده برای دستکاری آنها ارائه می دهد. از طریق این سفر، هدف ما این است که شما را با دانش برای ایجاد و استفاده مؤثر از اشیاء خود مسلح کنیم.
</p>
</section>


<section id="shey4">
<h2>درک ماهیت اشیاء جاوا اسکریپت</h2>
<p>
    اشیاء در جاوا اسکریپت شبیه صندوقچه های گنج هستند که ملغمه ای از داده ها و عملکردها را ذخیره می کنند. این مجموعه ها شامل عناصر مختلفی هستند که هر کدام با یک نام منحصر به فرد برچسب گذاری شده اند و ارزش یا عملکرد خود را دارند. این تجمیع ستون فقرات آنچه را که ما به عنوان اشیا می شناسیم تشکیل می دهد - ساختاری که در سازماندهی و مدیریت داده ها در جاوا اسکریپت نقش اساسی دارد.
</p>
</section>

<section id="shey5">
<h2>پیش نیازها</h2>
<ul>
<li>
    درک اساسی از HTML و CSS.
    آشنایی با مفاهیم اصلی جاوا اسکریپت، همانطور که در مراحل اولیه و بلوک های سازنده زبان مطرح شد.
</li>
</ul>
</section>

<section id="shey6">
<h2>آناتومی اشیاء جاوا اسکریپت</h2>
<p>
    سناریویی را در نظر بگیرید که در آن یک کتابخانه دیجیتال برای فهرست‌نویسی کتاب‌ها ایجاد می‌کنیم. هر کتاب در این کتابخانه را می توان به عنوان یک شی نشان داد، جزئیاتی مانند عنوان، نویسنده و روشی برای نمایش مختصر این اطلاعات را در بر می گیرد.
</p>
<p>خلق اولین شی ما: یک کتاب</p>
<img src="/images/7.1 photo.png" width="450" alt="" />
</section>

<section id="shey7">
<h2>بینش های کلیدی</h2>
<p>
    اشیاء در داخل پرانتزهای مجعد {} تعریف می‌شوند و هر عضو (یا ویژگی) از یک الگوی کلیدی پیروی می‌کند: مقدار.
    توابع درون اشیا، که به عنوان متدها شناخته می شوند، شی را قادر می سازند تا با داده های خود تعامل داشته باشد.
    این کلمه کلیدی دسترسی به اعضای خود شی را فراهم می کند.
</p>
</section>

<section id="shey8">
<h2>دسترسی به ویژگی‌های شی: نماد نقطه و براکت</h2>
<p>برای بازیابی یا اصلاح ویژگی‌های شی کتاب‌های خود، می‌توانید از دو نماد اصلی استفاده کنید:</p>
php
Copy code
<ul>
<li>
    <strong>Dot Notation:</strong> استفاده از نماد نقطه (مانند <code>book.title</code>) یک رویکرد ساده برای دسترسی به ویژگی‌ها ارائه می‌دهد.
</li>
<li>
    <strong>علامت گذاری براکت:</strong> استفاده از علامت گذاری براکت (مانند <code>کتاب["نویسنده"]</code>) زمانی مفید است که نام ویژگی‌ها پویا یا در متغیرها ذخیره شده باشد.
</li>
</ul>
</section>
<section id="shey9">
<h2>سازندگان: طرح‌بندی اشیاء</h2>
<p>هنگامی که کتابخانه دیجیتال ما گسترش می‌یابد، ایجاد دستی یک شی برای هر کتاب غیرعملی می‌شود. در اینجاست که سازندگان وارد عمل می‌شوند و به‌عنوان نقشه‌ای برای ایجاد چندین شی از یک نوع عمل می‌کنند.</p>
<img src="./images/7.2 photo.png" width="450" alt="7.2" />
</section>
<section>
<section id="shey10">
<h2>سناریوی عملی: ایجاد رابط کتابخانه دیجیتال</h2>
<p>برای تحکیم درک خود، بیایید شروع به ایجاد یک رابط کاربری ساده برای کتابخانه دیجیتال خود کنیم. این رابط به کاربران امکان می دهد کتاب هایی را به مجموعه اضافه کرده و آنها را مشاهده کنند.</p>
<section id="shey11">
<p>ساختار HTML</p>
<img src="./images/7.3 photo.png" width="450" alt="7.3" />

</section>
<section id="shey12">
<p>CSS Style
</p>
<img src="./images/7.4 photo.png" width="450" alt="7.4" />
</section>
<section id="shey13">
<p>JavaScript: حیات بخشیدن به کتابخانه</p>
<img src="./images/7.5 photo.png" width="450" alt="7.5" />
<div>
  <img src="./images/7.5- photo.png" width="450" alt="7.5-">
</div>
<div>
  <img src="./images/7.6 photo.png" width="450" alt="7.6" />
</div>
<ul>
<li>سازنده Book، طرح اولیه را برای هر شیء کتاب تعریف می کند.</li>
<li>تابع addBookToLibrary ورودی فرم را می گیرد، یک شی کتاب جدید ایجاد می کند و آن را به آرایه کتابخانه اضافه می کند.</li>
<li>تابع displayLibrary روی آرایه کتابخانه تکرار میشود و عناصری را برای هر کتاب ایجاد و نمایش می دهد.</li>
</ul>
<p>این مثال عملی نشان می‌دهد که چگونه اشیا می‌توانند مدیریت داده‌ها و عملکردهای مرتبط را ساده‌سازی کنند و یک رویکرد ساختاریافته برای چالش‌های برنامه‌نویسی ارائه دهند.</p>
<p>نتیجه:
 <img src="./images/7.7 photo.png" width="450" alt="7.7">
</p>

</section>

<section id="aval">
<h3>نمونه های اولیه / Prototype</h3>
<p>درک مفهوم نمونه های اولیه / Prototype برای تسلط بر جاوا اسکریپت ضروری است، زیرا در قلب مکانیسم وراثت شی جاوا اسکریپت قرار دارد. در اینجا، نمونه‌های اولیه، نقش زنجیره‌های نمونه اولیه و روش‌های تنظیم نمونه اولیه یک شی را بررسی می‌کنیم.</p>


</section>
<section id="aval1">
<h2>مقدمه ای بر نمونه های اولیه اشیاء
</h2>
<p>در جاوا اسکریپت، نمونه های اولیه نقش محوری در ارث بردن خواص و متدها از یک شی به شی دیگر دارند. این پایه و اساس وراثت مبتنی بر نمونه اولیه جاوا اسکریپت است و آن را از وراثت کلاسیک موجود در زبان هایی مانند جاوا یا C++ متمایز می کند.</p>
<section id="aval2" >
<h3>ملزومات زنجیره های اولیه
</h3>
<p>تصور کنید یک شی ساده در جاوا اسکریپت به صورت زیر ایجاد کنید:
  </p>
  <img src="./images/7.8 photo.png" width="450" alt="7.8">


<p>هنگام فراخوانی myObject.greet();، پیامی دریافت می کنید: "Greetings from Madrid". پس از بررسی myObject در کنسول، نه تنها City و Greet بلکه تعداد زیادی از ویژگی های دیگر مانند toString، valueOf، و به ویژه، __proto__ را متوجه خواهید شد.</p>
<p>این ویژگی‌های اضافی بخشی از نمونه اولیه myObject هستند - یک شی داخلی که myObject متدها و ویژگی‌ها را از آن به ارث می‌برد. این وراثت بخشی از چیزی است که به عنوان زنجیره اولیه شناخته می شود.</p>
<img src="./images/7.9 photo.png" width="450" alt="7.9">
<div>
  <img src="./images/7.10 photo.png" width="450" alt="7.10">

</div>
</section>
<section id="aval3">
<h3>درک وراثت نمونه اولیه
</h3>
<p>هر شی جاوا اسکریپت یک نمونه اولیه دارد. نمونه اولیه خود یک شی است و می تواند نمونه اولیه خود را داشته باشد و یک "زنجیره نمونه اولیه" ایجاد کند. این زنجیره تا رسیدن به یک نمونه اولیه با نول به عنوان نمونه اولیه خود ادامه می یابد و پایان زنجیره را مشخص می کند.</p>
<p>برای مثال برای دیدن این زنجیره:
</p>
<img src="./images/7.11 photo.png" width="450" alt="7.11">

<p>این نشان می دهد که نمونه اولیه myObject Object.prototype است، نمونه اولیه که همه اشیا به طور پیش فرض از آن ارث می برند.</p>


</section>

</section>
</section>

<section id="aval4">
<h3>ویژگی های سایه زدن - Shadowing Properties
</h3>
<p>چه می شود اگر یک شی و نمونه اولیه آن دارای ویژگی هایی با نام یکسان باشند؟ ویژگی خود شی، ویژگی نمونه اولیه را تحت الشعاع قرار می دهد. این به عنوان سایه مالکیت شناخته می شود.</p>
<section id="aval5">
<h3>تنظیم نمونه اولیه یک شی </h3>
<p>برای تنظیم صریح نمونه اولیه یک شی، جاوا اسکریپت مکانیسم هایی مانند Object.create() و توابع سازنده را ارائه می دهد.</p>
<img src="./images/7.12 photo.png" width="450" alt="7.12">
<div>
  <img src="./images/7.13 photo.png" width="450" alt="7.13">
</div>
<p>در اینجا Object.create() یک شی جدید به نام carl ایجاد می کند که نمونه اولیه آن personPrototype است.</p>
</section>
</section>


<section id="aval6">
<h3>استفاده از سازندگان  -Utilizing Constructors </h3>
<p>توابع سازنده به شما این امکان را می دهند که نمونه اولیه را برای تمام نمونه های ایجاد شده از سازنده تعریف کنید.</p>
<img src="./images/7.14 photo.png"  width="450"    alt="7.14">
<p>
در این مثال، تمام نمونه‌های Person از Person.prototype ارث می‌برند و روش‌های مشترک مانند greet را فعال می‌کنند.
</p>

</section>
<section id="aval7">
<h3>نمونه های اولیه: ستون فقرات اشیاء جاوا اسکریپت
</h3>
<p>از طریق زنجیره‌های نمونه اولیه، جاوا اسکریپت به ارث می‌رسد و به اشیا اجازه می‌دهد تا عملکردها را به طور موثر به اشتراک بگذارند و گسترش دهند. این سیستم زیربنای ویژگی های شی گرا زبان است و توسعه دهندگان را قادر می سازد تا ساختارهای کد پیچیده و مدولار را بسازند.</p>
<p>درک نمونه‌های اولیه و زنجیره‌های آن‌ها گامی به سوی تسلط بر رویکرد پویا و انعطاف‌پذیر جاوا اسکریپت به اشیا و وراثت است و زمینه را برای کاوش در مفاهیم برنامه‌نویسی شی گرا عمیق‌تر در زبان فراهم می‌کند.</p>
<p>بیایید یک مثال عملی را بررسی کنیم که وراثت نمونه اولیه جاوا اسکریپت را با یک برنامه وب کوچک نشان می دهد - یک رابط کاربری ساده که به کاربران اجازه می دهد با اشیایی که اشکال هندسی را نشان می دهند تعامل داشته باشند. این مثال شامل ایجاد یک سازنده شکل اولیه و گسترش آن برای ایجاد انواع خاصی از اشکال است.</p>
<sectin id="aval8">
<h3>سناریو: انتخابگر شکل</h3>
<p>برنامه وب ما به کاربران این امکان را می دهد که یک شکل را از منوی کشویی انتخاب کنند و سپس با استفاده از نمونه های اولیه شی جاوا اسکریپت، ویژگی های خاص شکل انتخاب شده، مانند مساحت و محیط را نمایش دهند.</p>
<section id="aval9">
<h4>ساختار HTML
</h4>
<p>ابتدا HTML را با یک کشویی برای انتخاب شکل و بخشی برای نمایش خصوصیات شکل تنظیم می کنیم.</p>
<img src="./images/7.15 photo.png" width="450" alt="7.15">
<div>
  <img src="./images/7.16 photo.png" width="450" alt="7.16">

</div>
</sectin>
<sectin id="aval10">
<h3>استایل CSS
</h3>
<p>در مرحله بعد، ما برخی از استایل های اولیه را اضافه می کنیم تا رابط کاربری خود را از نظر بصری جذاب تر کنیم.
</p>
<img src="./images/7.17 photo.png" width="450" alt="7.17">

</sectin>
<sectin id="aval11">
<h3>منطق جاوا اسکریپت
</h3>
<p>اکنون، سازنده‌های شکل و روش‌های نمونه اولیه را تعریف می‌کنیم، سپس شنونده رویداد را برای انتخاب شکل سیم‌کشی می‌کنیم.
</p>
<img src="./images/7.18 photo.png" width="450" alt="7.18">
<div>
  <img src="./images/7.19 photo.png" width="450" alt="7.19">

</div>
<div>
  <img src="./images/7.19- photo.png" width="450" alt="7.19-">

</div>
<img src="./images/7.20 photo.png" width="450" alt="7.20">

<p>این کد جاوا اسکریپت نحوه استفاده از وراثت نمونه اولیه را برای گسترش یک سازنده شکل پایه با انواع شکل های خاص مانند دایره و مربع نشان می دهد. از روش Object.create برای تنظیم نمونه اولیه سازنده های مشتق شده استفاده می کند و اطمینان حاصل می کند که ویژگی سازنده به تابع سازنده صحیح برمی گردد.
</p>
<p>پس از انتخاب یک شکل، شیء شکل مربوطه را نمونه سازی می کند و مساحت و محیط آن را در #shapeInfo div نمایش می دهد. این مثال قدرت و انعطاف‌پذیری سیستم نمونه اولیه جاوا اسکریپت را در یک سناریوی عملی نشان می‌دهد و استفاده مجدد و گسترش کد را تسهیل می‌کند.
</p>
</sectin>
<sectin id="aval12">
<h3>گسترش مثال انتخاب شکل
</h3>
<p>بیایید مثال انتخاب شکل را گسترش دهیم تا مفید بودن کلاس‌ها (یا در مثال قبلی، توابع سازنده که مشابه کلاس‌ها عمل می‌کنند) را برای ایجاد نمونه‌های جدید و گسترش برنامه‌مان بیشتر نشان دهیم.
</p>

</sectin>
</section>
<section id="aval13">
<h3>سناریوی اضافی: ایجاد شکل پویا
</h3>
<p>فرض کنید می‌خواهیم برنامه‌مان را ارتقا دهیم تا به کاربران اجازه دهیم ابعاد یک دایره یا مربع را وارد کنند و به صورت پویا آن شکل را ایجاد کنند و ویژگی‌های آن را نمایش دهند.
</p>
<section id="aval14">
<h3>گسترش HTML
</h3>
<p>فیلدهای ورودی را به HTML خود اضافه می کنیم تا به کاربران اجازه دهیم ابعاد شکل انتخابی خود را وارد کنند.
</p>
<img src="./images/7.21 photo.png" width="450" alt="7.21">
<div>
  <img src="./images/7.22 photo.png" width="450" alt="7.22">

</div>

</section>
<section id="aval15">
<h3>اصلاح جاوا اسکریپت
</h3>
<p>ما جاوا اسکریپت خود را تغییر می دهیم تا ورودی ابعاد را مدیریت کند و به صورت پویا اشکالی با اندازه های تعریف شده توسط کاربر ایجاد کنیم.
</p>
<img src="./images/7.23 photo.png" width="450" alt="7.23">
<div>
<img src="./images/7.24- photo.png" width="450" alt="7.24-">

</div>
<div>
  <img src="./images/7.25 photo.png" width="450" alt="7.25">

</div>
<div>
  <img src="./images/7.25- photo.png" width="450" alt="7.25-">

</div>
<img src="./images/7.26 photo.png" width="450" alt="7.26">


</section>
</section>

<section id="mofid">
<h3>چرا توابع/کلاس های سازنده مفید هستند؟
</h3>
<ul>
<li>استفاده مجدد و کارایی کد: با تعریف یک سازنده Shape عمومی و سازنده های خاص مانند Circle و Square، می توانیم چندین نمونه از این اشکال را بدون تکرار کد ایجاد کنیم. هر نمونه شکل جدید به طور خودکار به روش های تعریف شده در سازنده و نمونه اولیه خود دسترسی خواهد داشت.
</li>
<li>مقیاس پذیری: اگر تصمیم به معرفی یک شکل جدید مانند مثلث داشته باشیم، می توانیم به سادگی بدون تغییر شکل های موجود، سازنده جدیدی برای آن تعریف کنیم. این باعث می شود برنامه ما به راحتی گسترش یابد.
</li>
<li>قابلیت نگهداری: با ویژگی ها و روش های محصور شده در سازنده ها و نمونه های اولیه، نگهداری و به روز رسانی کد آسان تر است. به عنوان مثال، تغییرات در نمونه اولیه Circle، به طور خودکار برای همه نمونه های Circle اعمال می شود.</li>
<li>سازماندهی: سازنده ها و نمونه های اولیه به سازماندهی کد مربوط به اشیاء خاص کمک می کنند و آن را واضح تر و ماژولارتر می کنند.</li>
</ul>
<p>این مثال نشان می دهد که چگونه توابع وراثت و سازنده مبتنی بر نمونه اولیه جاوا اسکریپت ایجاد برنامه های کاربردی وب پویا، مقیاس پذیر و قابل نگهداری را تسهیل می کند.</p>
<img src="./images/7.27 photo.png" width="450" alt="7.27">

<section>
<h3>این مثال نشان می دهد که چگونه توابع وراثت و سازنده مبتنی بر نمونه اولیه جاوا اسکریپت ایجاد برنامه های کاربردی وب پویا، مقیاس پذیر و قابل نگهداری را تسهیل می کند.</h3>
<p>بیایید نگاه دقیق تری به کلاس‌های جاوا اسکریپت بیندازیم و آن‌ها را با دیدگاهی تازه و مثال‌های متمایز دوباره تصور کنیم. این نه تنها درک واضح‌تری از کلاس‌ها و نقش آن‌ها در جاوا اسکریپت ارائه می‌کند، بلکه کاربرد عملی آن‌ها را با نمونه‌های کد کامل همراه با تفسیر نشان می‌دهد.
</p>
</section>

</section>

<section id="script">
<section >
<h3>کلاس‌های جاوا اسکریپت</h3>
<p>بیایید نگاه دقیق تری به کلاس‌های جاوا اسکریپت بیندازیم و آن‌ها را با دیدگاهی تازه و مثال‌های متمایز دوباره تصور کنیم. این نه تنها درک واضح‌تری از کلاس‌ها و نقش آن‌ها در جاوا اسکریپت ارائه می‌کند، بلکه کاربرد عملی آن‌ها را با نمونه‌های کد کامل همراه با تفسیر نشان می‌دهد.</p>

</section>
<section id="script1">
<h3>مقدمه ای بر کلاس های جاوا اسکریپت
</h3>
<p>کلاس‌ها در جاوا اسکریپت به‌عنوان نقشه‌ای برای ایجاد اشیایی عمل می‌کنند که ویژگی‌ها و روش‌های مشابهی دارند. در حالی که جاوا اسکریپت مبتنی بر نمونه اولیه باقی می‌ماند، کلاس‌ها برای تولید نمونه‌های شی که به همان ساختار می‌پیوندند، نحو سنتی‌تر و قابل خواندن‌تری ارائه می‌دهند. این لایه های انتزاعی بر روی وراثت مبتنی بر نمونه اولیه موجود، ایجاد و وراثت شی را ساده می کند.</p>

</section>
<section id="script2">
<h3>درک کلاس ها و سازندگان</h3>
<p>کلمه کلیدی class یک کلاس را معرفی می کند. به عنوان مثال، یک کلاس ساده که یک کتاب را نشان می دهد در نظر بگیرید:</p>
<img src="./images/7.28 photo.png" width="450" alt="7.28">
<div>
  <img src="./images/7.29 photo.png" width="450" alt="7.29">

</div>
<p>این مثال یک کلاس Book را با ویژگی هایی برای عنوان و نویسنده کتاب تعریف می کند. متد سازنده این خصوصیات را با ایجاد یک نمونه Book جدید مقدار دهی اولیه می کند و متد displayInfo جزئیات کتاب را چاپ می کند.</p>
<p>
  ساده سازی سازندگان <br/>
اگر کلاس شما نیاز به مقداردهی اولیه خاصی ندارد، می توانید سازنده را حذف کنید. جاوا اسکریپت یک سازنده پیش فرض در چنین مواردی ارائه می دهد:

</p>
<img src="./images/7.30 photo.png" width="450" alt="7.30">


</section>
<section id="script3">
<h3>اجرای وراثت</h3>
<p>وراثت به یک کلاس اجازه می دهد تا ویژگی ها و متدها را از کلاس دیگر به ارث ببرد. برای رسیدن به این هدف از کلمه کلیدی extends استفاده کنید:</p>
<img src="./images/7.31 photo.png" width="450" alt="7.31">
<div>
  <img src="./images/7.32 photo.png" width="450" alt="7.32">

</div>
<p>در این مثال، Student Person را گسترش می‌دهد و ویژگی‌ها و روش‌های آن را به ارث می‌برد و در عین حال موارد جدید را معرفی می‌کند.</p>

</section>

</section>

<section id="script4">
<h3> کپسوله سازی / Encapsulation با خواص و روش های خصوصی</h3>
<p>کلاس‌های جاوا اسکریپت از کپسوله‌سازی پشتیبانی می‌کنند و به ویژگی‌ها و روش‌ها اجازه می‌دهند با استفاده از پیشوند # به‌عنوان خصوصی علامت‌گذاری شوند. این دسترسی به آنها را در خارج از کلاس محدود می کند:</p>
<img src="./images/7.33 photo.png" width="450" alt="7.33">
<div>
<img src="./images/7.34 photo.png" width="450" alt="7.34">
</div>
<section id="script5">
<h3>مثال عملی: ماشین حساب شکل</h3>
<p>بیایید دانش خود را برای ایجاد یک برنامه کاربردی ساده که مساحت و محیط را برای اشکال مختلف محاسبه می کند، به کار ببریم:</p>
</section>

<section id="script6">
<h3>ساختار HTML</h3>
<img src="./images/7.35 photo.png" width="450" alt="7.35">
<div>
  <img src="./images/7.36 photo.png" width="450" alt="7.36">

</div>

</section>
<section id="script7">
<h3>CSS Styling
</h3>
<img src="./images/7.37 photo.png" width="450" alt="7.37">

</section>
<section id="script8">
<h3>منطق جاوا اسکریپت
</h3>
<img src="./images/7.38 photo.png" width="450" alt="7.38">
<div>
<img src="./images/7.39 photo.png" width="450" alt="7.39">
</div>
<div>
  <img src="./images/7.39- photo.png" width="450" alt="7.39-">
</div>
<img src="./images/7.40 photo.png" width="450" alt="7.40">

<p>این مثال قدرت کلاس‌های جاوا اسکریپت را در ایجاد کدهای مدولار، قابل نگهداری و مقیاس‌پذیر با پیاده‌سازی یک ماشین‌حساب شکل تعاملی که به اصول OOP پایبند است، نشان می‌دهد.</p>
</section>
<section id="metod">
<h3>آشنایی با متدها در جاوا اسکریپت</h3>
<p>متدها در جاوا اسکریپت اقداماتی هستند که می توان روی اشیاء انجام داد. آنها اساسا توابعی هستند که به اشیا متصل می شوند و به شما امکان می دهند بر روی داده های شی کار کنید، آنها را دستکاری کنید و محاسبات را انجام دهید. درک روش ها برای برنامه نویسی موثر در جاوا اسکریپت بسیار مهم است، زیرا آنها شما را قادر می سازند تا عملیات درون اشیاء را محصور کنید و کد شما را ماژولار تر، قابل استفاده مجدد و قابل نگهداری تر می کند.</p>
</section>
<section id="metod1">
<h3>مفاهیم کلیدی روش ها:</h3>
<ul>
  <li>کپسوله‌سازی: روش‌ها به شما این امکان را می‌دهند که رفتارهای خاصی را با اشیا محصور کنید و اطمینان حاصل کنید که جزئیات داخلی یک شی از بیرون پنهان است و فقط آنچه لازم است را آشکار می‌کند.
</li>
  <li>قابلیت استفاده مجدد: با تعریف روش ها بر روی اشیاء، می توانید از آنها در بخش های مختلف برنامه خود استفاده مجدد کنید و تکرار کد را کاهش دهید.
</li>
  <li>روش‌های داخلی: جاوا اسکریپت تعداد زیادی از روش‌های داخلی را برای اشیاء بومی خود مانند آرایه‌ها، رشته‌ها و اعداد فراهم می‌کند و عملیات رایج را بدون نیاز به کتابخانه‌های خارجی تسهیل می‌کند.
</li>
</ul>
</section>

</section>
<section id="metod2">
<h3>متدهای اعلام - Declaring Methods
</h3>
<p>همانطور که در مثال زیر نشان داده شده است، می‌توان متدها را با مرتبط کردن یک تابع با یک ویژگی به صورت لفظی شی اعلان کرد:</p>
<img src="./images/7.41 photo.png" width="450" alt="7.41">
<div>
  <img src="./images/7.42 photo.png" width="450" alt="7.42">

</div>
<section id="metod3">
<h3> سینتکس متد ES6
</h3>
<p>ES6 یک سینتکس مختصر برای تعریف روش‌ها در اشیاء معرفی کرد، و نحو را تمیزتر و شهودی‌تر کرد:</p>
<img src="./images/7.43 photo.png" width="450" alt="7.43">
</section>

</section>
<section id="metod4">
<h3>متدهای داخلی شی - Built-in Object Methods
</h3>
<p>اشیاء داخلی جاوا اسکریپت با روش های خاص خود ارائه می شوند. برای مثال، اشیاء رشته‌ای متدهایی برای دستکاری دارند، آرایه‌ها متدهایی را برای تکرار و تبدیل و غیره ارائه می‌دهند.
</p>
<img src="./images/7.44 photo.png" width="450" alt="7.44">

</section>
<section id="metod5">
<h3>متدهای رشته ای - String Methods
</h3>
<img src="./images/7.45 photo.png" width="450" alt="7.45">
</section>
<section id="metod6">
<h3>متدهای آرایه - Array Methods
</h3>
<img src="./images/7.46 photo.png" width="450" alt="7.46">
</section>
<section id="metod7">
<h3>متدهای سفارشی - Custom Methods
</h3>
<p>شما می توانید روش های خود را برای افزودن قابلیت به اشیاء سفارشی تعریف کنید. این به ویژه برای ایجاد مدل هایی مفید است که موجودیت هایی را در برنامه شما نشان می دهد و عملیات مربوط به آن موجودیت ها را محصور می کند.
</p>
<section id="metod8">
<h3>مثال: یک شیء شمارنده
</h3>
<img src="./images/7.47 photo.png" width="450" alt="7.47">
<div>
<img src="./images/7.48 photo.png" width="450" alt="7.48">
</div>
<p>متدها یک جنبه اساسی جاوا اسکریپت هستند که راهی برای کپسوله کردن عملیات درون اشیاء فراهم می کنند. با استفاده از متدها، می‌توانید کد تمیزتر و سازمان‌یافته‌تری بنویسید که درک و نگهداری آن آسان‌تر باشد. خواه از متدهای داخلی برای ساده‌سازی عملیات رایج استفاده کنید یا متدهای خود را برای محصور کردن منطق کسب‌وکار تعریف کنید، متدها یک ابزار ضروری در جعبه ابزار برنامه‌نویس جاوا اسکریپت هستند.</p>


</section>
</section>
<section id="tafavot">
<h3>تفاوت بین توابع و متدها در جاوا اسکریپت
</h3>
<p>تفاوت اصلی بین توابع و متدها در جاوا اسکریپت در نحوه تعریف و فراخوانی آنها نهفته است. یک تابع یک بلوک از کد است که می تواند هنگام فراخوانی اجرا شود، در حالی که یک متد یک تابع مرتبط با یک شی (یا کلاس) است.</p>
<ul>
<li>عملکرد: به طور مستقل فراخوانی می شود.
</li>
<li>متد: بر روی یک شیء فراخوانی می شود.
</li>
</ul>
</section>
<section id="tafavot1">
<h3>سناریو: یک شیء پست وبلاگ
</h3>
<p>ما با یک پست وبلاگ ساده یک سناریو ایجاد خواهیم کرد. این شامل HTML برای ساختار صفحه، CSS برای استایل و جاوا اسکریپت برای به روز رسانی پویا محتوا است. جاوا اسکریپت ما شامل یک تابع مستقل و یک متد در یک شی برای نشان دادن تفاوت خواهد بود.
</p>
<section id="tafavot2">
<h3>HTML(index.html)
</h3>
<img src="./images/7.49 photo.png" width="450" alt="7.49">
</section>
<section id="tafavot3">
<h3>CSS(style.css)</h3>
<img src="./images/7.50 photo.png" width="450" alt="7.50">
<div>
  <img src="./images/7.51 photo.png" width="450" alt="7.51">

</div>
</section>
<section id="tafavot4">
<h3>JavaScript(script.js)</h3>
<img src="./images/7.52 photo.png" width="450" alt="7.52">
<div>
  <img src="./images/7.53 photo.png" width="450" alt="7.53">
</div>
</section>

<section id="tafavot3">
<h4>توضیح گام به گام:</h4>
<ul>
  <li>راه اندازی HTML: ما یک طرح صفحه وب ساده با عنوان (<h1>)، محتوا (<p>) و یک دکمه برای به روز رسانی محتوا ایجاد می کنیم.</li>
    <li>استایل CSS: سبک های پایه برای وضوح بصری اعمال می شوند.</li>
    <li>عملکرد جاوا اسکریپت:

<ul>
<li>
    <strong>تعریف شی:</strong> یک شی به نام blogPost شامل عنوان، محتوا و روش نمایش تعریف می‌شود که صفحه وب را با عنوان و محتوا به‌روز می‌کند.
</li>
<li>
    <strong>روش:</strong> متد display در شی blogPost تعریف و فراخوانی می‌شود. این متد عناصر HTML را با عنوان و محتوای پست وبلاگ به‌روز می‌کند.
</li>
<li>
    <strong>عملکرد مستقل:</strong> تابع updateBlogContent به عنوان یک تابع معمولی تعریف می‌شود که ویژگی محتوای blogPost را تغییر می‌دهد و سپس روش نمایش را برای به‌روزرسانی صفحه وب فراخوانی می‌کند. این نشان می‌دهد که چگونه می‌توان از یک تابع مستقل برای ایجاد تماس‌های روش شی استفاده کرد.
</li>
<li>
    <strong>شنونده رویداد:</strong> به دکمه اضافه می‌شود و هنگام کلیک کردن، تابع updateBlogContent را فراخوانی می‌کند. این نشان می‌دهد که چگونه می‌توان از یک تابع مستقل برای راه‌اندازی تماس‌های روش شی استفاده کرد.
</li>
</ul>
    </li>

</ul>

<p>نتیجه:</p>
<img src="./images/7.54 photo.png" width="450" alt="7.54">
<p>این سناریو تمایز عملکردی بین توابع و روش‌های مستقل در جاوا اسکریپت را نشان می‌دهد. توابع مستقل وظایفی را انجام می دهند و می توانند به طور مستقل فراخوانی شوند، در حالی که متدها به اشیاء (یا کلاس ها) گره خورده اند و بر روی داده ها یا وضعیت آنها کار می کنند. هر دو نقش مهمی در برنامه نویسی جاوا اسکریپت دارند و کدهای ساختاریافته و سازمان یافته را تسهیل می کنند.</p>
</section>

</section>
<section id="JSON">
<h3>آشنایی با JSON در جاوا اسکریپت
</h3>
<p>نمادگذاری شی جاوا اسکریپت - (JavaScript Object Notation (JSON یک فرمت شناخته شده جهانی برای تبادل و ذخیره داده های ساخت یافته است. این سینتکس خود را از جاوا اسکریپت مشتق می کند، اما به طور مستقل عمل می کند و امکان تبادل یکپارچه داده ها را بین کلاینت ها و سرورها یا بین اجزای مختلف یک برنامه وب فراهم می کند</p>

</section>
<section id="JSON1">
<h3>ماهیت JSON
</h3>
<p>JSON اساسا یک قالب متنی است که ساختار اشیاء جاوا اسکریپت را تقلید می کند. این برای خوانایی انسان و سهولت استفاده در زبان های برنامه نویسی طراحی شده است، و آن را به فرمت قابل استفاده برای API های وب و فایل های پیکربندی تبدیل می کند.
</p>
<p>ویژگی های کلیدی JSON:
</p>
<ul>
<li>مبتنی بر متن: JSON صرفاً متنی است و به راحتی توسط انسان قابل خواندن است.
</li>
<li>Language Agnostic: با وجود منشأ جاوا اسکریپت، JSON را می توان با بسیاری از زبان های برنامه نویسی استفاده کرد.
</li>
<li>داده های ساختاریافته: از آرایه ها، اشیا، رشته ها، اعداد، بولی ها و تهی پشتیبانی می کند.
</li>
</ul>
</section>


<section id="JSON2">
<h3>کار با JSON در جاوا اسکریپت
</h3>
<p>جاوا اسکریپت یک شی JSON را با دو روش مهم ارائه می دهد:
</p>
<li>JSON.parse(): یک رشته JSON را به یک شی جاوا اسکریپت تبدیل می کند.
</li>
<li>JSON.stringify(): یک شی جاوا اسکریپت را به یک رشته JSON تبدیل می کند.
</li>
<p>این متدها برای کار با داده‌های JSON ضروری هستند، چه آن‌ها را از سرور دریافت کنید و چه از مشتری ارسال کنید.
</p>

</section>
<section id="JSON3">
<h3>مثال: تجزیه / Parsing JSON
</h3>

<p>تصور کنید یک رشته JSON از سروری دریافت کنید که حاوی اطلاعاتی درباره یک کتاب است:
</p>
<img src="./images/7.55 photo.png" width="450" alt="7.55">
<p>برای دسترسی به این داده ها در جاوا اسکریپت، آن را به این صورت تجزیه کنید:
</p>
<img src="./images/7.56 photo.png" width="450" alt="7.56">
<div>
  <img src="./images/7.57 photo.png" width="450" alt="7.57">
</div>
</section>
<section id="JSON4">
<h3>JSON</h3>
<p>برعکس، اگر یک شی جاوا اسکریپت به نمایندگی از یک کاربر دارید و باید این داده ها را به یک سرور ارسال کنید، آن را به یک رشته JSON تبدیل می کنید:
</p>
<img src="./images/7.58 photo.png" width="450" alt="7.58">

</section>

<section id="fail">
<h3>کاربرد عملی: ساخت رابط کاربری
</h3>
<p>بیایید با ایجاد یک رابط کاربری ساده که اطلاعات فچ  شده از یک فایل JSON را نمایش می دهد، آنچه را که در مورد JSON آموخته ایم اعمال کنیم.
</p>
<section id="fail1">
<p>ساختار HTML
</p>
<img src="./images/7.59 photo.png" width="450" alt="7.59">
<div>
  <img src="./images/7.60 photo.png" width="450" alt="7.60">
</div>
</section>
<section id="fail2">
<h3>فایل جاوا اسکریپت
</h3>
<img src="./images/7.61 photo.png" width="450" alt="7.61">
</section>
<section id="fail3">
<h3>فایل user.json شامل:
</h3>
<img src="./images/7.62 photo.png" width="450" alt="7.62">

</section>
<p>قطعه کد داده های کاربر را فچ  می کند، JSON را تجزیه می کند و به صورت پویا نام و سن کاربر را در سند HTML درج می کند.
</p>
<p>JSON نقشی اساسی در توسعه وب مدرن ایفا می کند و انتقال داده ها را در قالبی قابل خواندن تسهیل می کند. ادغام آن با جاوا اسکریپت از طریق متدهای تجزیه و رشته‌بندی شی JSON به توسعه‌دهندگان اجازه می‌دهد تا بدون دردسر داده‌ها را سریال‌سازی و سریال‌زدایی کنند و از جریان روان داده‌ها در برنامه‌های کاربردی وب اطمینان حاصل کنند.</p>

<img src="./images/7.63 photo.png" width="450" alt="7.63">

</section>

<section id="dastor">
<h3>ساخت اشیاء با جاوا اسکریپت: نمایش ساده محصول تجارت الکترونیک
</h3>
<p>در این سناریو، ما با استفاده از HTML، CSS، جاوا اسکریپت و JSON یک نمایشگر ساده محصول تجارت الکترونیک ایجاد می کنیم. هدف ما تمرین ساختن و دستکاری اشیا و تولید پویا کارت های محصول در یک صفحه وب است.</p>
<p>شرح سناریو <br/>
یک فروشگاه اینترنتی را تصور کنید که محصولات مختلفی را به فروش می رساند. ما چند محصول از جمله نام، قیمت و تصاویر را در صفحه خود نمایش خواهیم داد. ما هر محصول را به عنوان یک شی تعریف می کنیم و از یک آرایه برای ذخیره چندین محصول استفاده می کنیم. سپس به صورت پویا محتوای HTML تولید می کنیم تا این محصولات را به صورت کارت در صفحه وب خود نمایش دهیم.
</p>
<section id="dastor1">
<h3>دستورالعمل های گام به گام
</h3>
<p>HTML (index.html)
ساختار اصلی صفحه را ایجاد کنید.
</p>
<img src="./images/7.64 photo.png" width="450" alt="7.64">
<p>CSS (style.css) <br/>
برای اینکه کارت های محصول ما مرتب به نظر برسند، سبک هایی اضافه کنید.
</p>
<img src="./images/7.65 photo.png" width="450" alt="7.65">
<div>
  <img src="./images/7.65- photo.png" width="450" alt="7.65-">

</div>
<img src="./images/7.66 photo.png" width="450" alt="7.66">
<p>عملکرد جاوا اسکریپت (script.js) <br/>

اشیاء محصول را تعریف کنید و کارت های محصول را به صورت پویا تولید کنید:
</p> 
<img src="./images/7.67 photo.png" width="450" alt="7.67">
<div>
  <img src="./images/7.68 photo.png" width="450" alt="7.68">

</div>
<div>
  <img src="./images/7.68- photo.png" width="450" alt="7.68-">

</div>
<img src="./images/7.69 photo.png" width="450" alt="7.69">
<p>توضیح:</p>
<ul>
<li>
HTML: ما یک ظرف <div> راه اندازی کردیم که در آن کارت های محصول ما نمایش داده می شود.
</li>
<li>CSS: یک ظاهر طراحی برای صفحه و کارت های محصول ارائه می دهد و آنها را به صورت شبکه ای از کارت ها نشان می دهد.</li>
<li>جاوا اسکریپت:
<ul>
  <li>ما با تعریف یک رشته JSON که محصولات ما را نشان می دهد شروع می کنیم.
</li>
  <li>ما این JSON را به یک شی جاوا اسکریپت تجزیه می کنیم تا بتوانیم با آن کار کنیم.
</li>
  <li>تابع displayProducts محصولات ما را می گیرد و به صورت پویا عناصر HTML را برای هر محصول ایجاد می کند و جزئیات مربوطه را از اشیاء محصول ما درج می کند.
</li>
  <li>در نهایت برای نمایش محصولات در صفحه ما این تابع را فراخوانی می کنیم.
</li>
</ul>
</li>
</ul>
<img src="./images/7.70 photo.png" width="450" alt="7.70">

<p>از طریق این تمرین، نحوه ساخت اشیاء در جاوا اسکریپت و استفاده از آنها برای تولید پویا محتوا در یک صفحه وب را مشاهده کرده اید. این الگو سنگ بنای توسعه وب مدرن است که به برنامه های کاربردی وب پویا و تعاملی اجازه می دهد.</p>

</section>
</section>

<section id="Asynchronous">
<h3> Asynchronous & Synchronous Javascript
</h3>
<section>
<h4>آشنایی با جاوا اسکریپت ناهمزمان / Asynchronous
</h4>
<p>در دنیای برنامه نویسی، به ویژه در توسعه وب، جاوا اسکریپت ناهمزمان سنگ بنای است که به ما امکان می دهد تا کارهایی را که ممکن است مدتی طول بکشد – مانند فچ کردن داده ها از یک API خارجی – بدون فریز کردن رابط کاربری انجام دهیم. این مقاله به بررسی چیستی جاوا اسکریپت ناهمزمان می‌پردازد، چرا به آن نیاز است، و روش‌های مدرن برای مدیریت مؤثر عملیات ناهمزمان را معرفی می‌کند.</p>

<p>چرا جاوا اسکریپت ناهمزمان؟
</p> <br/>
<p>جاوا اسکریپت، ذاتاً تک رشته ای است، به این معنی که فقط می تواند یک عملیات را در هر زمان و به ترتیب معین اجرا کند. این مشخصه می تواند منجر به مشکلات عملکردی در هنگام اجرای وظایفی شود که تکمیل آنها زمان قابل توجهی را می طلبد، مانند دانلود یک تصویر یا جستجو در پایگاه داده. این عملیات مانع از اجرای جاوا اسکریپت بعدی می شود که منجر به تجربه کاربری ضعیف می شود.
</p>
<p>جاوا اسکریپت ناهمزمان با اجازه دادن به اجرای وظایف طولانی مدت در پس‌زمینه، این مشکل را برطرف می‌کند و موتور جاوا اسکریپت را قادر می‌سازد تا کارهای دیگر را در حالی که منتظر تکمیل عملیات ناهمزمان است، اجرا کند.
</p>

</section>
<section id="Asynchronous1">
<h4>تکامل جاوا اسکریپت ناهمزمان
</h4>
<p>در ابتدا جاوا اسکریپت عملیات ناهمزمان را از طریق توابع پاسخ به تماس انجام می داد. با این حال، این رویکرد اغلب به «جهنم پاسخ به تماس» منجر می‌شد، جایی که تماس‌های تودرتو خواندن و نگهداری کد را دشوار می‌کرد.
</p>
<p>برای بهبود این امر، جاوا اسکریپت Promises را معرفی کرد، اشیایی که نشان دهنده تکمیل یا شکست نهایی یک عملیات ناهمزمان هستند. Promises کد ناهمزمان خواناتر را با مدیریت خطا آسان تر می دهد.
</p>
<p>علاوه بر این، نحو ناهمزمان/انتظار معرفی شد، که باعث می‌شود کدهای ناهمزمان بیشتر شبیه کد همزمان به نظر برسند و رفتار کنند و خوانایی و قابلیت نگهداری را افزایش دهند.
</p>
</section>
<section id="Asynchronous2">
<h3>جاوا اسکریپت ناهمزمان در عمل
</h3>
<p>بیایید یک سناریوی ساده را در نظر بگیریم که در آن باید داده‌های کاربر را از یک API فچ  کنیم و آن را در کنسول ثبت کنیم.</p>
<p>استفاده از Fetch API با Promises:
</p>

<p>استفاده از Async/Await for Cleaner Syntax:
</p>
<img src="./images/7.71 photo.png" width="450" alt="7.71">
<div>
  <img src="./images/7.72 photo.png" width="450" alt="7.72">
</div>

</section>
<section id="Asynchronous3">
<h3>تمرین عملی: ایجاد یک رابط کاربری برای داده های API
</h3>
<p>بیایید با ایجاد سناریویی که در آن داده‌های کاربر را از یک API ساختگی فچ  کرده و در صفحه وب خود نمایش می‌دهیم، درک خود را از جاوا اسکریپت ناهمزمان افزایش دهیم. این تمرین به نشان دادن قدرت عملیات ناهمزمان در یک زمینه دنیای واقعی کمک خواهد کرد.</p>
<p>سناریو: نمایش داده های کاربر با کلیک روی دکمه <br/>
هدف ما ایجاد یک صفحه وب ساده است که با کلیک روی یک دکمه، داده‌های کاربر را از یک API خارجی فچ  و نمایش می‌دهد. ما از Fetch API در کنار syntax async/wait برای کدهای ناهمزمان تمیز و خوانا استفاده خواهیم کرد.
</p>
<section id="Asynchronous4">
<h3>مرحله 1: تنظیم HTML
</h3>
<p>ساختار HTML ما شامل یک دکمه برای راه اندازی عملیات فچ کردن داده ها و یک عنصر <div> برای نمایش داده های فچ  شده است.
ساختار HTML: <br/>
</p>
<img src="./images/7.73 photo.png" width="450" alt="7.73">
<div>
  <img src="./images/7.74 photo.png" width="450" alt="7.74">

</div>
<p>
عنصر <button> برای شروع عملیات فچ  استفاده خواهد شد. عنصر <div> (id="userData") جایی است که داده های فچ  شده خود را نمایش خواهیم داد.
</p>

</section>
<section id="Asynchronous5">
<h3>مرحله 2: اضافه کردن سبک با CSS
</h3>
<p>بیایید یک استایل اولیه اضافه کنیم تا ارائه داده هایمان کمی جذاب تر شود.
</p>
<img src="./images/7.75 photo.png" width="450" alt="7.75">

</section>
<section id="Asynchronous6">
<h3>مرحله 3: فچ  و نمایش داده ها با جاوا اسکریپت
</h3>
<p>حال، اجازه دهید جاوا اسکریپتی را بنویسیم که داده‌های کاربر را به صورت ناهمزمان دریافت می‌کند و آن را در داخل ظرف <div> ما نمایش می‌دهد.</p>
<img src="./images/7.76 photo.png" width="450" alt="7.76">
<div>
  <img src="./images/7.77 photo.png" width="450" alt="7.77">
</div>
</section>
<ul>
<li>ما یک شنونده رویداد به دکمه خود اضافه می کنیم که با کلیک کردن فعال می شود.
</li>
<li>ما از دستور async/wait برای فچ  داده‌های کاربر از یک متغیر API استفاده می‌کنیم. این رویکرد کد ما را تمیز و خوانا نگه می دارد.
</li>
<li>بلوک try...catch هرگونه خطایی را که ممکن است در حین عملیات فچ  رخ دهد کنترل می‌کند و اطمینان می‌دهد که برنامه ما قوی باقی می‌ماند.
</li>
</ul>
<img src="./images/7.78 photo.png" width="450" alt="7.78">
<p>این سناریو قدرت جاوا اسکریپت ناهمزمان را در توسعه وب نشان می دهد. با استفاده از Fetch API با syntax async/wait، می‌توانیم درخواست‌های وب را به صورت ناهمزمان انجام دهیم و برنامه‌های وب خود را پاسخگو و سریع نگه داریم. ساختار try...catch مدیریت خطا را بیشتر می کند و کد ما را قابل اطمینان تر و نگهداری آسان تر می کند.
</p>
<p>با API های مختلف آزمایش کنید و راه های مختلفی را برای بهبود تجربه کاربر با استفاده از جاوا اسکریپت ناهمزمان در پروژه های خود کاوش کنید.
</p>
<p>برنامه نویسی ناهمزمان در جاوا اسکریپت توسعه برنامه های کاربردی وب سریع و پاسخگو را امکان پذیر می کند. درک و استفاده مؤثر از جاوا اسکریپت ناهمزمان، از جمله Promises و async/wait، برای توسعه دهندگان وب مدرن برای ایجاد تجربیات کاربر یکپارچه ضروری است.
</p>
</section>
</section>
<section id="barnameh">
<h3>Synchronous Programming
</h3>
<section>
<h3>برنامه نویسی سنکرون چیست؟</h3>
<p>برنامه نویسی همزمان در جاوا اسکریپت (یا در برنامه نویسی به طور کلی) به یک رویکرد متوالی برای اجرای کد اشاره دارد. در یک مدل برنامه نویسی همزمان، وظایف یکی پس از دیگری اجرا می شوند. هر کار قبل از اجرا منتظر می ماند تا کار قبلی تمام شود. این به این معنی است که اگر یک عملیات خاص برای کامل شدن زمان زیادی طول بکشد (مانند خواندن یک فایل از دیسک یا پرس و جو از یک پایگاه داده)، کارهای بعدی باید تا پایان عملیات منتظر بمانند، که به طور بالقوه منجر به مسدود کردن رفتار و یک برنامه یا برنامه کاربردی کمتر پاسخگو می شود.
</p>
<p>در اینجا یک تشبیه ساده وجود دارد: تصور کنید در یک صف کافی شاپ هستید. هر مشتری قهوه خود را سفارش می دهد، منتظر می ماند تا آن را درست کند و به او تحویل دهد و تنها پس از آن مشتری بعدی سفارش خود را شروع می کند. این فرآیند خطی و متوالی است و هر مرحله قبل از ادامه در انتظار تکمیل مرحله قبلی است.
</p>
<p>در جاوا اسکریپت، زمانی که کد همزمان را اجرا می کنید، هر دستور قبل از رفتن به دستور بعدی، اجرای خود را کامل می کند. در اینجا یک مثال اساسی برای نشان دادن اجرای کد همزمان آورده شده است:
</p>
<img src="./images/7.79 photo.png" width="450" alt="7.79">
<p>در این مثال، جاوا اسکریپت قبل از رفتن به دستور بعدی console.log منتظر می ماند تا حلقه کامل شود. این رفتار تضمین می کند که عملیات ها به ترتیبی که نوشته شده اند قابل پیش بینی و اجرا می شوند. با این حال، می‌تواند منجر به ناکارآمدی شود، به‌ویژه زمانی که با عملیات‌هایی که زمان‌بر هستند یا به منابع خارجی مانند درخواست‌های شبکه وابسته هستند، سر و کار داریم.
</p>
<p>ماهیت همزمان اجرا در چنین سناریوهایی می تواند برنامه را کند یا بی پاسخ کند، به خصوص در زمینه توسعه وب که تجربه کاربر بسیار مهم است. به همین دلیل است که الگوهای برنامه نویسی ناهمزمان اغلب برای عملیاتی که شامل تاخیر یا انتظار قابل توجه است ترجیح داده می شود و به برنامه اجازه می دهد تا با اجرای وظایف دیگر در حالی که منتظر تکمیل این عملیات است پاسخگو باقی بماند.
</p>

</section>

</section>
<section id="nahamzaman">
<h3>تفاوت کلیدی بین برنامه‌نویسی ناهمزمان و همزمان</h3>
<p>تفاوت کلیدی بین برنامه‌نویسی ناهمزمان و همزمان در نحوه مدیریت عملیات‌هایی است که تکمیل آنها به زمان نیاز دارد، به ویژه آنهایی که شامل انتظار هستند، مانند درخواست‌های شبکه، عملیات فایل یا تایمر. در اینجا به تفکیک تفاوت ها، به دنبال یک مثال و بهترین شیوه ها آمده است:
</p>

<h2>برنامه‌نویسی همزمان</h2>
<ul>
    <li>
        <strong>جریان اجرا:</strong> عملیات به ترتیب و یکی پس از دیگری اجرا می‌شوند. هر عملیات باید قبل از شروع عملیات بعدی کامل شود.
    </li>
    <li>
        <strong>مسدود کردن:</strong> اگر تکمیل یک عملیات به زمان نیاز داشته باشد، اجرای برنامه مسدود می‌شود، به این معنی که تا زمانی که عملیات فعلی تمام نشود، نمی‌توان به عملیات بعدی ادامه داد.
    </li>
    <li>
        <strong>سادگی:</strong> درک و دنبال کردن آن آسان‌تر است، زیرا اجرای کد با ترتیب نوشته شدن کد مطابقت دارد.
    </li>
    <li>
        <strong>موارد استفاده:</strong> بهترین گزینه برای عملیات سریع یا جاهایی که کارها باید با ترتیب خاصی بدون نیاز به همزمانی کامل شوند.
    </li>
</ul>

<h2>برنامه‌نویسی ناهمزمان</h2>
<ul>
    <li>
        <strong>جریان اجرا:</strong> عملیاتی که تکمیل آنها زمان بر است جدا از جریان اصلی برنامه اجرا می‌شود و به برنامه اجازه می‌دهد تا به اجرای وظایف دیگر ادامه دهد.
    </li>
    <li>
        <strong>Non-Blocking:</strong> عملیات طولانی مدت به گونه‌ای انجام می‌شود که اجرای برنامه را مسدود نمی‌کند. سایر عملیات همچنان می‌توانند در حین انتظار برای نتیجه اجرا شوند.
    </li>
    <li>
        <strong>پیچیدگی:</strong> به دلیل تماس‌های برگشتی، وعده‌ها و دستور ناهمگام/انتظار می‌تواند برای درک و پیاده‌سازی پیچیده‌تر باشد. مدیریت خطا و اشکال زدایی نیز می‌تواند چالش برانگیزتر باشد.
    </li>
    <li>
        <strong>موارد استفاده:</strong> ایده آل برای عملیاتی که شامل انتظار است، مانند درخواست های وب API، ورودی/خروجی فایل یا هر گونه ارتباط شبکه ای. برای افزایش عملکرد و پاسخگویی در برنامه ها عالی است.
    </li>
</ul>
</section>
<section id="nahamzaman1">
<p>همزمان / Synchronous:
</p>
<img src="./images/7.80 photo.png" width="450" alt="7.80">

<section id="nahamzaman2">
<p>نامتقارن / Asynchronous:
</p>
<img src="./images/7.81 photo.png" width="450" alt="7.81">
</section>
<section id="nahamzaman3">
<h2>Best Practices Asynchronous</h2>
<ul>
    <li>
        <strong>از متدهای ناهمزمان برای عملیات ورودی/خروجی استفاده کنید:</strong> برای عملیات‌هایی مانند درخواست‌های شبکه، وظایف سیستم فایل، و هرگونه عملیات محدود به ورودی/خروجی، از متدهای ناهمزمان برای جلوگیری از مسدود کردن رشته اصلی اجرا استفاده کنید، در نتیجه پاسخ‌دهی و عملکرد برنامه‌تان را بهبود می‌بخشید.
    </li>
    <li>
        <strong>Prefer Promises and Async/Await Over Callbacks:</strong> Callbacks می تواند منجر به جهنم برگشت به تماس شود و خواندن و نگهداری کد را سخت کند. Promises و syntax async/wait متدی تمیزتر و خواناتر برای مدیریت عملیات ناهمزمان ارائه می دهد.
    </li>
    <li>
        <strong>مدیریت خطا:</strong> از بلوک‌های try/catch با async/wait استفاده کنید تا خطاها را به خوبی مدیریت کنید. هنگام استفاده از وعده‌ها، مطمئن شوید که خطاها را شناسایی کنید تا از کنترل نشدن آنها جلوگیری کنید.
    </li>
    <li>
        <strong>همزمانی:</strong> برای بهینه‌سازی عملکرد، از ویژگی‌هایی مانند Promise.all برای اجرای چندین عملیات ناهمزمان به‌طور همزمان و نه متوالی استفاده کنید.
    </li>
    <li>
        <strong>درک زمان و نحوه استفاده از برنامه نویسی ناهمزمان و همزمان برای توسعه برنامه های کاربردی جاوا اسکریپت کارآمد، پاسخگو و قابل نگهداری بسیار مهم است.</strong>
    </li>
</ul>
</section>
<section id="Handlers">
<h2>Event Handlers چیست؟</h2>
<p>کنترل‌کننده‌های رویداد، توابعی در جاوا اسکریپت هستند که در پاسخ به رویدادهای خاصی که در یک برنامه وب رخ می‌دهند، اجرا می‌شوند. این رویدادها می‌تواند هر چیزی باشد، از کلیک کاربر روی دکمه، ارسال فرم، حرکت دادن ماوس تا رویدادهای پیچیده‌تر ایجاد شده توسط سیستم. کنترل‌کننده‌های رویداد نقش مهمی در تعاملی کردن صفحات وب و پاسخگویی به اقدامات کاربر دارند.</p>

<h3>نقش آنها در جاوا اسکریپت</h3>
<ul>
    <li>تعامل کاربر: آنها صفحات وب را با اجرای کد در پاسخ به اقدامات کاربر تعاملی می کنند.</li>
    <li>اجرای ناهمزمان: کنترل کننده های رویداد معمولاً به صورت ناهمزمان اجرا می شوند و به رویدادهایی که در زمان های نامشخص رخ می دهند پاسخ می دهند.</li>
    <li>دستکاری DOM: آنها اغلب مدل شیء سند (DOM) را بر اساس اقدامات کاربر، مانند نمایش یا پنهان کردن عناصر، اصلاح محتوا و غیره دستکاری می کنند.</li>
    <li>اعتبار سنجی و فرم‌ها: کنترل‌کننده‌های رویداد برای اعتبارسنجی ورودی‌های فرم قبل از ارسال استفاده می‌شوند.</li>
    <li>انیمیشن و جلوه ها: آنها انیمیشن ها یا جلوه های بصری را در پاسخ به تعاملات کاربر ایجاد می کنند.</li>
</ul>

<h3>سنکرون یا ناهمزمان؟</h3>
<p>کنترل‌کننده‌های رویداد طبیعتاً ناهمزمان هستند، زیرا منتظر می‌مانند تا یک رویداد بدون مسدود کردن اجرای کدهای دیگر اتفاق بیفتد. تابع handler تنها زمانی فراخوانی می شود که رویداد مرتبط با آن فعال شود.</p>
</section>
<section id="Handlers1">
<h3>مثال عملی: یک رویداد کلیک ساده
</h3>
<p>بیایید یک مثال ساده ایجاد کنیم که در آن کلیک کردن روی یک دکمه رنگ یک عنصر div را تغییر می‌دهد. <br/>

مرحله 1: ساختار HTML
</p>
<img src="./images/7.82 photo.png" width="450" alt="7.82">
<div><img src="./images/7.83 photo.png" width="450" alt="7.83">
</div>
<p>مرحله 2: CSS برای استایل کردن
</p>
<img src="./images/7.84 photo.png" width="450" alt="7.84">
<p>مرحله 3: جاوا اسکریپت برای مدیریت رویداد
</p>
<img src="./images/7.85 photo.png" width="450" alt="7.85">
<div><img src="./images/7.86 photo.png" width="450" alt="7.86">
</div>
<p>این کد قبل از انتخاب عناصر و تخصیص کنترل کننده رویداد تا بارگذاری کامل DOM صبر می کند. هنگامی که دکمه کلیک می شود، تابع changeColor اجرا می شود و رنگ پس زمینه div را بین آبی و قرمز تغییر می دهد.</p>
</section>
<section id="Handlers2">
<h2>بهترین توصیه ها برای استفاده از رویداد Handlers</h2>
<ul>
    <li>از addEventListener استفاده کنید: به شما امکان می دهد چندین کنترل کننده رویداد را به یک رویداد اضافه کنید و انعطاف پذیری بیشتری را نسبت به ویژگی onclick قدیمی در HTML فراهم می کند.</li>
    <li>جداسازی نگرانی ها: کدهای HTML، CSS و جاوا اسکریپت خود را جدا نگه دارید تا کدهای تمیز و قابل مدیریت را حفظ کنید.</li>
    <li>توابع ناشناس: برای مدیریت رویدادهای ساده و یکبار مصرف، استفاده از توابع ناشناس را مستقیماً در داخل addEventListener در نظر بگیرید.</li>
    <li>Remove Event Listeners: اگر دیگر نیازی به شنونده رویداد نیست، آن را با removeEventListener حذف کنید تا از نشت حافظه جلوگیری شود.</li>
    <li>Delegation رویداد: از تفویض رویداد برای به حداقل رساندن تعداد گردانندگان رویداد استفاده کنید. به وقایع مربوط به یک والدین مشترک به جای فرزندان فردی گوش دهید.</li>
    <li>دسترس‌پذیری: اطمینان حاصل کنید که کنترل‌کننده‌های رویداد در دسترس‌پذیری وب‌سایت شما دخالت نمی‌کنند. کاربران صفحه‌کلید و صفحه‌خوان باید بتوانند با همه عناصر تعاملی تعامل داشته باشند.</li>
</ul>
<p>مدیریت رویدادها ستون فقرات توسعه وب تعاملی هستند که به توسعه دهندگان اجازه می دهند وب سایت های پاسخگو و کاربر پسند ایجاد کنند.</p>
</section>

<section id="Promises">
<h4>آشنایی با Promises در جاوا اسکریپت</h4>
<p>وعده ها / Promise برای مدیریت عملیات ناهمزمان در جاوا اسکریپت اساسی هستند. آنها یک مکانیسم قوی برای مدیریت نتایج و خطاهای عملیات ناهمزمان، مانند درخواست‌های شبکه، عملیات فایل یا تایمر ارائه می‌دهند. بیایید وعده ها، موارد استفاده آنها و نحوه استفاده از آنها را با مثال های عملی بررسی کنیم.</p>
<p>Promise در جاوا اسکریپت یک شی / Object است که نشان دهنده تکمیل یا شکست نهایی یک عملیات ناهمزمان / Asynchronous است. این به شما اجازه می دهد تا کنترل کننده ها را با ارزش موفقیت یا دلیل شکست یک اقدام ناهمزمان مرتبط کنید. این به متدهای ناهمزمان اجازه می‌دهد مقادیری مانند متدهای همزمان را برگردانند: به جای اینکه بلافاصله مقدار نهایی را برگرداند، متد ناهمزمان وعده‌ای را برای ارائه مقدار در نقطه‌ای در آینده برمی‌گرداند.</p>
<p>در کجا از وعده ها استفاده می شود؟
Promises در سناریوهایی استفاده می شود که در آن شما نیاز به انجام عملیات ناهمزمان دارید، مانند:</p>
<ul>
    <li>فچ کردن داده ها از سرور با استفاده از Fetch API.</li>
    <li>انجام عملیات فایل در Node.js.</li>
    <li>بسته بندی API های قدیمی مبتنی بر تماس در وعده هایی برای قابلیت استفاده و کنترل بهتر.</li>
</ul>
<p>چرا وعده ها مهم هستند؟</p>
<ul>
    <li>غیر مسدود کردن: Promises به جاوا اسکریپت اجازه می دهد تا عملیات طولانی را در پس زمینه انجام دهد و پاسخگویی برنامه های وب را بهبود بخشد.</li>
    <li>مدیریت خطای ساده شده: با .then() برای موفقیت و .catch() برای خطاها، وعده ها فرآیند کشف و رسیدگی به خطاها را ساده می کنند.</li>
    <li>Cleaner Async Code: وعده‌ها پیچیدگی کدهای ناهمزمان را کاهش می‌دهند، از جهنم بازگشت به تماس بدنام جلوگیری می‌کنند و خواندن و نگهداری کد را آسان‌تر می‌کنند.</li>
</ul>
</section>
<section id="Promises1">
<h4>نحوه استفاده از وعده ها</h4>
<p>وعده‌ها در جاوا اسکریپت بر اساس کمیت طبقه‌بندی نمی‌شوند، بلکه بر اساس وضعیت و کاربردشان دسته‌بندی می‌شوند. با این حال، چندین مفهوم و روش کلیدی مرتبط با وعده ها وجود دارد که باید با آنها آشنا باشید. در اینجا یک تفکیک وجود دارد:</p>
<p>یک وعده در جاوا اسکریپت می تواند در یکی از سه حالت باشد:</p>
<ol>
    <li><strong>در انتظار / Pending:</strong> حالت اولیه یک وعده. نتیجه هنوز مشخص نشده است زیرا عملیات ناهمزمان که وعده نشان می دهد کامل نشده است.</li>
    <li><strong>برآورده شده / Fulfilled:</strong> حالت یک وعده که نشان دهنده یک عملیات موفق است. این به این معنی است که عملیات ناهمزمان کامل شده است و وعده اکنون یک مقدار حل شده دارد.</li>
    <li><strong>Rejected:</strong> حالت یک وعده که نشان دهنده یک عملیات ناموفق است. این به این معنی است که عملیات ناهمزمان شکست خورده است و قول اکنون دلیلی برای شکست دارد.</li>
      <li><strong>روش های اصلی وعده:</strong></li>
</ol>

<p>چندین روش در خود شی Promise یا یک نمونه قول وجود دارد. درک این موارد به شما کمک می کند تا به طور موثر با وعده ها کار کنید:</p>
<ul>
    <li><code>Promise Constructor (new Promise):</code> برای ایجاد یک وعده جدید استفاده می شود. سازنده یک تابع مجری می گیرد که با دو تابع Resol و Reject فراخوانی می شود که به ترتیب برای حل یا رد قول استفاده می شود.</li>
    <li><code>then():</code> برای برنامه‌ریزی یک callback استفاده می‌شود تا زمانی که وعده محقق شد، اجرا شود. همچنین می‌توانید برای انجام عملیات ناهمزمان اضافی به ترتیب، روش‌ها را زنجیره‌ای کنید.</li>
    <li><code>catch():</code> برای برنامه‌ریزی یک تماس برگشتی برای اجرای زمانی که وعده رد می‌شود استفاده می‌شود. برای رسیدگی به خطا در زنجیره های وعده استفاده می شود.</li>
    <li><code>finally():</code> به شما امکان می دهد بدون توجه به سرنوشت وعده، یک تماس برگشتی را اجرا کنید. این برای پاکسازی منابع یا سایر کارهای نهایی مفید است.</li>
</ul>
</section>
<section id="Promises2" >
<p>روش‌های سودمند برای مدیریت وعده‌های متعدد:</p>
<ul>
    <li><code>Promise.all:</code> یک تکرار از وعده‌ها را می‌گیرد و یک وعده واحد را برمی‌گرداند که زمانی حل می‌شود که همه وعده‌های ورودی حل شوند یا زمانی که تکرار شونده حاوی هیچ وعده‌ای نباشد. رد می‌کند به دلیل قول اولی که رد می‌کند.</li>
    <li><code>Promise.allSettled:</code> شبیه Promise.all است، اما منتظر می‌ماند تا تمام وعده‌های ورودی بدون توجه به رد شدن آنها تکمیل شود. با آرایه‌ای از اشیاء حل می‌شود که هر کدام نتیجه هر وعده را توصیف می‌کند.</li>
    <li><code>Promise.race:</code> یک وعده تکراری را می‌گیرد و یک وعده واحد را برمی‌گرداند که به محض اینکه یکی از وعده‌های ورودی تسویه شد (یا حل شود یا رد شود)، با ارزش یا دلیل آن قول تسویه می‌شود.</li>
    <li><code>Promise.any:</code> مشابه Promise.race، اما تنها پس از رد شدن همه وعده‌های ورودی، با یک AggregateError حاوی دلایل رد شدن، رد می‌شود. به محض رفع هر یک از وعده‌های ورودی حل می‌شود.</li>
    <li><code>Promise.resolve:</code> قولی را برمی‌گرداند که با مقدار داده شده حل شده است. اگر مقدار یک وعده باشد، آن وعده برگردانده می‌شود.</li>
    <li><code>Promise.reject:</code> قولی را که با دلیل ذکر شده رد شده است برمی‌گرداند.</li>
</ul>
<p>Promises یک ویژگی قدرتمند جاوا اسکریپت برای مدیریت عملیات ناهمزمان است. آنها روشی قوی‌تر برای مدیریت کد ناهمزمان در مقایسه با رویکردهای قدیمی‌تر مبتنی بر تماس ارائه می‌کنند. درک وضعیت‌هایی که یک وعده می‌تواند در آن باشد، و همچنین روش‌های موجود برای مدیریت وعده‌ها، برای برنامه‌نویسی موثر جاوا اسکریپت، به ویژه هنگام کار با APIهای وب مدرن و الگوهای کد ناهمزمان، بسیار مهم است.</p>
</section>

<section id="Promises3">
<h2>ایجاد و استفاده از وعده‌ها</h2>
<p>یک وعده نشان دهنده تکمیل (failure) نهایی یک عملیات ناهمزمان و مقدار حاصل از آن است. در اینجا نحوه استفاده از آنها آمده است:</p>

<h3>ایجاد یک Promise</h3>
<p>یک وعده با سازنده Promise که یک تابع مجری می‌گیرد، نمونه‌سازی می‌شود. این تابع بلافاصله توسط اجرای Promise اجرا می‌شود و دو تابع را به عنوان پارامتر دریافت می‌کند که به طور سنتی به نام‌های Resol و Reject نامیده می‌شود.</p>
<img src="./images/7.87 photo.png" width="450" alt="7.87">
<p>استفاده از Promises: هنگامی که یک قول دارید، می‌توانید تماس‌های برگشتی را برای رسیدگی به تحقق (then.) یا رد (catch.) به آن متصل کنید.</p>
<img src="./images/7.88 photo.png" width="450" alt="7.88">

</section>
<section id="Promises4">
<h3> فچ کردن - Fetch
</h3>
<p>بیایید از Fetch API برای فچ کردن داده ها از یک URL استفاده کنیم و ببینیم چگونه وعده ها عملیات ناهمزمان را ساده می کنند.
</p>
<img src="./images/7.89 photo.png" width="450" alt="7.89">
<p>در این مثال، fetch() یک وعده را برمی گرداند، که به ما امکان می دهد .then() را برای سناریوهای موفقیت و .catch() را برای مدیریت خطاها زنجیره کنیم.
</p>

</section>
<section id="Promises5">
<h3>مدیریت چندین عملیات ناهمزمان
</h3>
<p>گاهی اوقات، ممکن است لازم باشد چندین عملیات را انجام دهید که به نتایج یکدیگر بستگی ندارد. در چنین مواردی، Promise.all() می تواند فوق العاده مفید باشد زیرا منتظر می ماند تا همه وعده ها حل و فصل شوند.
</p>
<img src="./images/7.90 photo.png" width="450" alt="7.90">
<p>این مثال تلاش می کند تا داده ها را از دو URL فچ  کند. Promise.all() تضمین می‌کند که ما فقط زمانی ادامه می‌دهیم که تمام درخواست‌های فچ  تکمیل شوند و به ما امکان می‌دهد نتایج را به صورت جمعی مدیریت کنیم.
</p>

</section>
<section id="Promises6">
<h3>ایجاد یک وعده جدید:
</h3>
<img src="./images/7.91 photo.png" width="450" alt="7.91">
<div>
  <img src="./images/7.92 photo.png" width="450" alt="7.92">
</div>
<p>در این کد، myPromise یک شی جدید Promise است. تابع executor در new Promise() بلافاصله اجرا می شود و قرار است در نهایت حل (برای موفقیت) یا reject (برای شکست) را فراخوانی کند.
</p>
<h4>نتیجه گیری و بهترین شیوه ها
</h4>
<p>وعده ها به طور قابل توجهی مدیریت کد ناهمزمان را در جاوا اسکریپت ساده می کند. در اینجا برخی از بهترین شیوه ها وجود دارد:
</p>
<ul>
<li>هنگام رسیدگی به وعده‌ها، از async/wait برای نحو تمیزتر استفاده کنید.
</li>
<li>همیشه با استفاده از .catch () یا try/catch با async/await، رد وعده ها را مدیریت کنید.
</li>
<li>از Promise.all() برای عملیات ناهمزمان همزمان که به یکدیگر وابسته نیستند استفاده کنید.
</li>
</ul>

</section>

</section>


<section id="Promises7">
<h3>مثال: فچ کردن داده های محصول
</h3>
<p>در این سناریو، ما یک برنامه وب ساده ایجاد می کنیم که داده های محصول را از URL ارائه شده فچ  می کند و آن را در صفحه نمایش می دهد. ما از ویژگی‌های جاوا اسکریپت مدرن مانند فچ  برای بازیابی داده‌ها، همگام‌سازی/انتظار برای عملیات ناهمزمان و الگوهای واقعی برای تولید HTML استفاده خواهیم کرد. این برنامه همچنین با CSS برای ارائه جذاب‌تر استایل‌بندی می‌شود.
</p>
<section id="Promises8">
<h3>مرحله 1: ساختار HTML را تنظیم کنید
</h3>
<p>
ابتدا یک فایل HTML ایجاد می کنیم که شامل یک محفظه برای محصولات و یک تگ اسکریپت برای گنجاندن کد جاوا اسکریپت ما است.
</p>
<p>index.html
</p>
<img src="./images/7.93 photo.png" width="450" alt="7.93">
</section>
<section id="Promises9">
<h3>مرحله 2: یک سبک CSS
</h3>
<p>یک فایل style.css ایجاد کنید.
</p>
<img src="./images/7.94 photo.png" width="450" alt="7.94">
<div>
  <img src="./images/7.95 photo.png" width="450" alt="7.95">
</div>
<img src="./images/7.96 photo.png" width="450" alt="7.96">
</section>
<section id="Promises10">
<h3>مرحله 3: فچ  و نمایش محصولات با جاوا اسکریپت
</h3>
<p>در نهایت، ما script.js را برای فچ کردن داده های محصول و نمایش هر محصول در صفحه HTML پیاده سازی می کنیم.
</p>
<img src="./images/7.97 photo.png" width="450" alt="7.97">
<div>
  <img src="./images/7.98 photo.png" width="450" alt="7.98">
</div>
<p>توضیح کد جاوا اسکریپت:
</p>
<ul>
<li>تابع Async fetchProducts: این تابع به طور ناهمزمان داده های محصول را از URL داده شده با استفاده از fetch فچ می کند. از انتظار برای تکمیل فچ استفاده می‌کند، که باعث می‌شود کد هماهنگ به نظر برسد و خواندن آن آسان‌تر شود.
</li>
<li>مدیریت خطا: اگر درخواست فچ ناموفق باشد (خطای شبکه یا وضعیت پاسخ درست نیست)، یک خطا پرتاب می‌شود و در بلوک catch ثبت می‌شود، جایی که در کنسول ثبت می‌شود.
</li>
<li>نمایش محصولات: هنگامی که داده ها با موفقیت فچ شد و به JSON تبدیل شد، displayProducts با داده های محصول فچ شده فراخوانی می شود. این تابع بر روی هر محصول تکرار می شود، یک عنصر HTML جدید برای هر یک ایجاد می کند و آن را در DOM قرار می دهد. تصویر، نام و قیمت محصول نمایش داده می شود.
</li>
<li>فراخوانی fetchProducts: در نهایت، ما fetchProducts را فراخوانی می کنیم تا هنگام بارگیری اسکریپت، عملیات فچ را آغاز کنیم.
</li>
</ul>
<p>این مثال نحوه استفاده از ویژگی‌های جاوا اسکریپت مدرن را برای فچ داده‌ها از یک API راه دور و نمایش آن در یک صفحه وب نشان می‌دهد. ما از async/wait برای کدهای ناهمزمان با خوانایی آسان و الفبای الگو برای تولید پویا HTML بر اساس داده‌های فچ شده استفاده کردیم. استفاده از CSS flexbox تضمین می کند که محصولات به خوبی در صفحه چیده شوند.
</p>
<img src="./images/7.99 photo.png" width="450" alt="7.99">

</section>

</section>
<sectin id="wob" >
<h3>مقدمه ای بر Web Workers
</h3>
<p>در توسعه وب مدرن، حفظ یک رابط کاربری روان و پاسخگو در حین انجام عملیات پیچیده می تواند چالش برانگیز باشد. جاوا اسکریپت که تک رشته ای است، در همان رشته رابط کاربری اجرا می شود و آن را مستعد مسدود کردن عملیاتی می کند که می تواند صفحه را مسدود کند. اینجاست که Web Workers وارد عمل می‌شود و راه‌حلی قدرتمند را با فعال کردن وظایف به موازات موضوع اصلی ارائه می‌دهد.
</p>
</sectin>
<sectin id="wob1">
<h3>Web Workers چیست؟
</h3>
<p>Web Workers به شما این امکان را می دهد که عملیات جاوا اسکریپت را در رشته های پس زمینه اجرا کنید و رشته اصلی را برای تعاملات UI آزاد نگه دارید. این اجرای موازی تضمین می کند که وظایف سنگین رابط کاربری را مسدود نمی کند و پاسخگویی برنامه های وب را بهبود می بخشد.
</p>

</sectin>
<sectin id="wob2">
<h3>انواع کارگران - Workers
</h3>
<p>کارگران اختصاص داده شده: کارگران متعهد که به خالق خود گره خورده اند، فقط می توانند با رشته ای که آنها را ایجاد کرده ارتباط برقرار کنند، و آنها را برای تخلیه وظایف خاص و فشرده از رشته اصلی ایده آل می کند.
</p>
<ul>
<li>Shared Workers: این کارگران را می توان با چندین اسکریپت – حتی در پنجره ها یا برگه های مختلف مرورگر – که تعاملات پیچیده تر و به اشتراک گذاری داده ها را تسهیل می کند، قابل دسترسی است.
</li>
<li>Service Workers: به عنوان یک پروکسی شبکه عمل می‌کند، سرویس‌کاران تجربه‌های آفلاین غنی، همگام‌سازی پس‌زمینه، و اعلان‌های فشاری را در میان چیزهای دیگر فعال می‌کنند. آنها نقش مهمی در توسعه برنامه های وب پیشرو (PWA) دارند.
</li>
</ul>
</sectin>
<section id="wob3">
<h3>مثال عملی: Web Workers
</h3>
<p>بیایید یک مثال مدرن و پاسخگو ایجاد کنیم که استفاده از Web Workers را در یک برنامه وب نشان می دهد. ما یک برنامه ساده خواهیم ساخت که اعداد فیبوناچی را در پس زمینه محاسبه می کند. هدف حفظ یک رابط کاربری پاسخگو حتی در حین انجام وظایف محاسباتی فشرده است.
</p>
<p> سناریو: ماشین حساب فیبوناچی با Web Worker <br/>
این اپلیکیشن به کاربران اجازه می دهد تا عددی را وارد کنند و عدد فیبوناچی مربوطه را در پس زمینه با استفاده از Web Worker محاسبه می کند. دنباله فیبوناچی به دلیل سادگی انتخاب شده است و به دلیل اینکه محاسبه آن می تواند برای ورودی های بزرگ منابع فشرده باشد، و آن را برای این نمایش ایده آل می کند.
</p>

</section>
<section id="wob4">
<h3>مرحله 1: ساختار پروژه
</h3>
<p>
یک پوشه پروژه با فایل های زیر ایجاد کنید:

<ul>
<li>index.html - ساختار HTML برنامه ما.
</li>
<li>style.css - برای استایل دادن به برنامه ما.
</li>
<li>main.js - فایل اصلی جاوا اسکریپت برای تعامل رابط کاربری.
</li>
<li>fibonacciWorker.js - اسکریپت Web Worker که اعداد فیبوناچی را محاسبه می کند.
</li>

</ul>
</p>
<p>index.html
</p>
<img src="./images/7.100 photo.png" width="450" alt="7.100">
<div>
  <img src="./images/7.101 photo.png" width="450" alt="7.101">
</div>

<p>Styling (style.css)
</p>
<img src="./images/7.102 photo.png" width="450" alt="7.102">
<p>منطق موضوع اصلی (main.js)
</p>
<img src="./images/7.103 photo.png" width="450" alt="7.103">
<p>Worker Thread Logic - منطق موضوع کارگر (fibonacciWorker.js)
</p>
<img src="./images/7.104 photo.png" width="450" alt="7.104">
<div><img src="./images/7.105 photo.png" width="450" alt="7.105">
</div>

</section>
<section id="wob5">
<h3>توضیحات گام به گام:
</h3>
<ul>
<li>راه اندازی HTML: ما یک رابط کاربری ساده با ورودی برای عدد، یک دکمه برای شروع محاسبه و یک div برای نمایش نتیجه تعریف می کنیم.
</li>
<li>CSS Styling: برای بهبود خوانایی و قابلیت استفاده، یک ظاهر طراحی اولیه را برای عناصر UI ما ارائه می دهد.
</li>
<li>Main Thread Logic: Web Worker را راه اندازی می کند و شنوندگان رویداد را برای عناصر UI تنظیم می کند. شماره ورودی را برای پردازش به کارگر می فرستد و نتیجه یا پیام های خطای دریافتی از کارگر را نمایش می دهد.
</li>
<li>Web Worker Logic: به پیام هایی از رشته اصلی گوش می دهد، محاسبه فیبوناچی را انجام می دهد و نتیجه را به رشته اصلی ارسال می کند.
</li>
</ul>
</section>
<section>
<h3>بهترین توصیه ها:
</h3>
<ul>
<li>موارد استفاده: Web Workers برای کارهایی مانند پردازش داده ها، محاسبات پیچیده و سایر عملیاتی که در غیر این صورت رشته UI را مسدود می کنند، ایده آل هستند.
</li>
<li>ارتباطات: کارگران از طریق پیام‌ها با موضوع اصلی ارتباط برقرار می‌کنند و از کپسوله‌سازی داده‌ها و ایمنی رشته اطمینان می‌دهند.
</li>
<li>محدودیت‌ها: کارگران به DOM دسترسی ندارند و در یک زمینه محدود اجرا می‌شوند، که آنها را برای محاسبات خارج از رشته UI مناسب می‌کند.
</li>
<li>از Web Workers برای محاسبات فشرده برای پاسخگو نگه داشتن رابط کاربری استفاده کنید.
</li>
<li>کارگران را زمانی که دیگر برای آزاد کردن منابع لازم نیست خاتمه دهید: worker.terminate();.
</li>
<li>مدیریت خطا: اطمینان حاصل کنید که خطاها را هم در اسکریپت اصلی و هم در اسکریپت کارگر مدیریت می کنید.
</li>
<li>بهینه سازی الگوریتم ها برای عملکرد بهتر، به ویژه در کارگران برای به حداقل رساندن زمان محاسبات.
</li>
</ul>
<p>این مثال نشان می‌دهد که چگونه می‌توان از Web Workers برای انجام محاسبات پیچیده بدون مسدود کردن UI استفاده کرد و تجربه کاربری روان را تضمین کرد.
</p>
<p>Web Workers یک مدل قوی برای اجرای وظایف فشرده بدون به خطر انداختن تجربه کاربر ارائه می‌دهد و آنها را به ابزاری ضروری در جعبه ابزار توسعه‌دهندگان وب مدرن تبدیل می‌کند.
</p>
</section>
<section id="final">
<p>**نتیجه**</p>
<p>همانطور که به پایان سفر خود از طریق جنبه های اساسی HTML، CSS و جاوا اسکریپت می رسیم، مهم است که در مسیری که طی کرده ایم فکر کنیم. از اصول ساختاردهی صفحات وب با HTML گرفته تا سبک سازی آنها با CSS، و در نهایت به افزودن تعامل با جاوا اسکریپت، ما طیف گسترده ای از اصول توسعه وب را پوشش داده ایم که برای هر توسعه دهنده وب مشتاق ضروری است.</p>
<p>اما سفر به اینجا ختم نمی شود. دنیای توسعه وب بسیار گسترده و دائماً در حال تغییر است و استانداردها، چارچوب‌ها و بهترین شیوه‌های جدید همیشه در حال ظهور هستند. دانشی که به دست آورده اید یک پایه محکم است، اما یادگیری و تمرین مستمر کلید پیشرفت مهارت های شما و به روز ماندن در این زمینه پویا است.</p>
<p>برای کسانی که مشتاق به کاوش عمیق تر و گسترش درک خود از توسعه وب هستند، منابع فراوانی در انتظار است. یک منبع با ارزش ویژه، اسناد وب شبکه توسعه دهنده موزیلا (MDN) است:</p>
</section>
<section id="MDN">
<h4>MDN Web Docs - JavaScript را یاد بگیرید</h4>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN Web Docs - JavaScript را یاد بگیرید</a></p>
<p>MDN Web Docs مخزن گسترده ای از دانش است که آموزش های عمیق، راهنماها و مواد مرجع در HTML، CSS، جاوا اسکریپت و موارد دیگر را ارائه می دهد. چه به دنبال تعمیق درک خود از جاوا اسکریپت، کاوش در موضوعات پیشرفته، یا یادگیری در مورد آخرین فن آوری های وب و API ها هستید، MDN Web Docs یک منبع ضروری است.</p>
<p>به یاد داشته باشید، سفر یادگیری توسعه وب یکی از کاوش و کشف مداوم است. به طور منظم تمرین کنید، پروژه بسازید، و از آزمایش کردن و اشتباه کردن نترسید – همه اینها بخشی از فرآیند یادگیری است. با جامعه توسعه‌دهنده تعامل داشته باشید، در پروژه‌های منبع باز مشارکت داشته باشید و مرزهای آنچه را که می‌توانید ایجاد کنید ادامه دهید.</p>
<p>مهارت‌هایی که توسعه داده‌اید، تازه شروع کار هستند. با فداکاری، خلاقیت و اشتیاق به یادگیری، شما در راه تبدیل شدن به یک توسعه دهنده وب ماهر هستید. وب بوم نقاشی شماست - پیش بروید و ایجاد کنید!</p>
<p>از اینکه با ما این سفر آموزشی را آغاز کردید متشکریم. در اینجا موفقیت مداوم شما در دنیای توسعه وب است!</p>
</section>
</section>
  </section>


    
  </div>
  <button class="section-nav-toggle" aria-label="Toggle menu">
    <div class="section-nav-toggle-bar">⌘ </div>
  </button>
  
  <nav class="section-nav" >


    <ol>
      <li><a href="#introduction">مقدمه</a></li>
      <li><a href="#introduction">برنامه نویسی چیست و چرا باید آن را یاد گرفت؟
</a></li> 
<ul>
      <li><a href="#request-response">چرا یادگیری کدنویسی؟ </a></li>

</ul>
      <li><a href="#authentication">مفاهیم برنامه نویسی</a>
        <ul>
          <li><a href="#Variables">متغیرها</a></li>
          <li><a href="#Data">انواع داده</a></li>
          <li><a href="#Operators">عملگرها</a></li>
          <li><a href="#Conditional Statements">شرط‌ها</a></li>
          <li><a href="#Loops">حلقه‌ها</a></li>
          <li><a href="#Functions">توابع</a></li>
          
        </ul>
      </li>
      <li><a href="#endpoints">کامپایل کردن یعنی چی؟ </a>
        <ul>
          <li class=""><a href="#nemoneh-compile">نمونه ای از کامپایل</a></li>
          </ul>
          <li class=""><a href="#zaban">مروری کوتاه بر زبان های برنامه نویسی
</a></li>
          <li class=""><a href="#Dark">درک کامپیوترها</a>
          </li>
          <li class="">
            <a href="#rahandaz">راه‌اندازی جعبه ابزار</a>
            <ul>
              <li class=""><a href="#editor">انتخاب یک ویرایشگر متن یا ویرایشگر کد</a>
          </li>
            <li class=""><a href="#browser">مرورگرهای وب و نقش آنها</a>
          </li>
            </ul>
          </li>

          
          <li class=""><a href="#chapter2">فصل دوم</a></li>
          <li class=""><a href="#Hyper">Hyper Text Markup Language</a>
<ul>
  <li class=""><a href="#sakhtar">ساختار اصلی یک سند HTML</a>
          </li>
          <li class=""><a href="#HTML Elements">HTML Elements</a>
          </li>
        </ul>
          </li>
        
      </li>
      <li class=""><a href="#Nesting elements">عناصر تودرتو</a></li>
      <ul>
          <li class=""><a href="#Void elements">عناصر خالی</a></li>
      </ul>
      <li><a href="#Avalieh">برخی از عناصر اولیه</a></l>
        <ul>
          <li class=""><a href="#Text">تصاویر / Images</a></li>
          <li class=""><a href="#headings">سرفصل ها / Heading</a></li>
          <li class=""><a href="#Paragraph">پاراگراف ها / Paragraphs</a></li>
          <li class=""><a href="#List">لیست ها / Lists</a></li>
          <li class=""><a href="#Link">پیوندها / Links</a></li>
</ul>
      <li class=""><a href="#HTML">مزایای چیدمان معنایی HTML5</a></li>
      <li class=""><a href="#chapter3">فصل سوم</a></li>
      <li class=""><a href="#chapter3">CSS چیست؟</a></li>
<li class=""><a href="#ghavaed">درک عمیق‌تر ساختار و اصطلاحات قواعد CSS:</a>
<ol>
  <li class=""><a href="#Layout">ویژگی های طرح بندی / Layout Properties</a></li>
<li class=""><a href="#Flexbox">Flexbox , Grid</a></li>
<li class=""><a href="#Box">ویژگی های مدل جعبه / Box Model Properties</a></li>
<li class=""><a href="#Typography">خواص تایپوگرافی / Typography Properties</a></li>

<li class=""><a href="#properties">ویژگی های جلوه های بصری / Visual Effects Properties</a></li>

<li class=""><a href="#Animation">انیمیشن و انتقال / Animation and Transitions</a></li>
<li class=""><a href="#Miscellaneous">خواص متفرقه / Miscellaneous Properties</a></li>

</li>
<li class=""><a href="#mafahimasasi"> برخی از مفاهیم اساسی CSS که فراتر از ویژگی ها هستند:</a>
<ul>
<li class=""><a href="#emtehan"> بیایید امتحان کنیم!</a></li> 
</ul>
</li>

<li class=""><a href="#font">فونت و متن / Fonts and text</a></li>

<li class=""><a href="#cssbox">CSS: همه چیز درباره جعبه ها Boxes</a>
<ul>
<li class=""><a href="#tagheire-rang">تغییر رنگ صفحه</a></li>
<li class=""><a href="#style-body">حالت دادن به بدن / Styling the body</a></li>
<li class=""><a href="#style-safhe">تعیین موقعیت و استایل کردن عنوان صفحه اصلی</a></li>
<li class=""><a href="#position">مکان تصویر را تغییر دهید / Change the image position
</a></li>
</ul>
</li>

</a></li><li class=""><a href="#chapter4">فصل چهارم</a></li>
<li class=""><a href="#chapter3">CSS چیست؟

</a></li><li class=""><a href="#api">(API (Application Programming Interfaces
</a>
<ul>

<li class=""><a href="#api1">API ها چیست؟
</a></li>
<li class=""><a href="#api2">انواع API ها
</a></li>
<li class=""><a href="#api3">معماری API</a></li>
</ul>
</li>



<li class=""><a href="#soap">SOAP) Simple Object Access Protocol)
</a>
<ul>
<li class=""><a href="#soap1">ویژگی های کلیدی SOAP
</a></li>
<li class=""><a href="#soap2">مزایا و معایب SOAP
</a></li>
</ul>
</li>



<li class=""><a href="#rest">(REST) Representational State Transfer</a>
<ul>


<li class=""><a href="#rest1">موارد استفاده ایده آل برای REST</a></li>
<li class=""><a href="#rest2">روش های REST API و ساختار درخواست
</a></li>
<li class=""><a href="#rest3">ساختار پاسخ REST
</a></li>
<li class=""><a href="#rest4">REST در مقابل SOAP: ملاحظات عملکرد
</a></li>
</ul>
</li>

<li class=""><a href="#graph">GraphQL</a>
<ul>
<li class=""><a href="#graph1">تشخیص GraphQL از REST</a></li>
<li class=""><a href="#graph2">مفاهیم کلیدی در GraphQL</a></li>
<li class=""><a href="#graph3">ساخت GraphQL API</a></li>
</ul>
</li>




<li class=""><a href="#google">gRPC) Google Remote Procedure Call)</a>

<ul>
<li class=""><a href="#google1">تماس رویه از راه دور (RPC) چیست؟</a></li>
<li class=""><a href="#google2">اصول اصلی gRPC</a></li>
<li class=""><a href="#google3">نمونه ای از سرویس gRPC</a></li>
</ul>

</li>

<li class=""><a href="#socket">وب سوکت</a>
<ul>
<li class=""><a href="#socket1">ویژگی های اصلی WebSocket</a></li>
<li class=""><a href="#socket2">چه زمانی از WebSocket استفاده کنیم؟</a></li>
<li class=""><a href="#socket3">مثالی از استفاده از WebSocket</a></li>
</ul>
</li>

<li class=""><a href="#hook">وب هوک</a>
<ul>
<li class=""><a href="#hook1">ویژگی های اصلی WebHooks</a></li>
<li class=""><a href="#hook2">ویژگی های اصلی WebHooks</a></li>
<li class=""><a href="#hook3">چه زمانی از WebHooks استفاده کنیم؟</a></li>
</ul>
</li>

<li class=""><a href="#mq">MQTT) Message Queuing Telemetry Transport)</a>
<ul>
<li class=""><a href="#mq1">ویژگی های اصلی MQTT</a></li>
<li class=""><a href="#mq2">چه زمانی از MQTT استفاده کنیم؟</a></li>
<li class=""><a href="#mq3">مثالی از استفاده از MQTT</a></li>
</ul>
</li>

<li class=""><a href="#am">AMQP) Advanced Message Queuing Protocol)</a>
<ul>

<li class=""><a href="#am1">ویژگی های اصلی AMQP</a></li>
<li class=""><a href="#am2">چه زمانی از AMQP استفاده کنیم؟</a></li>
<li class=""><a href="#am3">نمونه ای از استفاده از AMQP</a></li>
</ul>
</li>
<li class=""><a href="#memari">انتخاب معماری بهینه API</a></li>

<li class=""><a href="#js">فصل پنجم
</a></li>
<li class=""><a href="#js">گام های اول جاوا اسکریپت: راهنمای مقدماتی
</a>
<ul>
<li class=""><a href="#js1">جاوا اسکریپت چیست</a></li>
<li class=""><a href="#js2">نقش جاوا اسکریپت در توسعه وب</a></li>
<li class=""><a href="#js3">یک مثال ساده</a></li>
<li class=""><a href="#js4">روش های مختلف برای اضافه کردن جاوا اسکریپت</a></li>
<li class=""><a href="#js5">کد داخلی جاوا اسکریپت</a></li>
<li class=""><a href="#js6">کد خارجی جاوا اسکریپت</a></li>
<li class=""><a href="#js7">کنترل کننده های درون خطی جاوا اسکریپت - Javascript I</a></li>
</ul>
</li>
<li class=""><a href="#add">addEventListener به عنوان جایگزینی برای کنترل کننده های جاوا اسکریپت درون خطی</a>
<ul>
<li class=""><a href="#add1">چرا addEventListener ترجیح داده می شود؟</a></li>
<li class=""><a href="#add2">نمونه ای از استفاده از addEventListener</a></li>
</ul>
</li>
<li class=""><a href="#strategy">استراتژی های بارگذاری اسکریپت و بهترین روش</a>
<ul>
<li class=""><a href="#strategy1">بهترین روش بارگذاری اسکریپت - Best Practices</a>
</li>

</ul>
</li>

<li class=""><a href="#comment">نظرات (توضیحات) در جاوا اسکریپت - Comments</a>
<ul>
<li class=""><a href="#comment1">نظرات تک خطی</a></li>
<li class=""><a href="#comment2">نظرات چند خطی</a></li>
<li class=""><a href="#comment3">غیرفعال کردن کد برای اشکال زدایی</a></li>
</ul>
</li>

<li class=""><a href="#code">کدهای جاوا اسکریپت به چه ترتیبی اجرا می شوند؟</a>
<ul>
<li class=""><a href="#code1">کد تفسیر شده در مقابل کد کامپایل شده / Interpreted versus compiled code</a></li>
<li class=""><a href="#code2">کد سمت سرور Server-side در مقابل کد سمت سرویس گیرنده client-side </a></li>
<li class=""><a href="#code3">کد پویا Dynamic در مقابل استاتیک Static</a></li>
</ul>
</li>

<li class=""><a href="#API">چرا API ها در جاوا اسکریپت مهم هستند؟</a>
<ul>
<li class=""><a href="#API1">دسته بندی API ها در جاوا اسکریپت</a></li>
<li class=""><a href="#API2">استفاده عملی از API ها در جاوا اسکریپت</a></li>
</ul>
</li>

<li class=""><a href="#karbord">جاوا اسکریپت چه کاری می تواند انجام دهد؟</a></li>


<li class=""><a href="#fasle6">فصل ششم
تسلط بر مبانی جاوا اسکریپت</a></li>

<li class=""><a href="#declare">Variables Declaration / اعلان‌های متغیرها</a>
<ul>
<li class=""><a href="#declare1">تفاوت های کلیدی بین let و const</a></li>

<li class=""><a href="#declare2">بهترین  روش ها / Best Practices</a></li>
</ul>
</li>

<li class=""><a href="#var">Data Types</a>
<ul>

<li class=""><a href="#var1">شماره ها / Numbers</a></li>
<li class=""><a href="#var2"> رشته ها / Strings </a></li>
<li class=""><a href="#var3">بولین ها / Booleans</a></li>
<li class=""><a href="#var4">آرایه ها / Arrays</a></li>
<li class=""><a href="#var5">اشیاء / Objects</a></li>
<li class=""><a href="#var6">تایپ پویا / Dynamic Type</a></li>
</ul>
</li>

<li class=""><a href="#hesab">اعداد و عملگرهای حسابی</a>
<ul>
<li class=""><a href="#hesab1">اعداد صحیح در مقابل اعداد ممیز شناور</a></li>
<li class=""><a href="#hesab2">عملگرهای حسابی</a></li>
<li class=""><a href="#hesab3">اپراتورهای واگذار</a></li>
<li class=""><a href="#hesab4">مقایسه و عملگرهای منطقی</a></li>
<li class=""><a href="#hesab5">مقادیر عددی ویژه</a></li>
</ul>
</li>


<li class=""><a href="#modir">مدیریت متن در جاوا اسکریپت
</a>
<ul>
<li class=""><a href="#modir1">ایجاد رشته ها</a></li>
<li class=""><a href="#modir2">الفاظ الگو - Template Literals</a></li>
<li class=""><a href="#modir3">الفبای الگوی تو در تو</a></li>
<li class=""><a href="#modir4">برچسب‌گذاری شده با واژه‌های قالب / Tagged Template Literals</a></li>
<li class=""><a href="#modir5">رشته های رایج - String Methods</a></li>
<li class=""><a href="#modir6">Concatenation</a></li>
<li class=""><a href="#modir7">length</a></li>
<li class=""><a href="#modir8">دسترسی به کاراکترها - Characters</a></li>
<li class=""><a href="#modir9">جستجو در یک رشته - Searching Within a String</a></li>
<li class=""><a href="#modir10">استخراج زیر رشته ها - Extracting Substrings</a></li>
<li class=""><a href="#modir11">جایگزینی محتوا - Replacing Content</a></li>
<li class=""><a href="#modir12">تغییر حروف - Changing Case</a></li>
</ul>
</li>

<li class=""><a href="#araye">شرح مفصل آرایه ها / Arrays در جاوا اسکریپت</a>
<ul>
<li class=""><a href="#araye1">ایجاد و راه اندازی آرایه ها</a></li>
<li class=""><a href="#araye2">
دسترسی به آیتم های آرایه</a></li>
<li class=""><a href="#araye3">اصلاح آیتم های آرایه</a></li>
<li class=""><a href="#araye4">دسترسی و اصلاح آیتم های آرایه</a></li>
<li class=""><a href="#araye5">آرایه های چند بعدی - Multidimensional Arrays</a></li>
</ul>
</li>

<li class=""><a href="#shakhes">ویژگی ها و روش های آرایه / Array Properties and Methods</a>
<ul>
<li class=""><a href="#shakhes1">ویژگی length </a> </li>
<li class=""><a href="#shakhes2">افزودن و حذف موارد</a> </li>
<li class=""><a href="#shakhes3">یافتن آیتم ها و شاخص ها </a> </li>
</ul></li>

<li class=""><a href="#loop">حلقه روی آرایه ها - Looping over Arrays</a>
<ul>
<li class=""><a href="#loop1">حلقه for</a></li>
<li class=""><a href="#loop2">حلقه برای... از - For…of</a></li>
<li class=""><a href="#loop3">متد forEach</a></li>
</ul>
</li>

<li class=""><a href="#map">روش نقشه () - The map() Method</a></li>

<li class=""><a href="#nokte">نکاتی برای حلقه زدن آرایه ها</a></li>

<li class=""><a href="#tasmim">تصمیم گیری: تسلط بر شرایط در جاوا اسکریپت
</a>
<ul>
<li class=""><a href="#tasmim1">بیانیه if</a></li>
<li class=""><a href="#tasmim2">بیانیه دیگر- else</a></li>
<li class=""><a href="#tasmim3">بیانیه else if </a></li>
<li class=""><a href="#tasmim4">Nested if Statements</a></li>
<li class=""><a href="#tasmim5">اپراتورهای مقایسه - Comparison Operators</a></li>
<li class=""><a href="#tasmim6">عملگرهای منطقی - Logical Operators</a></li>
<li class=""><a href="#tasmim7">اپراتور سه گانه - The Ternary Operator</a></li>
<li class=""><a href="#tasmim8">بیانیه سوئیچ - The switch Statement</a></li>
<li class=""><a href="#tasmim9">HTML</a></li>
<li class=""><a href="#tasmim10">CSS (style.css)</a></li>
<li class=""><a href="#tasmim11">جاوا اسکریپت (script.js)</a></li>
<li class=""><a href="#tasmim12">توضیح</a></li>
</ul>
</li>


<li class=""><a href="#halghe">قدرت حلقه ها / Loops در جاوا اسکریپت</a>
<ul>
<li class=""><a href="#halghe1">چرا حلقه ها اهمیت دارند</a></li>
<li class=""><a href="#halghe2">مثال: نمایش فهرستی از نام ها</a></li>
<li class=""><a href="#halghe3">با یک حلقه</a></li>
<li class=""><a href="#halghe4">بدون حلقه</a></li>
<li class=""><a href="#halghe5">تاثیر حلقه ها</a></li>
<li class=""><a href="#halghe6">حلقه for</a></li>
<li class=""><a href="#halghe7">حلقه while</a></li>
<li class=""><a href="#halghe8">حلقه do...while</a></li>
<li class=""><a href="#halghe9">حلقه for...of</a></li>
<li class=""><a href="#halghe10">حلقه for...in </a></li>
<li class=""><a href="#halghe11">استفاده بهینه از حلقه ها</a></li>
<li class=""><a href="#halghe12">ترکیب حلقه ها با دستورات شرطی</a></li>
<li class=""><a href="#halghe13">
بیانیه های کنترل حلقه Loop Control Statements</a></li>
<li class=""><a href="#halghe14">مثال حلقه‌ها</a></li>
<li class=""><a href="#halghe15">HTML</a></li>
<li class=""><a href="#halghe16">CSS (styles.css)</a></li>
<li class=""><a href="#halghe17">جاوا اسکریپت (script.js)</a></li>
<li class=""><a href="#halghe18">توضیح</a></li>
</ul>
</li>


<li class=""><a href="#tabe">استفاده از قدرت توابع / Functions در جاوا اسکریپت</a>
<ul>
<li class=""><a href="#tabe1">مقدمه ای بر توابع</a></li>
<li class=""><a href="#tabe2">تعریف توابع</a></li>
<li class=""><a href="#tabe3">فراخوانی توابع</a></li>
<li class=""><a href="#tabe4"> پارامترهای تابع و آرگومان ها</a></li>
<li class=""><a href="#tabe5"> محدوده عملکرد - Function Scope</a></li>
<li class=""><a href="#tabe6"> محدوده عملکرد داخل</a></li>
<li class=""><a href="#tabe7"> دامنه جهانی</a></li>
<li class=""><a href="#tabe8">پیمایش درگیری ها و نگرانی های امنیتی </a></li>
<li class=""><a href="#tabe9">قیاس باغ وحش: تصویری در محدوده </a></li>
<li class=""><a href="#tabe10"> Best Practices</a></li>
<li class=""><a href="#tabe11"> توابع ناشناس و عبارات تابع - Anonymous Functions and Function Expressions</a></li>
<li class=""><a href="#tabe12">توابع پیکان - Arrow Functions</a></li>
<li class=""><a href="#tabe13">یک مثال عملی توابع</a></li>
<li class=""><a href="#tabe14">ساختار HTML</a></li>
<li class=""><a href="#tabe15">CSS Style</a></li>
<li class=""><a href="#tabe16">توابع جاوا اسکریپت</a></li>
<li class=""><a href="#tabe17">توضیح گام به گام:</a></li>
  </ul>
</li>

<li class=""><a href="#meghdar">مقدمه ای بر مقادیر بازگشتی تابع - Function Return Values</a>
<ul>
<li class=""><a href="#meghdar1">ارزش های بازگشتی / Return Values دقیقاً چیست؟</a></li>
<li class=""><a href="#meghdar2">استفاده از مقادیر بازگشتی در توابع سفارشی</a></li>
<li class=""><a href="#meghdar3">کاربرد دنیای واقعی: تحلیل اعداد تعاملی</a></li>
<li class=""><a href="#meghdar4">نتیجه‌گیری: ارزش‌های بازده</a></li>
</ul>
</li>

<li class=""><a href="#roydad">مقدمه ای بر رویدادهای جاوا اسکریپت - Events in JS</a>
<ul>
<li class=""><a href="#roydad1">یک رویداد دقیقاً چیست؟</a></li>
<li class=""><a href="#roydad2">استفاده از addEventListener()</a></li>
<li class=""><a href="#roydad3">گسترش افق رویداد</a></li>
<li class=""><a href="#roydad4">حذف شنوندگان رویداد</a></li>
<li class=""><a href="#roydad5">انتشار رویداد: حباب زدن و گرفتن</a></li>
<li class=""><a href="#roydad6">قدرت نمایندگی رویداد</a></li>
<li class=""><a href="#roydad7">رویدادهای فراتر از صفحه وب</a></li>
<li class=""><a href="#roydad8">سناریوی عملی: گالری تصاویر تعاملی</a></li>
<li class=""><a href="#roydad9">ساختار HTMl</a></li>
<li class=""><a href="#roydad10">CSS (style.css)</a></li>
<li class=""><a href="#roydad11">جاوا اسکریپت (script.js)</a></li>
</ul></li>



<li class=""><a href="#fasl7">مقدمه فصل هفتم: برنامه نویسی شی گرا</a></li>
<li class=""><a href="#shey">مقدمه فصل هفتم: برنامه نویسی شی گرا</a>
<ul>
<li class=""><a href="#shey1">برنامه نویسی شی گرا چیست؟</a></li>
<li class=""><a href="#shey2">چرا جاوا اسکریپت یک زبان شی گرا در نظر گرفته می شود؟</a></li>
<li class=""><a href="#shey3">اشیاء جاوا اسکریپت - Object in JS</a></li>
<li class=""><a href="#shey4">درک ماهیت اشیاء جاوا اسکریپت</a></li>
<li class=""><a href="#shey5">پیش نیازها:</a></li>
<li class=""><a href="#shey6">آناتومی اشیاء جاوا اسکریپت</a></li>
<li class=""><a href="#shey7">بینش های کلیدی:</a></li>
<li class=""><a href="#shey8">دسترسی به ویژگی های شی: نماد نقطه و براکت</a></li>
<li class=""><a href="#shey9">سازندگان: طرح‌بندی اشیاء</a></li>
<li class=""><a href="#shey10">سناریوی عملی: ایجاد رابط کتابخانه دیجیتال</a></li>
<li class=""><a href="#shey11">ساختار HTML</a></li>
<li class=""><a href="#shey12">CSS Style</a></li>
<li class=""><a href="#shey13">JavaScript: حیات بخشیدن به کتابخانه</a></li>
</ul></li>



<li class=""><a href="#aval">نمونه های اولیه / Prototype </a>
<ul>
<li class=""><a href="#aval1">مقدمه ای بر نمونه های اولیه اشیاء</a></li>
<li class=""><a href="#aval2">ملزومات زنجیره های اولیه</a></li>
<li class=""><a href="#aval3">درک وراثت نمونه اولیه</a></li>
<li class=""><a href="#aval4">ویژگی های سایه زدن - Shadowing Properties</a></li>
<li class=""><a href="#aval5">تنظیم نمونه اولیه یک شی </a></li>
<li class=""><a href="#aval6">استفاده از سازندگان  -Utilizing Constructors </a></li>
<li class=""><a href="#aval7">نمونه های اولیه: ستون فقرات اشیاء جاوا اسکریپت</a></li>
<li class=""><a href="#aval8">سناریو: انتخابگر شکل</a></li>
<li class=""><a href="#aval9">ساختار HTML</a></li>
<li class=""><a href="#aval10">استایل CSS</a></li>
<li class=""><a href="#aval11">منطق جاوا اسکریپت</a></li>
<li class=""><a href="#aval12">گسترش مثال انتخاب شکل</a></li>
<li class=""><a href="#aval13">سناریوی اضافی: ایجاد شکل پویا</a></li>
<li class=""><a href="#aval14">گسترش HTML</a></li>
<li class=""><a href="#aval15">اصلاح جاوا اسکریپت</a></li>
</ul></li>


<li class=""><a href="#mofid">چرا توابع/کلاس های سازنده مفید هستند؟</a></li>



<li class=""><a href="#script">کلاس‌های جاوا اسکریپت</a>
<ul>
<li class=""><a href="#script1">مقدمه ای بر کلاس های جاوا اسکریپت</a></li>
<li class=""><a href="#script2">درک کلاس ها و سازندگان</a></li>
<li class=""><a href="#script3">اجرای وراثت</a></li>
<li class=""><a href="#script4">کپسوله سازی / Encapsulation با خواص و روش های خصوصی</a></li>
<li class=""><a href="#script5">مثال عملی: ماشین حساب شکل</a></li>
<li class=""><a href="#script6">ساختار HTML</a></li>
<li class=""><a href="#script7">CSS Styling</a></li>
<li class=""><a href="#script8">منطق جاوا اسکریپت</a></li>
</ul></li>

<li class=""><a href="#metod">آشنایی با متدها در جاوا اسکریپت</a>
<ul>
<li class=""><a href="#metod1">مفاهیم کلیدی روش ها:</a></li>
<li class=""><a href="#metod2">متدهای اعلام - Declaring Methods</a></li>
<li class=""><a href="#metod3">سینتکس متد ES6</a></li>
<li class=""><a href="#metod4">متدهای داخلی شی - Built-in Object Methods</a></li>
<li class=""><a href="#metod5">متدهای رشته ای - String Methods</a></li>
<li class=""><a href="#metod6">متدهای آرایه - Array Methods</a></li>
<li class=""><a href="#metod7">متدهای سفارشی - Custom Methods</a></li>
<li class=""><a href="#metod8">مثال: یک شیء شمارنده</a></li>
</ul>
</li>

<li class=""><a href="#tafavot">تفاوت بین توابع و متدها در جاوا اسکریپت</a>
<ul>
<li class=""><a href="#tafavot1">سناریو: یک شیء پست وبلاگ</a></li>
<li class=""><a href="#tafavot2">HTML(index.html)</a></li>
<li class=""><a href="#tafavot3"> CSS Style (Style.css)</a></li>
<li class=""><a href="#tafavot4">JavaScript (script.js)</a></li>
<li class=""><a href="#tafavot5">توضیح گام به گام:</a></li>

</ul>
</li>
<li class=""><a href="#JSON ">آشنایی با JSON در جاوا اسکریپت </a>
<ul>
<li class=""><a href="#JSON 1">ماهیت JSON</a></li>
<li class=""><a href="#JSON 2">کار با JSON در جاوا اسکریپت</a></li>
<li class=""><a href="#JSON 3">مثال: تجزیه / Parsing JSON</a></li>
<li class=""><a href="#JSON 4">مثال: ایجاد JSON</a></li>
</ul>
</li>

<li class=""><a href="#fail">کاربرد عملی: ساخت رابط کاربری</a>
<ul>
<li class=""><a href="#fail1">ساختار HTML</a></li>
<li class=""><a href="#fail2">فایل جاوا اسکریپت</a></li>
<li class=""><a href="#fail3">فایل user.json شامل:
</a></li>
</ul>
</li>

<li class=""><a href="#dastor">ساخت اشیاء با جاوا اسکریپت: نمایش ساده محصول تجارت الکترونیک</a>
<ul>
<li class=""><a href="#dastor1">دستورالعمل های گام به گام</a></li>
</ul> 
</li>
<li class=""><a href="#Asynchronous"> Asynchronous & Synchronous Javascript <br/>
آشنایی با جاوا اسکریپت ناهمزمان / Asynchronous
</a>
<ul>
<li class=""><a href="#Asynchronous1">تکامل جاوا اسکریپت ناهمزمان</a></li>
<li class=""><a href="#Asynchronous2">جاوا اسکریپت ناهمزمان در عمل</a></li>
<li class=""><a href="#Asynchronous3">تمرین عملی: ایجاد یک رابط کاربری برای داده های API</a></li>
<li class=""><a href="#Asynchronous4">مرحله 1: تنظیم HTML</a></li>
<li class=""><a href="#Asynchronous5">مرحله 2: اضافه کردن سبک با CSS</a></li>
<li class=""><a href="#Asynchronous6">مرحله 3: فچ  و نمایش داده ها با جاوا اسکریپت</a></li>
</ul>
</li>

<li class=""><a href="#barnameh">Synchronous Programming <br/>
برنامه نویسی سنکرون چیست؟
</a></li>


<li class=""><a href="#nahamzaman">تفاوت کلیدی بین برنامه‌نویسی ناهمزمان و همزمان</a>
<ul>
<li class=""><a href="#nahamzaman1">همزمان / Synchronous:</a></li>
<li class=""><a href="#nahamzaman2">نامتقارن / Asynchronous:</a></li>
<li class=""><a href="#nahamzaman3">Best Practices Asynchronous</a></li>
</ul>
</li>

<li class=""><a href="#Handlers">Event Handlers چیست؟</a></li>

<li class=""><a href="#Handlers1">مثال عملی: یک رویداد کلیک ساده</a></li>
<li class=""><a href="#Handlers2">
بهترین توصیه ها برای استفاده از رویداد Handlers</a></li>

</ul>
</li>


<li class=""><a href="#Promises">آشنایی با Promises در جاوا اسکریپت </a>
<ul>
<li class=""><a href="#Promises1">نحوه استفاده از وعده ها</a></li>
<li class=""><a href="#Promises2">روش های سودمند برای وعده های متعدد</a></li>
<li class=""><a href="#Promises3">ایجاد و استفاده از وعده ها</a></li>
<li class=""><a href="#Promises4"> فچ کردن - Fetch</a></li>
<li class=""><a href="#Promises5">مدیریت چندین عملیات ناهمزمان</a></li>
<li class=""><a href="#Promises6">ایجاد یک وعده جدید:</a></li>
<li class=""><a href="#Promises7">مثال: فچ کردن داده های محصول</a></li>
<li class=""><a href="#Promises8">مرحله 1: ساختار HTML را تنظیم کنید</a></li>
<li class=""><a href="#Promises9">مرحله 2: یک سبک CSS</a></li>
<li class=""><a href="#Promises10">مرحله 3: فچ  و نمایش محصولات با جاوا اسکریپت</a></li>
</ul>
</li>


<li class=""><a href="#wob">مقدمه ای بر Web Workers</a>
<ul>
<li class=""><a href="#wob1">Web Workers چیست؟</a></li>
<li class=""><a href="#wob2">انواع کارگران - Workers</a></li>
<li class=""><a href="#wob3">مثال عملی: Web Workers</a></li>
<li class=""><a href="#wob4">مرحله 1: ساختار پروژه</a></li>
<li class=""><a href="#wob5">توضیحات گام به گام:</a></li>

</ul>
</li>

<li class=""><a href="#final">نتیجه</a></li>
<li class=""><a href="#MDN">MDN Web Docs - JavaScript را یاد بگیرید</a></li>


      </li>
      
    </ol>

  </nav>
</main>
<script src="script.js"></script>
</body>
</html>




